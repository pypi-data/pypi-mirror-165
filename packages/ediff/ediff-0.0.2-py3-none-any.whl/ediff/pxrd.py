'''
ediff.pxrd
----------
Calculation of powder X-ray diffraction patterns.    
'''

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pymatgen.core.structure import Structure as pmStructure
from pymatgen.analysis.diffraction.xrd import XRDCalculator as pmXRDCalculator

class Crystal:
    
    def __init__(self, structure, temp_factors=0.8):
        # (1) Define structure
        if type(structure) == pmStructure:
            # Structure was generated by PyMatGen methods
            self.structure = structure
        else:
            # Structure is not from PyMatGen => we suppose CIF input
            self.structure = self.read_structure_from_CIF(structure)
        # (2) Define temperature factors
        if type(temp_factors) == dict:
            # Temperature factors were given as dictionary
            self.temp_factors = temp_factors
        else:
            # Temp.factors are not dictionary => we suppose a number
            # (the number is a universal temperature factor for all atoms
            self.temp_factors = self.get_elements_with_temp_factors(
                self.structure, temp_factors)
    
    @staticmethod
    def read_structure_from_CIF(CIF):
        structure = pmStructure.from_file(CIF)
        return(structure)

    def get_elements(self, structure):
        list_of_atoms = []
        for site in structure:
            for sp, occu in site.species.items():
                list_of_atoms.append(sp.symbol)
        list_of_elements = np.unique(list_of_atoms)
        return(list_of_elements)

    def get_elements_with_temp_factors(self, structure, B=0.8):
        elements = self.get_elements(structure)
        elements_with_temp_factors = dict.fromkeys(elements, B)
        return(elements_with_temp_factors)

class Experiment:
    
    def __init__(self, wavelength, two_theta_range):
        self.wavelength = wavelength
        self.two_theta_range = two_theta_range

class PlotParameters:
    '''
    PlotParameters = object defining local+global parameters for plotting.
    
    Parameters
    ----------
    title : str
        Title of the plot.
    x_axis : str, 'two_theta','S','q' or 'dhkl', optional, default is 'q'
        Quantity for X-axis.
    rcParams : dict; optional, the default is empty dictionary {}
        The dictionary shoud be formatted for mathplotlib.pyplot.rcParams.
        The argmument is passed to matplotlib.pyplot.
        The initialization procedure creates some default rcParams.
        This argument can override this pre-defined parameters,
        i.e. the default is created anyway
        and then (possibly) supplemented by rcParams argument.
    '''
    
    def __init__(self, title=None, x_axis='q', xlim=None, rcParams={}):
        # Docstring for __init__ are given above in class description.
        # Reason: In this way, the parameters are visible in Spyder/Ctrl+I.
        
        # Initialize basic parameters
        self.title = title
        self.x_axis = x_axis
        self.xlim = xlim
        self.rcParams = rcParams
        # Set global plot settings using rcParams
        self.set_default_rcParams(rcParams)

    @staticmethod
    def set_default_rcParams(my_rcParams={}):
        '''
        A class method defining global plot parameters (plt.rcParams).
        
        Parameters
        ----------
        my_rcParams : dictionary
            containing selected plt.rcParams keys)
            DESCRIPTION. The default is {}.

        Returns
        -------
        None, BUT it redefines global variable plt.rcParams!

        Notes:
        ------
        * This is a @classmethod (because it is used within the whole class)
          but it could be a @staticmethod as well (because it does not use
          cls variable in fact).
        * The method is employed in two ways:
            - standard usage of MCREEP package: default rcParams are used
              (and possibly modified) in objects of PlotParameters class
            - special usage of MCREEP (more figures, multiplots): default
              rcParams are used when definining the axes of (multiple)figures
        '''
        # (1) Set default rcParams
        # (Hardcoded, suitable default for standard plots
        plt.rcParams.update({
            'figure.figsize'     : (8/2.54,6/2.54),
            'figure.dpi'         : 500,
            'font.size'          : 7,
            'lines.linewidth'    : 0.8,
            'axes.linewidth'     : 0.6,
            'xtick.major.width'  : 0.6,
            'ytick.major.width'  : 0.6,
            'grid.linewidth'     : 0.6,
            'grid.linestyle'     : ':'})
        # (2) Update default with argument rcParams, if it was given
        # (User-defined in the main program, if necessary
        # (Useful namely for multiplots
        plt.rcParams.update(my_rcParams)

class PeakProfiles:

    def gaussian(X,m,s):
        '''
        Gaussian function (~ profile for PXRD calculation).
    
        Parameters
        ----------
        X : numpy array
            X-variable of Gaussian function.
        m : float
            Mean value = the center of Gaussian function.
        s : float
            Standard deviation = the width of Gaussian function.
    
        Returns
        -------
        NumPy array
            The array with Y-values of the function; Y = Gaussian(X).
        '''
        return( 1/(s*np.sqrt(2*np.pi)) * np.exp(-(X-m)**2/(2*s**2)) )
    
    def lorentzian(X,m,s):
        '''
        Lorentzian function (~ profile for PXRD calculation).
    
        Parameters
        ----------
        X : numpy array
            X-variable of Lorentzian function.
        m : float
            Mean value = the center of Lorentzian function.
        s : float
            Standard deviation = the width of Lorentzian function.
    
        Returns
        -------
        NumPy array
            The array with Y-values of the functin; Y = Lorenzian(X).
        '''
        return( 1/np.pi * s/((X-m)**2 + s**2) )
    
    def pseudo_voigt(X,m,s,n=0.5):
        '''
        Pseudo-Voigt function (~ profile for PXRD calculation).
    
        Parameters
        ----------
        X : numpy array
            X-variable of pseudo-Voigt function.
        m : float
            Mean value = the center of pseudo-Voigt function.
        s : float
            Standard deviation = the width of pseudo-Voigt function.
        n : float, optional, the default is 0.5
            Ratio between Gaussian and Lorentzian components.
            In the very first approximation, we can set n = 0.5.
            For more details, see *Notes* subsection below.
            
        Returns
        -------
        NumPy array
            The array with Y-values of the functin; Y = Lorenzian(X).
    
        Notes
        -----
        * Pseudo-Voigt function
          = linear combination of Gaussian and Lorentzian function.
        * In the 1st approximation:
            * 50/50 combination => n = 0.5
            * sg = sigma_Gaussian
              defined so that sg and s yielded the same FWHM
        * more details in:
            * https://en.wikipedia.org/wiki/Voigt_profile
            * https://lmfit.github.io/lmfit-py/builtin_models.html
        '''
        # (1) Calculate sg
        # (sg = sigma_Gaussian - see docstring above for more details
        sg = s/np.sqrt(2*np.log(2))
        # (2) Calculate Pseudo-Voigt function
        # (Pseudo-Voigt = n * Gausian + (1-n) * Lorenzian)
        pseudo_voigt = \
            n * PeakProfiles.gaussian(X,m,sg) \
            + (1-n) * PeakProfiles.lorentzian(X,m,s)
        # (3) Return calculated function    
        return(pseudo_voigt)

class PXRDcalculation:
    
    def __init__(self, crystal, experiment, plot_parameters,
                 peak_profile = PeakProfiles.pseudo_voigt):
        self.crystal = crystal
        self.experiment = experiment
        self.plot_parameters = plot_parameters
        self.diffractions = self.calculate_diffractions()
        self.diffractogram = self.calculate_diffraction_profile()

    def calculate_diffractions(self):
        # (1) Calculate intensities
        calculation = pmXRDCalculator(
            wavelength = self.experiment.wavelength,
            debye_waller_factors=(self.crystal.temp_factors))
        diffractions = calculation.get_pattern(
            self.crystal.structure,
            two_theta_range = self.experiment.two_theta_range)
        # (2) Transform intensities: PyMatGen structure => pd.DataFrame
        intensities_df = PXRDcalculation.diffractions_to_dframe(diffractions)
        # (3) Return calculated intensities
        # (pandas.DataFrame with cols: TwoTheta, dhkl, S, q, Intensity
        return(intensities_df)
        
    def calculate_diffraction_profile(self):
        df = self.diffractions
        return(df)
        
    def show_diffractions(self):
        table = PXRDcalculation.dframe_to_table(self.diffractions)
        print(table)
            
    def save_diffractions(self, output_file):
        try:
            with open(output_file, 'w') as fh:
                table = PXRDcalculation.dframe_to_table(self.diffractions)
                print(table, file=fh)
        except:
            print(f'Error saving diffractions to {output_file}!')
    
    def plot_diffractions(self, outfile=None):
        # (1) Make local copies of pre-defined parameters (just convenience)
        df      = self.diffractions
        title   = self.plot_parameters.title
        x_axis  = self.plot_parameters.x_axis
        my_xlim = self.plot_parameters.xlim
        # (2) Prepare the plot
        plt.vlines(df[x_axis],0,df.Ihkl, lw=2)
        # ...plot title: set it if it is defined
        if title != None: plt.title(title)
        # ...xlimits = xlim: set only if they are defined
        if my_xlim != None: plt.xlim(my_xlim)
        # ...label of x-axis = xlabel depends on x_axis argument
        if (x_axis == 'q') or (x_axis == 'S'):
            xlabel_str = f'${x_axis}$' + r' [1/$\mathrm{\AA}$]'
        elif x_axis == 'TwoTheta':
            xlabel_str = r'2$\theta$ [deg]'
        elif x_axis == 'dhkl':
            xlabel_str = r'$d(hkl)$' + r' [$\mathrm{\AA}$]'
        else:
            print('X-axis - unknown quantity and units...')
        # ...set labels and other plot details
        plt.xlabel(xlabel_str)
        plt.ylabel('Intensity')
        plt.grid()
        plt.tight_layout()
        # Save/show the plot...
        # In Spyder: plot is always shown
        # In CLI: plot is saved (if outfile is defined) or it is just shown
        if outfile != None: 
            plt.savefig(outfile) 
        else:
            plt.show()
    
    def plot_diffractions_with_indexes(self):
        '''
        Interactive plot of indexed diffractions.
        
        IMPORTANT: before running a script with this method...
        ------------------------------------------------------
        * This plot is for interactive inspection of indexed diffractions.
        * If the method is called from Spyder IDE, type in Console ...
            * BEFORE running (to make plot interactive): %matplotlib qt
            * AFTER running (back to non-interactive mode): %matplotlib inline
        
        Parameters
        ----------
        * None; this function is to be called exclusively 
          as method of PXRDcalculation object.
        * If PXRDcalculation is properly initialized,
          additional parameters are not needed.

        Returns
        -------
        * None; the output is the interactive plot in the screen.
        
        Technical notes
        ---------------
        * The code below uses (sligthly modified) PyMatGen functions.
        * Reason: PyMatGen plotting works well with diffraction indexes.
          Re-programing of indexed plots would be difficult and useless...
        '''
        # (0) Redefine plot parameters
        # (so that they were optimized for the interactive plot
        plt.rcParams.update({
            'figure.figsize'  : (12/2.54,4/2.54),
            'figure.dpi'      : 200,
            'font.size'       : 6})
        # (1) Calculate diffractions
        # (re-calculation in order to get the original PyMatGen xrd object
        # (the xrd object can be employed to plot diffractions with indexes
        xrd = pmXRDCalculator(
            wavelength = self.experiment.wavelength,
            debye_waller_factors=(self.crystal.temp_factors))
        # (2) Create plot with indexes
        # (trick: we create figure and axes (fig,ax)
        # (and instruct PyMatGen to plot in pre-defined axes
        fig,ax = plt.subplots()
        xrd.get_plot(
            structure = self.crystal.structure,
            two_theta_range=self.experiment.two_theta_range,
            annotate_peaks='compact', ax=ax, fontsize=6)
        # (3) Ex-post changing of lines in plt.plot
        # https://stackoverflow.com/q/41709257
        for line in ax.get_lines():
            line.set_color('orange')
        ax.set_xlabel('2theta [deg]')
        ax.set_ylabel('Intensity')
        ax.grid()
        # (4) Set higher number of ticks on X-axis
        # Trick #1: major ticks => higher MaxNLocator to get dense ticks
        # Trick #2: minor ticks => import special class for them
        ax.xaxis.set_major_locator(plt.MaxNLocator(15, steps=[1,2,5,10] ))
        from matplotlib.ticker import AutoMinorLocator
        ax.xaxis.set_minor_locator(AutoMinorLocator(5))
        # (5) Final adjustments
        fig.tight_layout()
        fig.show()
        
        
    def show_diffractogram(self):
        pass
            
    def save_diffractogram(self, output_file):
        pass
    
    def plot_diffractogram(self, output_file, x_axis='q'):
        pass
    
    @staticmethod    
    def diffractions_to_dframe(intensities):
        h = []; k = []; l = []
        for i in intensities.hkls:
            h.append(i[0]['hkl'][0])
            k.append(i[0]['hkl'][1])
            l.append(i[0]['hkl'][2])
        df = pd.DataFrame( 
            np.transpose(
                [intensities.x, h, k, l, intensities.d_hkls, intensities.y]),
            columns=['TwoTheta','h','k','l','dhkl','Ihkl'])
        df.insert(loc=5, column='S', value=1/df.dhkl)
        df.insert(loc=6, column='q', value=2*np.pi*df.S)
        return(df)
    
    @staticmethod
    def dframe_to_table(dframe):
        # POZOR: parametr formatters je zaludny!
        # * musi to byt sada funkci, takze...
        #   NEfunguji string-formaty '%.3f' - nejsou to funkce
        #   NEfunguji f-stringy - nelze prazdne - f'{8.3f}' ani f'{:8.3f}'
        # * muzou se pouzit funkce str.format nebo lambda funkce
        #   to uz je skoro jednodussi str.format
        #   trik #1: float M.N-format je bez carky '{:8.3f}'.format
        #   ....ale: float  .N-format je s carkou  '{:,.3f}'.format
        #   trik #2: NElze naformatovat obecny typ jako integer
        #   ..takze: pro obecne cislo misto NEfunkcniho {:3d} nutno {:3.0f}
        table = dframe.to_string(
            formatters={
                'TwoTheta' : '{:8.3f}'.format,
                'h'        : '{:3.0f}'.format,
                'k'        : '{:3.0f}'.format,
                'l'        : '{:3.0f}'.format,
                'dhkl'     : '{:7.3f}'.format,
                'S'        : '{:7.3f}'.format,
                'q'        : '{:7.3f}'.format,
                'Ihkl'     : '{:9.3f}'.format
            }
        )
        return(table)
