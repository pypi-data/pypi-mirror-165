# coding: utf-8

# (C) Copyright IBM Corp. 2022.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# IBM OpenAPI SDK Code Generator Version: 3.27.0-c07e12f4-20210209-225127
 
"""
Use IBM Cloud Schematics service to provision a stack of IBM Cloud resources described
using a templating language, such as - Terraform files, Helm charts, Ansible playbooks,
etc..
"""

from datetime import datetime
from enum import Enum
from typing import BinaryIO, Dict, List
import base64
import json

from ibm_cloud_sdk_core import BaseService, DetailedResponse
from ibm_cloud_sdk_core.authenticators.authenticator import Authenticator
from ibm_cloud_sdk_core.get_authenticator import get_authenticator_from_environment
from ibm_cloud_sdk_core.utils import convert_model, datetime_to_string, string_to_datetime

from .common import get_sdk_headers

##############################################################################
# Service
##############################################################################

class Schematics20ApiV2(BaseService):
    """The Schematics 2.0 API V2 service."""

    DEFAULT_SERVICE_URL = 'https://schematics-dev.containers.appdomain.cloud'
    DEFAULT_SERVICE_NAME = 'schematics_2_0_api'

    @classmethod
    def new_instance(cls,
                     service_name: str = DEFAULT_SERVICE_NAME,
                    ) -> 'Schematics20ApiV2':
        """
        Return a new client for the Schematics 2.0 API service using the specified
               parameters and external configuration.
        """
        authenticator = get_authenticator_from_environment(service_name)
        service = cls(
            authenticator
            )
        service.configure_service(service_name)
        return service

    def __init__(self,
                 authenticator: Authenticator = None,
                ) -> None:
        """
        Construct a new client for the Schematics 2.0 API service.

        :param Authenticator authenticator: The authenticator specifies the authentication mechanism.
               Get up to date information from https://github.com/IBM/python-sdk-core/blob/master/README.md
               about initializing the authenticator of your choice.
        """
        BaseService.__init__(self,
                             service_url=self.DEFAULT_SERVICE_URL,
                             authenticator=authenticator)


    #########################
    # utils
    #########################


    def get_schematics_info(self,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the information about schematics.

        Get detailed information about the IBM Cloud Schematics API version, supported
        template types and versions, and the supported locations.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SchematicsInfo` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_schematics_info')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/info'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def list_schematics_access_rules(self,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all access_rules for all schematics resources.

        Get all the authorization rules for the User for Workspaces,  Datasets, Controls &
        Settings API.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SchematicsAccessRuleList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_schematics_access_rules')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/access'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def get_schematics_access_rules_for_resource(self,
        resource_name: str,
        *,
        command_name: str = None,
        command_parameter: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the access_rules for the schematics resource.

        Get the authorization rules for the User for Workspaces,  Shared datasets,
        Controls & Settings API.

        :param str resource_name: Name of the schematics resource.
        :param str command_name: (optional) Job command name.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name, capsule-name or flow-name).
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SchematicsAccessRuleList` object
        """

        if resource_name is None:
            raise ValueError('resource_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_schematics_access_rules_for_resource')
        headers.update(sdk_headers)

        params = {
            'command_name': command_name,
            'command_parameter': command_parameter
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['resource_name']
        path_param_values = self.encode_path_vars(resource_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/access/{resource_name}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_schematics_command_names(self,
        resource_name: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all the allowed commands for schematics resource.

        Get all the allowed commands for schematics resource.

        :param str resource_name: Name of the schematics resource.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CommandList` object
        """

        if resource_name is None:
            raise ValueError('resource_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_schematics_command_names')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['resource_name']
        path_param_values = self.encode_path_vars(resource_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/commands/{resource_name}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response

    #########################
    # workspaces
    #########################


    def list_workspaces(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all Workspace definitions.

        Get all Workspace definitions.

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WorkspaceList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_workspaces')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/workspaces'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_workspace(self,
        workspace: 'Workspace',
        **kwargs
    ) -> DetailedResponse:
        """
        Create a Workspace definition.

        Create a new workspace definition.

        :param Workspace workspace: Create a Workspace in your Account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Workspace` object
        """

        if workspace is None:
            raise ValueError('workspace must be provided')
        if isinstance(workspace, Workspace):
            workspace = convert_model(workspace)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_workspace')
        headers.update(sdk_headers)

        data = json.dumps(workspace)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/workspaces'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_workspace(self,
        w_id: str,
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Workspace definition.

        Get the Workspace definition.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Workspace` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_workspace')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def replace_workspace(self,
        w_id: str,
        workspace: 'Workspace',
        **kwargs
    ) -> DetailedResponse:
        """
        Replace the Workspace definition.

        Replace the Workspace definition.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param Workspace workspace: Replace the entire Workspace definition.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Workspace` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if workspace is None:
            raise ValueError('workspace must be provided')
        if isinstance(workspace, Workspace):
            workspace = convert_model(workspace)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='replace_workspace')
        headers.update(sdk_headers)

        data = json.dumps(workspace)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def delete_workspace(self,
        w_id: str,
        *,
        force: bool = None,
        propagate: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete the Workspace.

        Delete the workspace; if the workspace's auto_destroy_on_delete is set to true,
        try to destroy all the resources in the workspace before deleting the workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        headers = {
            'force': force,
            'propagate': propagate
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_workspace')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def update_workspace(self,
        w_id: str,
        workspace: 'Workspace',
        **kwargs
    ) -> DetailedResponse:
        """
        Update the Workspace definition.

        Update the Workspace definition.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param Workspace workspace: Update some details in the Workspace.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Workspace` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if workspace is None:
            raise ValueError('workspace must be provided')
        if isinstance(workspace, Workspace):
            workspace = convert_model(workspace)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_workspace')
        headers.update(sdk_headers)

        data = json.dumps(workspace)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def list_workspace_inputs(self,
        w_id: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Workspace input parameter definitions.

        Get the input parameter definition (variables, values, metadata) for the
        workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `InputVariableDataList` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_workspace_inputs')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/inputs'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def list_workspace_outputs(self,
        w_id: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Workspace output parameter definitions.

        Get the output parameter definition (variables, metadata) for the workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `OutputVariableDataList` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_workspace_outputs')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/outputs'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response

    #########################
    # workspace-template
    #########################


    def create_workspace_templates(self,
        template_list_request: 'TemplateListRequest',
        *,
        x_github_token: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Create a new Workspace with Template definitions.

        A new workspace is created for the templates.

        :param TemplateListRequest template_list_request: List of Templates.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Workspace` object
        """

        if template_list_request is None:
            raise ValueError('template_list_request must be provided')
        if isinstance(template_list_request, TemplateListRequest):
            template_list_request = convert_model(template_list_request)
        headers = {
            'X-Github-token': x_github_token
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_workspace_templates')
        headers.update(sdk_headers)

        data = json.dumps(template_list_request)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/templates'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def list_templates_in_workspace(self,
        w_id: str,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all Template definitions from the Workspace.

        Get list of all Templates in a Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateList` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_templates_in_workspace')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def add_templates_to_workspace(self,
        w_id: str,
        template: 'Template',
        *,
        x_github_token: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Add a new Template definition to the Workspace.

        Creates a new Template and adds it to Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param Template template: Add a new Template to the Workspace.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Template` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if template is None:
            raise ValueError('template must be provided')
        if isinstance(template, Template):
            template = convert_model(template)
        headers = {
            'X-Github-token': x_github_token
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='add_templates_to_workspace')
        headers.update(sdk_headers)

        data = json.dumps(template)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_template_in_workspace(self,
        w_id: str,
        t_id: str,
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Template definition from the Workspace.

        Get the Template definition from the workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Template` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_template_in_workspace')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def replace_template_in_workspace(self,
        w_id: str,
        t_id: str,
        *,
        template: 'Template' = None,
        x_github_token: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Replace the Template definition in the Workspace.

        Replace the Template definition in the Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param Template template: (optional) Replace the entire Template in the
               Workspace.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Template` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        if  template is not None and isinstance(template, Template):
            template = convert_model(template)
        headers = {
            'X-Github-token': x_github_token
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='replace_template_in_workspace')
        headers.update(sdk_headers)

        data = json.dumps(template)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def delete_template_from_workspace(self,
        w_id: str,
        t_id: str,
        *,
        force: bool = None,
        propagate: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Remove the Template from the Workspace.

        Delete the Template associated with the workspace; if the template's
        auto_destroy_on_delete is set to true, try to destroy all the resources
        associated with Template before deleting the Template.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        headers = {
            'force': force,
            'propagate': propagate
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_template_from_workspace')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def update_template_in_workspace(self,
        w_id: str,
        t_id: str,
        *,
        template: 'Template' = None,
        x_github_token: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Update the Template definition in the Workspace.

        Update the Template definition in the Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param Template template: (optional) Update the Template definition in the
               Workspace.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Template` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        if  template is not None and isinstance(template, Template):
            template = convert_model(template)
        headers = {
            'X-Github-token': x_github_token
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_template_in_workspace')
        headers.update(sdk_headers)

        data = json.dumps(template)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def upload_template_tar_in_workspace(self,
        w_id: str,
        t_id: str,
        *,
        file: BinaryIO = None,
        file_content_type: str = None,
        x_github_token: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Upload the Template content as tar-file.

        Upload the Template content as tar-file.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param BinaryIO file: (optional) Template tar file.
        :param str file_content_type: (optional) The content type of file.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Template` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        headers = {
            'X-Github-token': x_github_token
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='upload_template_tar_in_workspace')
        headers.update(sdk_headers)

        form_data = []
        if file:
            form_data.append(('file', (None, file, file_content_type or 'application/octet-stream')))

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}/content'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       files=form_data)

        response = self.send(request)
        return response


    def get_template_readme(self,
        w_id: str,
        t_id: str,
        *,
        accept: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Templates Readme file.

        Get the Readme file from the Template in the Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param str accept: (optional) The type of the response: text/markdown or
               text/html. A character encoding can be specified by including a `charset`
               parameter. For example, 'text/markdown;charset=utf-8'.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `str` result
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        headers = {
            'Accept': accept
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_template_readme')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}/readme'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def get_template_source(self,
        w_id: str,
        t_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Template source details.

        Get the source details (Git repo, IBM Catalog, or other catalog sources) of the
        Template in the Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ExternalSource` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_template_source')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}/source'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def list_template_inputs(self,
        w_id: str,
        t_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Template input parameter definitions.

        Get the template input parameter definitions (variables, values, metadata) of
        Template in the Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `VariableDataList` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_template_inputs')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}/inputs'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def list_template_outputs(self,
        w_id: str,
        t_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Template output parameter definitions.

        Get the output parameter definitions (variables, values, metadata) of Template in
        the Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `VariableDataList` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_template_outputs')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id']
        path_param_values = self.encode_path_vars(w_id, t_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}/outputs'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response

    #########################
    # workspace-flows
    #########################


    def list_flows_in_workspace(self,
        w_id: str,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all Flow definitions from the Workspace.

        Get list of all Flow definitions in a Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateFlowList` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_flows_in_workspace')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/flows'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def add_flow_to_workspace(self,
        w_id: str,
        template_flow: 'TemplateFlow',
        **kwargs
    ) -> DetailedResponse:
        """
        Add a new Flow definition to the Workspace.

        Creates a new Flow and adds it to the Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param TemplateFlow template_flow: Add a new Flow to the Workspace.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateFlow` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if template_flow is None:
            raise ValueError('template_flow must be provided')
        if isinstance(template_flow, TemplateFlow):
            template_flow = convert_model(template_flow)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='add_flow_to_workspace')
        headers.update(sdk_headers)

        data = json.dumps(template_flow)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id']
        path_param_values = self.encode_path_vars(w_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/flows'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_flow_in_workspace(self,
        w_id: str,
        flow_id: str,
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get Flow definition from the Workspace.

        Get specified flow details in a workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str flow_id: Flow Id.  Use `GET /v2/workspaces/<workspace_id>/flows`
               API to look up the  Flow Ids in your Workspaces.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateFlow` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if flow_id is None:
            raise ValueError('flow_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_flow_in_workspace')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 'flow_id']
        path_param_values = self.encode_path_vars(w_id, flow_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/flows/{flow_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def replace_flow_in_workspace(self,
        w_id: str,
        flow_id: str,
        *,
        template_flow: 'TemplateFlow' = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Replace the Flow definition in the Workspace.

        Replace the Flow definition in the Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str flow_id: Flow Id.  Use `GET /v2/workspaces/<workspace_id>/flows`
               API to look up the  Flow Ids in your Workspaces.
        :param TemplateFlow template_flow: (optional) Replace the entire Flow in
               the Workspace.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateFlow` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if flow_id is None:
            raise ValueError('flow_id must be provided')
        if  template_flow is not None and isinstance(template_flow, TemplateFlow):
            template_flow = convert_model(template_flow)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='replace_flow_in_workspace')
        headers.update(sdk_headers)

        data = json.dumps(template_flow)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 'flow_id']
        path_param_values = self.encode_path_vars(w_id, flow_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/flows/{flow_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def delete_flow_from_workspace(self,
        w_id: str,
        flow_id: str,
        *,
        propagate: bool = None,
        force: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Remove the Flow from the Workspace.

        Delete the flow associated with workspace;.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str flow_id: Flow Id.  Use `GET /v2/workspaces/<workspace_id>/flows`
               API to look up the  Flow Ids in your Workspaces.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if flow_id is None:
            raise ValueError('flow_id must be provided')
        headers = {
            'propagate': propagate,
            'force': force
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_flow_from_workspace')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['w_id', 'flow_id']
        path_param_values = self.encode_path_vars(w_id, flow_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/flows/{flow_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def update_flow_in_workspace(self,
        w_id: str,
        flow_id: str,
        *,
        template_flow: 'TemplateFlow' = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Update the Flow definition in the Workspace.

        Update the Flow definition in the Workspace.

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str flow_id: Flow Id.  Use `GET /v2/workspaces/<workspace_id>/flows`
               API to look up the  Flow Ids in your Workspaces.
        :param TemplateFlow template_flow: (optional) Update the Flow definition in
               the workspace.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateFlow` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if flow_id is None:
            raise ValueError('flow_id must be provided')
        if  template_flow is not None and isinstance(template_flow, TemplateFlow):
            template_flow = convert_model(template_flow)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_flow_in_workspace')
        headers.update(sdk_headers)

        data = json.dumps(template_flow)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 'flow_id']
        path_param_values = self.encode_path_vars(w_id, flow_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/flows/{flow_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response

    #########################
    # actions
    #########################


    def list_actions(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        List actions.

        Retrieve a list of all Schematics actions that depends on the API endpoint that
        you have access. For example, if you use an API endpoint for a geography, such as
        North America, only actions that are created in `us-south` or `us-east` are
        retrieved.
         For more information, about supported API endpoints, see
        [API endpoints](/apidocs/schematics#api-endpoints).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ActionList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_actions')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/actions'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_action(self,
        action: 'Action',
        *,
        x_github_token: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Create an action.

        Create an IBM Cloud Schematics action to run on a single target or groups of
        target hosts, roles, policies, or steps to deploy your resources in the target
        hosts. You can run the IBM Cloud resources the order in which you want to execute
        them. **Note** If your Git repository already contains a host file. Schematics
        does not overwrite the host file already present in your Git repository. For
        sample templates, see IBM Cloud Automation
        [templates](https://github.com/Cloud-Schematics).
         The Schematics action API now supports bastion host connection with `non-root`
        user, and bastion connection type is marked as optional, when inventory connection
        type is set as [Windows Remote
        Management](https://www.ibm.com/docs/en/license-metric-tool?topic=v-configuring-winrm-hyper-hosts)(`winrm`).
         For more information, about the Schematics create action,
         see [ibmcloud schematics action
        create](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-create-action).
         **Note** you cannot update the location and region once an action is created.
         Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](/docs/schematics?topic=schematics-access#action-permissions).

        :param Action action: Create Action request.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Action` object
        """

        if action is None:
            raise ValueError('action must be provided')
        if isinstance(action, Action):
            action = convert_model(action)
        headers = {
            'X-Github-token': x_github_token
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_action')
        headers.update(sdk_headers)

        data = json.dumps(action)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/actions'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_action(self,
        action_id: str,
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get action details.

        Retrieve the detailed information of an actions from your IBM Cloud account.  This
        API returns a URL to the log file that you can retrieve by using  the `GET
        /v2/actions/{action_id}/logs` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#action-permissions).

        :param str action_id: Action Id.  Use GET /actions API to look up the
               Action Ids in your IBM Cloud account.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Action` object
        """

        if action_id is None:
            raise ValueError('action_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_action')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['action_id']
        path_param_values = self.encode_path_vars(action_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/actions/{action_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def delete_action(self,
        action_id: str,
        *,
        force: bool = None,
        propagate: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete an action.

        Delete a Schematics action and specify the Ansible playbook that you want to run
        against your IBM Cloud resources. **Note** you cannot delete or stop the job
        activity from an ongoing execution of an action defined in the playbook. You can
        repeat the execution of same job, whenever you patch the actions. For more
        information, about the Schematics action state, see  [Schematics action state
        diagram](https://cloud.ibm.com/docs/schematics?topic=schematics-action-setup#action-state-diagram).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str action_id: Action Id.  Use GET /actions API to look up the
               Action Ids in your IBM Cloud account.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if action_id is None:
            raise ValueError('action_id must be provided')
        headers = {
            'force': force,
            'propagate': propagate
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_action')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['action_id']
        path_param_values = self.encode_path_vars(action_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/actions/{action_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def update_action(self,
        action_id: str,
        action: 'Action',
        *,
        x_github_token: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Update an action.

        Update or replace an action to change the action state from the critical state to
        normal state, or pending state to the normal state for a successful execution. For
        more information, about the Schematics action state, see [Schematics action state
        diagram](https://cloud.ibm.com/docs/schematics?topic=schematics-action-setup#action-state-diagram).
         The Schematics action API now supports bastion host connection with `non-root`
        user, and bastion connection type is marked as optional, when inventory connection
        type is set as [Windows Remote
        Management](https://www.ibm.com/docs/en/license-metric-tool?topic=v-configuring-winrm-hyper-hosts)(`winrm`).
         **Note** you cannot update the location and region once an action is created.
        Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses].
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str action_id: Action Id.  Use GET /actions API to look up the
               Action Ids in your IBM Cloud account.
        :param Action action: Action.
        :param str x_github_token: (optional) The personal access token to
               authenticate with your private GitHub or GitLab repository and access your
               Terraform template.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Action` object
        """

        if action_id is None:
            raise ValueError('action_id must be provided')
        if action is None:
            raise ValueError('action must be provided')
        if isinstance(action, Action):
            action = convert_model(action)
        headers = {
            'X-Github-token': x_github_token
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_action')
        headers.update(sdk_headers)

        data = json.dumps(action)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['action_id']
        path_param_values = self.encode_path_vars(action_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/actions/{action_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def upload_template_tar_action(self,
        action_id: str,
        *,
        file: BinaryIO = None,
        file_content_type: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Upload a TAR file to an action.

        Update your template by uploading tape archive file (.tar) file from  your local
        machine. Before you use this API, you must create an action  without a link to a
        GitHub or GitLab repository with the `POST /v2/actions` API.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,
         see [Schematics service access roles and required
        permissions](/docs/schematics?topic=schematics-access#action-permissions).

        :param str action_id: Action Id.  Use GET /actions API to look up the
               Action Ids in your IBM Cloud account.
        :param BinaryIO file: (optional) Template tar file.
        :param str file_content_type: (optional) The content type of file.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateRepoTarUploadResponse` object
        """

        if action_id is None:
            raise ValueError('action_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='upload_template_tar_action')
        headers.update(sdk_headers)

        form_data = []
        if file:
            form_data.append(('file', (None, file, file_content_type or 'application/octet-stream')))

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['action_id']
        path_param_values = self.encode_path_vars(action_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/actions/{action_id}/template_repo_upload'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       files=form_data)

        response = self.send(request)
        return response

    #########################
    # jobs
    #########################


    def list_jobs(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        profile: str = None,
        resource: str = None,
        resource_id: str = None,
        action_id: str = None,
        list: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        List jobs.

        Retrieve a list of all Schematics jobs.  The job displays a list of jobs with the
        status as `pending`, `in_progess`,  `success`, or `failed`. Jobs are generated
        when you use the  `POST /v2/jobs`, `PUT /v2/jobs/{job_id}`, or `DELETE
        /v2/jobs/{job_id}`.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param str resource: (optional) Name of the resource (workspace, actions or
               controls).
        :param str resource_id: (optional) The Resource Id. It could be an
               Action-id or Workspace-id.
        :param str action_id: (optional) Action Id.
        :param str list: (optional) list jobs.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `JobList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_jobs')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile,
            'resource': resource,
            'resource_id': resource_id,
            'action_id': action_id,
            'list': list
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/jobs'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_job(self,
        refresh_token: str,
        job: 'Job',
        **kwargs
    ) -> DetailedResponse:
        """
        Create a job.

        Create & launch the Schematics job. It can be used to launch an Ansible playbook
        against a target hosts.  The job displays a list of jobs with the status as
        `pending`, `in_progess`, `success`, or `failed`.

        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param Job job: Create a Job Record and launch the Job.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Job` object
        """

        if refresh_token is None:
            raise ValueError('refresh_token must be provided')
        if job is None:
            raise ValueError('job must be provided')
        if isinstance(job, Job):
            job = convert_model(job)
        headers = {
            'refresh_token': refresh_token
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_job')
        headers.update(sdk_headers)

        data = json.dumps(job)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/jobs'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_job(self,
        job_id: str,
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get a job.

        Retrieve the detailed information of Job
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Job` object
        """

        if job_id is None:
            raise ValueError('job_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_job')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['job_id']
        path_param_values = self.encode_path_vars(job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def update_job(self,
        job_id: str,
        refresh_token: str,
        job: 'Job',
        **kwargs
    ) -> DetailedResponse:
        """
        Update a job.

        Creates a copy of the Schematics job and relaunches an existing job  by updating
        the information of an existing Schematics job.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param Job job: Clone the Job-record, and relaunch the Job.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Job` object
        """

        if job_id is None:
            raise ValueError('job_id must be provided')
        if refresh_token is None:
            raise ValueError('refresh_token must be provided')
        if job is None:
            raise ValueError('job must be provided')
        if isinstance(job, Job):
            job = convert_model(job)
        headers = {
            'refresh_token': refresh_token
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_job')
        headers.update(sdk_headers)

        data = json.dumps(job)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['job_id']
        path_param_values = self.encode_path_vars(job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def delete_job(self,
        job_id: str,
        refresh_token: str,
        *,
        force: bool = None,
        propagate: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Stop the running Job, and delete the Job.

        Stop the running Job, and delete the Job.  **Note** You cannot delete or stop the
        job activity from an ongoing  execution of an action defined in the playbook.  You
        can repeat the execution of same job, whenever you patch or update the action or
        workspace.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param str refresh_token: The IAM refresh token for the user or service
               identity.
                 **Retrieving refresh token**:
                 * Use `export IBMCLOUD_API_KEY=<ibmcloud_api_key>`, and execute `curl -X
               POST "https://iam.cloud.ibm.com/identity/token" -H "Content-Type:
               application/x-www-form-urlencoded" -d
               "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=$IBMCLOUD_API_KEY"
               -u bx:bx`.
                 * For more information, about creating IAM access token and API Docs,
               refer, [IAM access
               token](/apidocs/iam-identity-token-api#gettoken-password) and [Create API
               key](/apidocs/iam-identity-token-api#create-api-key).
                 **Limitation**:
                 * If the token is expired, you can use `refresh token` to get a new IAM
               access token.
                 * The `refresh_token` parameter cannot be used to retrieve a new IAM
               access token.
                 * When the IAM access token is about to expire, use the API key to create
               a new access token.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if job_id is None:
            raise ValueError('job_id must be provided')
        if refresh_token is None:
            raise ValueError('refresh_token must be provided')
        headers = {
            'refresh_token': refresh_token,
            'force': force,
            'propagate': propagate
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_job')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['job_id']
        path_param_values = self.encode_path_vars(job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def list_job_logs(self,
        job_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get job logs.

        Retrieve the job logs <h3>Authorization</h3> Schematics support generic
        authorization for its resources. For more information, about Schematics access and
        permissions, see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `JobLog` object
        """

        if job_id is None:
            raise ValueError('job_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_job_logs')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['job_id']
        path_param_values = self.encode_path_vars(job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}/logs'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def get_job_files(self,
        job_id: str,
        file_type: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get output files from the Job record.

        Get output files from the Job record. For more information, about the Schematics
        job status, download job logs, and download the output files, see [Download
        Schematics
        Job](https://cloud.ibm.com/docs/schematics?topic=schematics-job-download).

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param str file_type: The type of file you want to download eg.state_file,
               plan_json.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `JobFileData` object
        """

        if job_id is None:
            raise ValueError('job_id must be provided')
        if file_type is None:
            raise ValueError('file_type must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_job_files')
        headers.update(sdk_headers)

        params = {
            'file_type': file_type
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['job_id']
        path_param_values = self.encode_path_vars(job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}/files'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response

    #########################
    # controls
    #########################


    def list_controls(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all Controls definition.

        Get all Controls definition.

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ControlsList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_controls')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/controls'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_controls(self,
        controls: 'Controls',
        **kwargs
    ) -> DetailedResponse:
        """
        Register a new Controls definition.

        Create a new Controls definition.

        :param Controls controls: Register a Control.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Controls` object
        """

        if controls is None:
            raise ValueError('controls must be provided')
        if isinstance(controls, Controls):
            controls = convert_model(controls)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_controls')
        headers.update(sdk_headers)

        data = json.dumps(controls)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/controls'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_controls(self,
        controls_id: str,
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Controls definition.

        Get the Controls definition.

        :param str controls_id: Controls Id.  Use `GET /v2/controls` API to look up
               the Controls Ids in your IBM Cloud account.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Controls` object
        """

        if controls_id is None:
            raise ValueError('controls_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_controls')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['controls_id']
        path_param_values = self.encode_path_vars(controls_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/controls/{controls_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def delete_controls(self,
        controls_id: str,
        *,
        force: bool = None,
        propagate: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete the Controls definition.

        Delete the Controls definition.

        :param str controls_id: Controls Id.  Use `GET /v2/controls` API to look up
               the Controls Ids in your IBM Cloud account.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if controls_id is None:
            raise ValueError('controls_id must be provided')
        headers = {
            'force': force,
            'propagate': propagate
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_controls')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['controls_id']
        path_param_values = self.encode_path_vars(controls_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/controls/{controls_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def update_controls(self,
        controls_id: str,
        controls: 'Controls',
        **kwargs
    ) -> DetailedResponse:
        """
        Update the Controls definition.

        Update the Controls definition.

        :param str controls_id: Controls Id.  Use `GET /v2/controls` API to look up
               the Controls Ids in your IBM Cloud account.
        :param Controls controls: Update the Controls definition.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Controls` object
        """

        if controls_id is None:
            raise ValueError('controls_id must be provided')
        if controls is None:
            raise ValueError('controls must be provided')
        if isinstance(controls, Controls):
            controls = convert_model(controls)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_controls')
        headers.update(sdk_headers)

        data = json.dumps(controls)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['controls_id']
        path_param_values = self.encode_path_vars(controls_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/controls/{controls_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def list_capsules(self,
        controls_id: str,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all Policy Capsules in the Controls definition.

        Get all Policy Capsules in the Controls definition.

        :param str controls_id: Controls Id.  Use `GET /v2/controls` API to look up
               the Controls Ids in your IBM Cloud account.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CapsuleList` object
        """

        if controls_id is None:
            raise ValueError('controls_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_capsules')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['controls_id']
        path_param_values = self.encode_path_vars(controls_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/controls/{controls_id}/capsules'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_capsule(self,
        controls_id: str,
        capsule: 'Capsule',
        **kwargs
    ) -> DetailedResponse:
        """
        Register a Policy Capsule to the Controls definition.

        Create a Policy Capsule in the Controls definition.

        :param str controls_id: Controls Id.  Use `GET /v2/controls` API to look up
               the Controls Ids in your IBM Cloud account.
        :param Capsule capsule: Create a Policy Capsule in the Controls definition.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CapsuleList` object
        """

        if controls_id is None:
            raise ValueError('controls_id must be provided')
        if capsule is None:
            raise ValueError('capsule must be provided')
        if isinstance(capsule, Capsule):
            capsule = convert_model(capsule)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_capsule')
        headers.update(sdk_headers)

        data = json.dumps(capsule)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['controls_id']
        path_param_values = self.encode_path_vars(controls_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/controls/{controls_id}/capsules'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_capsule(self,
        controls_id: str,
        capsule_id: str,
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get Policy Capsule from the Controls definition.

        Get Policy Capsule from the Controls definition.

        :param str controls_id: Controls Id.  Use `GET /v2/controls` API to look up
               the Controls Ids in your IBM Cloud account.
        :param str capsule_id: Capsule Id.  Use `GET
               /v2/controls/<contorls_id>/capsules` API to look up the Capsules Ids  for
               the Controls in your IBM Cloud account.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Capsule` object
        """

        if controls_id is None:
            raise ValueError('controls_id must be provided')
        if capsule_id is None:
            raise ValueError('capsule_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_capsule')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['controls_id', 'capsule_id']
        path_param_values = self.encode_path_vars(controls_id, capsule_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/controls/{controls_id}/capsules/{capsule_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def delete_capsule(self,
        controls_id: str,
        capsule_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Unregister the Policy Capsule from the Controls.

        Delete the Policy Capsule from the Controls.

        :param str controls_id: Controls Id.  Use `GET /v2/controls` API to look up
               the Controls Ids in your IBM Cloud account.
        :param str capsule_id: Capsule Id.  Use `GET
               /v2/controls/<contorls_id>/capsules` API to look up the Capsules Ids  for
               the Controls in your IBM Cloud account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if controls_id is None:
            raise ValueError('controls_id must be provided')
        if capsule_id is None:
            raise ValueError('capsule_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_capsule')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['controls_id', 'capsule_id']
        path_param_values = self.encode_path_vars(controls_id, capsule_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/controls/{controls_id}/capsules/{capsule_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def update_capsule(self,
        controls_id: str,
        capsule_id: str,
        capsule: 'Capsule',
        **kwargs
    ) -> DetailedResponse:
        """
        Update the Policy Capsule in the Controls definition.

        Update the Policy Capsule in the Controls definition.

        :param str controls_id: Controls Id.  Use `GET /v2/controls` API to look up
               the Controls Ids in your IBM Cloud account.
        :param str capsule_id: Capsule Id.  Use `GET
               /v2/controls/<contorls_id>/capsules` API to look up the Capsules Ids  for
               the Controls in your IBM Cloud account.
        :param Capsule capsule: Update the Policy Capusle.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Capsule` object
        """

        if controls_id is None:
            raise ValueError('controls_id must be provided')
        if capsule_id is None:
            raise ValueError('capsule_id must be provided')
        if capsule is None:
            raise ValueError('capsule must be provided')
        if isinstance(capsule, Capsule):
            capsule = convert_model(capsule)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_capsule')
        headers.update(sdk_headers)

        data = json.dumps(capsule)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['controls_id', 'capsule_id']
        path_param_values = self.encode_path_vars(controls_id, capsule_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/controls/{controls_id}/capsules/{capsule_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response

    #########################
    # settings-datasets
    #########################


    def list_datasets(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all shared datasets.

        Get all shared datasets.

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `DatasetList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_datasets')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/datasets'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_dataset(self,
        dataset: 'Dataset',
        **kwargs
    ) -> DetailedResponse:
        """
        Create a shared dataset.

        Create a shared dataset.

        :param Dataset dataset: Create a shared dataset.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Dataset` object
        """

        if dataset is None:
            raise ValueError('dataset must be provided')
        if isinstance(dataset, Dataset):
            dataset = convert_model(dataset)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_dataset')
        headers.update(sdk_headers)

        data = json.dumps(dataset)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/datasets'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_dataset(self,
        dataset_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the shared dataset.

        Get the Shared dataset.

        :param str dataset_id: Shared dataset Id.  Use `GET /v2/datasets` API to
               look up the Shared dataset Ids  in your IBM Cloud account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Dataset` object
        """

        if dataset_id is None:
            raise ValueError('dataset_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_dataset')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['dataset_id']
        path_param_values = self.encode_path_vars(dataset_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/datasets/{dataset_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def replace_dataset(self,
        dataset_id: str,
        dataset: 'Dataset',
        **kwargs
    ) -> DetailedResponse:
        """
        Replace the shared dataset.

        Replace the shared dataset.

        :param str dataset_id: Shared dataset Id.  Use `GET /v2/datasets` API to
               look up the Shared dataset Ids  in your IBM Cloud account.
        :param Dataset dataset: Replace the shared datasets.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Dataset` object
        """

        if dataset_id is None:
            raise ValueError('dataset_id must be provided')
        if dataset is None:
            raise ValueError('dataset must be provided')
        if isinstance(dataset, Dataset):
            dataset = convert_model(dataset)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='replace_dataset')
        headers.update(sdk_headers)

        data = json.dumps(dataset)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['dataset_id']
        path_param_values = self.encode_path_vars(dataset_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/datasets/{dataset_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def delete_dataset(self,
        dataset_id: str,
        *,
        force: bool = None,
        propagate: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete the Shared dataset.

        Delete the shared dataset.

        :param str dataset_id: Shared dataset Id.  Use `GET /v2/datasets` API to
               look up the Shared dataset Ids  in your IBM Cloud account.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if dataset_id is None:
            raise ValueError('dataset_id must be provided')
        headers = {
            'force': force,
            'propagate': propagate
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_dataset')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['dataset_id']
        path_param_values = self.encode_path_vars(dataset_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/datasets/{dataset_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def update_ataset(self,
        dataset_id: str,
        dataset: 'Dataset',
        **kwargs
    ) -> DetailedResponse:
        """
        Update the shared dataset.

        Update the shared dataset details.

        :param str dataset_id: Shared dataset Id.  Use `GET /v2/datasets` API to
               look up the Shared dataset Ids  in your IBM Cloud account.
        :param Dataset dataset: Update the shared dataset details.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Dataset` object
        """

        if dataset_id is None:
            raise ValueError('dataset_id must be provided')
        if dataset is None:
            raise ValueError('dataset must be provided')
        if isinstance(dataset, Dataset):
            dataset = convert_model(dataset)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_ataset')
        headers.update(sdk_headers)

        data = json.dumps(dataset)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['dataset_id']
        path_param_values = self.encode_path_vars(dataset_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/datasets/{dataset_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def list_dataset_variables(self,
        dataset_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all the Shared dataset variable definitions.

        Get all the shared dataset variable definitions (variables, values, metadata).

        :param str dataset_id: Shared dataset Id.  Use `GET /v2/datasets` API to
               look up the Shared dataset Ids  in your IBM Cloud account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `VariableDataList` object
        """

        if dataset_id is None:
            raise ValueError('dataset_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_dataset_variables')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['dataset_id']
        path_param_values = self.encode_path_vars(dataset_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/datasets/{dataset_id}/variables'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def get_dataset_variable(self,
        dataset_id: str,
        var_name: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Shared dataset.

        Get the shared dataset.

        :param str dataset_id: Shared dataset Id.  Use `GET /v2/datasets` API to
               look up the Shared dataset Ids  in your IBM Cloud account.
        :param str var_name: Name of the variable.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `VariableData` object
        """

        if dataset_id is None:
            raise ValueError('dataset_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_dataset_variable')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['dataset_id', 'var_name']
        path_param_values = self.encode_path_vars(dataset_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/datasets/{dataset_id}/values/{var_name}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response

    #########################
    # inventory
    #########################


    def list_inventories(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        List inventory definitions.

        Retrieve a list of all Schematics inventories that depends on the API endpoint
        that you have access. For example, if you use an API endpoint for a geography,
        such as North America, only inventories that are created in `us-south` or
        `us-east` are retrieved. For more information, about supported API endpoints, see
        [APIendpoints](/apidocs/schematics#api-endpoints).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `InventoryResourceRecordList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_inventories')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/inventories'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_inventory(self,
        inventory_resource_definition: 'InventoryResourceDefinition',
        **kwargs
    ) -> DetailedResponse:
        """
        Create an inventory definition.

        Create an IBM Cloud Schematics inventory as a single IBM Cloud resource where you
        want to run Ansible playbook by using Schematics actions. For more information,
        about inventory host groups, refer to [creating static and dynamic inventory for
        Schematics
        actions](https://cloud.ibm.com/docs/schematics?topic=schematics-inventories-setup).
         **Note** you cannot update the location and region, resource group once an action
        is created. Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
         If your Git repository already contains a host file. Schematics does not
        overwrite the host file already present in your Git repository.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param InventoryResourceDefinition inventory_resource_definition: Create a
               Inventory definition resource.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `InventoryResourceRecord` object
        """

        if inventory_resource_definition is None:
            raise ValueError('inventory_resource_definition must be provided')
        if isinstance(inventory_resource_definition, InventoryResourceDefinition):
            inventory_resource_definition = convert_model(inventory_resource_definition)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_inventory')
        headers.update(sdk_headers)

        data = json.dumps(inventory_resource_definition)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/inventories'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_inventory(self,
        inventory_id: str,
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get an inventory definition.

        Use this API to retrieve the detailed information for a resource inventory
        definition used to target an action in your IBM Cloud account. For more
        information, about inventory get, refer to [ibmcloud schematics inventory
        get](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-get-inv).
         **Note** you can fetch only the location and region, resource group from where
        your inventory is created.
         Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str inventory_id: Resource Inventory Id.  Use `GET /v2/inventories`
               API to look up the Resource Inventory definition Ids  in your IBM Cloud
               account.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `InventoryResourceRecord` object
        """

        if inventory_id is None:
            raise ValueError('inventory_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_inventory')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['inventory_id']
        path_param_values = self.encode_path_vars(inventory_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/inventories/{inventory_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def replace_inventory(self,
        inventory_id: str,
        inventory_resource_definition: 'InventoryResourceDefinition',
        **kwargs
    ) -> DetailedResponse:
        """
        Update an inventory definition.

        Use this API to update the inventory definition resource used to target an action.
        For more information, about inventory update, refer to [ibmcloud schematics
        inventory
        update](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-update-inv).
         **Note** you cannot update the location and region, resource group once an action
        is created.
         Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str inventory_id: Resource Inventory Id.  Use `GET /v2/inventories`
               API to look up the Resource Inventory definition Ids  in your IBM Cloud
               account.
        :param InventoryResourceDefinition inventory_resource_definition: Update
               the inventory definition resource.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `InventoryResourceRecord` object
        """

        if inventory_id is None:
            raise ValueError('inventory_id must be provided')
        if inventory_resource_definition is None:
            raise ValueError('inventory_resource_definition must be provided')
        if isinstance(inventory_resource_definition, InventoryResourceDefinition):
            inventory_resource_definition = convert_model(inventory_resource_definition)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='replace_inventory')
        headers.update(sdk_headers)

        data = json.dumps(inventory_resource_definition)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['inventory_id']
        path_param_values = self.encode_path_vars(inventory_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/inventories/{inventory_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def delete_inventory(self,
        inventory_id: str,
        *,
        force: bool = None,
        propagate: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete an inventory definition.

        Use this API to delete the resource inventory definition by using the inventory ID
        that you want to run against. For more information, about inventory delete, refer
        to [ibmcloud schematics inventory
        delete](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-delete-inventory).
         **Note** you cannot delete the location and region, resource group from where
        your inventory is created. Also, make sure your IP addresses are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str inventory_id: Resource Inventory Id.  Use `GET /v2/inventories`
               API to look up the Resource Inventory definition Ids  in your IBM Cloud
               account.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if inventory_id is None:
            raise ValueError('inventory_id must be provided')
        headers = {
            'force': force,
            'propagate': propagate
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_inventory')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['inventory_id']
        path_param_values = self.encode_path_vars(inventory_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/inventories/{inventory_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def list_resource_query(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        List resource queries.

        Retrieve the list of resource query definitions that you have access to.  The list
        of resource queries that is returned depends on the API  endpoint that you use.
        For example, if you use an API endpoint for a geography, such as North America,
        only resource query definitions that are created in `us-south` or `us-east` are
        retrieved. For more information, about supported API endpoints, see [API
        endpoints](/apidocs/schematics#api-endpoints).
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ResourceQueryRecordList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_resource_query')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/resources_query'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_resource_query(self,
        resource_query_definition: 'ResourceQueryDefinition',
        **kwargs
    ) -> DetailedResponse:
        """
        Create resource query.

        Use this API to create a resource query definition that will be used to select an
        IBM Cloud resource or a group of resources as the dynamic inventory for the
        Schematics Actions. For more information, about resource query commands, refer to
        [ibmcloud schematics resource query
        create](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-create-rq).
        **Note** you cannot update the location and region, resource group  once an action
        is created. Also, make sure your IP addresses are  in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
        If your Git repository already contains a host file.  Schematics does not
        overwrite the host file already present in your Git repository.
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param ResourceQueryDefinition resource_query_definition: Create a resource
               query definition.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ResourceQueryRecord` object
        """

        if resource_query_definition is None:
            raise ValueError('resource_query_definition must be provided')
        if isinstance(resource_query_definition, ResourceQueryDefinition):
            resource_query_definition = convert_model(resource_query_definition)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_resource_query')
        headers.update(sdk_headers)

        data = json.dumps(resource_query_definition)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/resources_query'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_resources_query(self,
        query_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get resources query.

        Use this API to retrieve the information resource query by Id.  For more
        information, about resource query commands, refer to  [ibmcloud schematics
        resource query
        get](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-get-rq).
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str query_id: Resource query Id.  Use `GET /v2/resource_query` API
               to look up the Resource query definition Ids  in your IBM Cloud account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ResourceQueryRecord` object
        """

        if query_id is None:
            raise ValueError('query_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_resources_query')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['query_id']
        path_param_values = self.encode_path_vars(query_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/resources_query/{query_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def replace_resources_query(self,
        query_id: str,
        resource_query_definition: 'ResourceQueryDefinition',
        **kwargs
    ) -> DetailedResponse:
        """
        Update resources query definition.

        Use this API to update the resource query definition used to build  the dynamic
        inventory for the Schematics Action.  For more information, about resource query
        commands, refer to [ibmcloud schematics resource query
        update](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-update-rq).
        **Note** you cannot update the location and region, resource group  once a
        resource query is created. Also, make sure your IP addresses  are in the
        [allowlist](https://cloud.ibm.com/docs/schematics?topic=schematics-allowed-ipaddresses).
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str query_id: Resource query Id.  Use `GET /v2/resource_query` API
               to look up the Resource query definition Ids  in your IBM Cloud account.
        :param ResourceQueryDefinition resource_query_definition: Replace the
               resources query definition.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ResourceQueryRecord` object
        """

        if query_id is None:
            raise ValueError('query_id must be provided')
        if resource_query_definition is None:
            raise ValueError('resource_query_definition must be provided')
        if isinstance(resource_query_definition, ResourceQueryDefinition):
            resource_query_definition = convert_model(resource_query_definition)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='replace_resources_query')
        headers.update(sdk_headers)

        data = json.dumps(resource_query_definition)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['query_id']
        path_param_values = self.encode_path_vars(query_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/resources_query/{query_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def execute_resource_query(self,
        query_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Run the resource query.

        Run the resource query.

        :param str query_id: Resource query Id.  Use `GET /v2/resource_query` API
               to look up the Resource query definition Ids  in your IBM Cloud account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ResourceQueryResponseRecord` object
        """

        if query_id is None:
            raise ValueError('query_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='execute_resource_query')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['query_id']
        path_param_values = self.encode_path_vars(query_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/resources_query/{query_id}'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def delete_resources_query(self,
        query_id: str,
        *,
        force: bool = None,
        propagate: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete resources query.

        Use this API to delete the resource query definition by Id.  For more information,
        about resource query commands, refer to  [ibmcloud schematics resource query
        delete](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-delete-resource-query).
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str query_id: Resource query Id.  Use `GET /v2/resource_query` API
               to look up the Resource query definition Ids  in your IBM Cloud account.
        :param bool force: (optional) Equivalent to -force options in the command
               line.
        :param bool propagate: (optional) Auto propagate the chaange or deletion to
               the dependent resources.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if query_id is None:
            raise ValueError('query_id must be provided')
        headers = {
            'force': force,
            'propagate': propagate
        }
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_resources_query')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['query_id']
        path_param_values = self.encode_path_vars(query_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/resources_query/{query_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response

    #########################
    # agent
    #########################


    def list_agent(self,
        *,
        offset: int = None,
        limit: int = None,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all registered agents, in the Account.

        Get all registered agents, in the Account.

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AgentList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_agent')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/agents'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def register_agent(self,
        agent: 'Agent',
        **kwargs
    ) -> DetailedResponse:
        """
        Register the agent with schematics.

        Register the agent with schematics.

        :param Agent agent: Register the agent with schematics.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Agent` object
        """

        if agent is None:
            raise ValueError('agent must be provided')
        if isinstance(agent, Agent):
            agent = convert_model(agent)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='register_agent')
        headers.update(sdk_headers)

        data = json.dumps(agent)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/agents'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_agent(self,
        agent_id: str,
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the registered agent details.

        Get the registered agent details.

        :param str agent_id: Agent ID to get the details of agent.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Agent` object
        """

        if agent_id is None:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_agent')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/agents/{agent_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def delete_agent(self,
        agent_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Deregister the agent.

        Deregister the agent.

        :param str agent_id: Agent ID to get the details of agent.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if agent_id is None:
            raise ValueError('agent_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_agent')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/agents/{agent_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def update_agent_registration(self,
        agent_id: str,
        agent: 'Agent',
        **kwargs
    ) -> DetailedResponse:
        """
        Update the agent registration.

        Update the agent registeration.

        :param str agent_id: Agent ID to get the details of agent.
        :param Agent agent: Update the agent registration.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Agent` object
        """

        if agent_id is None:
            raise ValueError('agent_id must be provided')
        if agent is None:
            raise ValueError('agent must be provided')
        if isinstance(agent, Agent):
            agent = convert_model(agent)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_agent_registration')
        headers.update(sdk_headers)

        data = json.dumps(agent)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['agent_id']
        path_param_values = self.encode_path_vars(agent_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/agents/{agent_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response

    #########################
    # reference-data
    #########################


    def get_dataset_variable_value(self,
        dataset_id: str,
        var_name: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Shared dataset value for {var_name}.

        Get the Shared dataset value for {var_name}; "$$D(dataset_id):$$V(var_name)".

        :param str dataset_id: Shared dataset Id.  Use `GET /v2/datasets` API to
               look up the Shared dataset Ids  in your IBM Cloud account.
        :param str var_name: Name of the variable.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueResponse` object
        """

        if dataset_id is None:
            raise ValueError('dataset_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_dataset_variable_value')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['dataset_id', 'var_name']
        path_param_values = self.encode_path_vars(dataset_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/datasets/{dataset_id}/values/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def get_credential_variable_value(self,
        creds_id: str,
        var_name: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the credential value for {var_name}.

        Get the credential value for {var_name}; "$$C(creds_id):$$V(var_name)".

        :param str creds_id: Credentials Id.  Use `GET /v2/credentials` API to look
               up the Credentials Ids  in your IBM Cloud account.
        :param str var_name: Name of the variable.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueResponse` object
        """

        if creds_id is None:
            raise ValueError('creds_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_credential_variable_value')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['creds_id', 'var_name']
        path_param_values = self.encode_path_vars(creds_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/credentials/{creds_id}/variables/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def get_inventory_variable_value(self,
        inventory_id: str,
        var_name: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the resource ids for {var_name}.

        Get the resource ids for {var_name}.

        :param str inventory_id: Resource Inventory Id.  Use `GET /v2/inventories`
               API to look up the Resource Inventory definition Ids  in your IBM Cloud
               account.
        :param str var_name: Name of the variable.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueListResponse` object
        """

        if inventory_id is None:
            raise ValueError('inventory_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_inventory_variable_value')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['inventory_id', 'var_name']
        path_param_values = self.encode_path_vars(inventory_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/inventories/{inventory_id}/variables/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def get_workspace_input_value(self,
        w_id: str,
        var_name: str,
        *,
        limit: int = None,
        offset: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Workspace Input value for {var_name}, used by the recent job execution.

        Get Workspace Input value for {var_name}, used by the recent job execution;
        "$$W(workspace_name):$$I(var_name)".

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str var_name: Name of the variable.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueResponse` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_workspace_input_value')
        headers.update(sdk_headers)

        params = {
            'limit': limit,
            'offset': offset
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 'var_name']
        path_param_values = self.encode_path_vars(w_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/inputs/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_workspace_output_value(self,
        w_id: str,
        var_name: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Workspace Output value for {var_name}, produced by the recent job execution.

        Get Workspace Output value for {var_name}, produced by the recent job execution;
        "$$W(workspace_name):$$O(var_name)".

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str var_name: Name of the variable.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueResponse` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_workspace_output_value')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 'var_name']
        path_param_values = self.encode_path_vars(w_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/outputs/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_workspace_settings_value(self,
        w_id: str,
        var_name: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Workspace environment setting value for {var_name}, used by the recent job execution.

        Get Workspace environment setting value for {var_name}, used by the recent job
        execution; "$$W(workspace_name):$$S(var_name)".

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str var_name: Name of the variable.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueResponse` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_workspace_settings_value')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 'var_name']
        path_param_values = self.encode_path_vars(w_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/settings/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_workspace_template_input_value(self,
        w_id: str,
        t_id: str,
        var_name: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Workspace Input value for {var_name}, used by the recent job execution.

        Get Workspace Input value for {var_name}, used by the recent job execution;
        "$$W(workspace_name):$$T(template_name):$$I(var_name)".

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param str var_name: Name of the variable.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueResponse` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_workspace_template_input_value')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id', 'var_name']
        path_param_values = self.encode_path_vars(w_id, t_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}/inputs/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_workspace_template_output_value(self,
        w_id: str,
        t_id: str,
        var_name: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Workspace Output value for {var_name}, produced by the recent job execution.

        Get Workspace Output value for {var_name}, produced by the recent job execution;
        "$$W(workspace_name):$$T(template_name):$$O(var_name)".

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param str var_name: Name of the variable.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueResponse` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_workspace_template_output_value')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id', 'var_name']
        path_param_values = self.encode_path_vars(w_id, t_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}/outputs/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_workspace_template_setting_value(self,
        w_id: str,
        t_id: str,
        var_name: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Workspace environment setting value for {var_name}, used by the recent job execution.

        Get Workspace environment setting value for {var_name}, used by the recent job
        execution; "$$W(workspace_name):$$T(template_name):$$S(var_name)".

        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str t_id: The ID of the Terraform template in your workspace.  When
               you create a workspace, the Terraform template that  your workspace points
               to is assigned a unique ID. Use the `GET /v1/workspaces` to look up the
               workspace IDs  and template IDs or `template_data.id` in your IBM Cloud
               account.
        :param str var_name: Name of the variable.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueResponse` object
        """

        if w_id is None:
            raise ValueError('w_id must be provided')
        if t_id is None:
            raise ValueError('t_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_workspace_template_setting_value')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['w_id', 't_id', 'var_name']
        path_param_values = self.encode_path_vars(w_id, t_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/workspaces/{w_id}/templates/{t_id}/settings/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_job_workspace_input_value(self,
        job_id: str,
        w_id: str,
        var_name: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Workspace Input value for {var_name}, used by the job {job_id}.

        Get Workspace Input value for {var_name}, used by the recent job execution;
        "$$J(job_id):$$W(workspace_name):$$I(var_name)".

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str var_name: Name of the variable.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueResponse` object
        """

        if job_id is None:
            raise ValueError('job_id must be provided')
        if w_id is None:
            raise ValueError('w_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_job_workspace_input_value')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['job_id', 'w_id', 'var_name']
        path_param_values = self.encode_path_vars(job_id, w_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}/workspaces/{w_id}/inputs/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_job_workspace_output_value(self,
        job_id: str,
        w_id: str,
        var_name: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Workspace Output value for {var_name}, produced by the job {job_id}.

        Get Workspace Output value for {var_name}, produced by the recent job execution;
        "$$J(job_id):$$W(workspace_name):$$O(var_name)".

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str var_name: Name of the variable.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueResponse` object
        """

        if job_id is None:
            raise ValueError('job_id must be provided')
        if w_id is None:
            raise ValueError('w_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_job_workspace_output_value')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['job_id', 'w_id', 'var_name']
        path_param_values = self.encode_path_vars(job_id, w_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}/workspaces/{w_id}/outputs/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_job_workspace_setting_value(self,
        job_id: str,
        w_id: str,
        var_name: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Workspace environment setting value for {var_name}, used by the recent job execution.

        Get Workspace environment setting value for {var_name}, used by the recent job
        execution; "$$J(job_id):$$W(workspace_name):$$S(var_name)".

        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param str w_id: The ID of the workspace.  To find the workspace ID, use
               the `GET /v1/workspaces` API.
        :param str var_name: Name of the variable.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ValueResponse` object
        """

        if job_id is None:
            raise ValueError('job_id must be provided')
        if w_id is None:
            raise ValueError('w_id must be provided')
        if var_name is None:
            raise ValueError('var_name must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_job_workspace_setting_value')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['job_id', 'w_id', 'var_name']
        path_param_values = self.encode_path_vars(job_id, w_id, var_name)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/jobs/{job_id}/workspaces/{w_id}/settings/{var_name}/value'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response

    #########################
    # settings-kms
    #########################


    def get_kms_settings(self,
        location: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get a KMS settings.

        Retrieve the kms instance that is integrated with Schematics for the **byok** and
        **kyok**. For each geographic location supported in Schematics we can have
        different kms settings. For example `US` and `EU` will have different kms
        settings.
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str location: The location of the Resource.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `KMSSettings` object
        """

        if location is None:
            raise ValueError('location must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_kms_settings')
        headers.update(sdk_headers)

        params = {
            'location': location
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/kms'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def update_kms_settings(self,
        kms_settings: 'KMSSettings',
        **kwargs
    ) -> DetailedResponse:
        """
        Update a KMS settings.

        Replace or Update kms settings for a given location can be updated.
        **Note** you can update the kms settings only once. For example, if you use an API
        endpoint for a geography, such as North America, only kms settings for that region
        can be retrieved.
        <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param KMSSettings kms_settings: Options to be provided with updating kms
               settings.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `KMSSettings` object
        """

        if kms_settings is None:
            raise ValueError('kms_settings must be provided')
        if isinstance(kms_settings, KMSSettings):
            kms_settings = convert_model(kms_settings)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_kms_settings')
        headers.update(sdk_headers)

        data = json.dumps(kms_settings)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/kms'
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def list_kms(self,
        encryption_scheme: str,
        location: str,
        *,
        resource_group: str = None,
        limit: int = None,
        sort: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        List KMS instances.

        Lists the kms instances of your IBM Cloud account to find your Key Protect or
        Hyper Protect Crypto Services by using the location and encrypted scheme.
         <h3>Authorization</h3>
         Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions, see
         [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str encryption_scheme: The encryption scheme to be used.
        :param str location: The location of the Resource.
        :param str resource_group: (optional) The resource group (by default, fetch
               from all resource groups).
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `KMSDiscovery` object
        """

        if encryption_scheme is None:
            raise ValueError('encryption_scheme must be provided')
        if location is None:
            raise ValueError('location must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_kms')
        headers.update(sdk_headers)

        params = {
            'encryption_scheme': encryption_scheme,
            'location': location,
            'resource_group': resource_group,
            'limit': limit,
            'sort': sort
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/kms_instances'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response

    #########################
    # settings-triggers
    #########################


    def list_triggers(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all the Schematics triggers.

        Get all the Schematics triggers.

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TriggerList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_triggers')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/triggers'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_trigger(self,
        trigger: 'Trigger',
        **kwargs
    ) -> DetailedResponse:
        """
        Register a Schematics trigger.

        Register a Schematics trigger.

        :param Trigger trigger: Register a Scheduling or Action Trigger with
               Schematics.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Trigger` object
        """

        if trigger is None:
            raise ValueError('trigger must be provided')
        if isinstance(trigger, Trigger):
            trigger = convert_model(trigger)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_trigger')
        headers.update(sdk_headers)

        data = json.dumps(trigger)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/triggers'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_trigger(self,
        trigger_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Schematics trigger.

        Get the Schematics trigger.

        :param str trigger_id: Id of the Schematics trigger.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Trigger` object
        """

        if trigger_id is None:
            raise ValueError('trigger_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_trigger')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['trigger_id']
        path_param_values = self.encode_path_vars(trigger_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/triggers/{trigger_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def replace_trigger(self,
        trigger_id: str,
        trigger: 'Trigger',
        **kwargs
    ) -> DetailedResponse:
        """
        Replace the Schematics trigger.

        Replace the Schematics trigger.

        :param str trigger_id: Id of the Schematics trigger.
        :param Trigger trigger: Replace the Schematics trigger.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Trigger` object
        """

        if trigger_id is None:
            raise ValueError('trigger_id must be provided')
        if trigger is None:
            raise ValueError('trigger must be provided')
        if isinstance(trigger, Trigger):
            trigger = convert_model(trigger)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='replace_trigger')
        headers.update(sdk_headers)

        data = json.dumps(trigger)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['trigger_id']
        path_param_values = self.encode_path_vars(trigger_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/triggers/{trigger_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def delete_trigger(self,
        trigger_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Unregister the Schematics trigger.

        Delete the Schematics trigger.

        :param str trigger_id: Id of the Schematics trigger.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if trigger_id is None:
            raise ValueError('trigger_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_trigger')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['trigger_id']
        path_param_values = self.encode_path_vars(trigger_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/triggers/{trigger_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response

    #########################
    # settings-hook
    #########################


    def list_webhook(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all the Schematics web-hooks.

        Get all the Schematics web-hooks.

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WebHookList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_webhook')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/hooks'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_webhook(self,
        web_hook: 'WebHook',
        **kwargs
    ) -> DetailedResponse:
        """
        Register a Schematics web-hook.

        Register a Schematics web-hook.

        :param WebHook web_hook: Register a Web-hook or callback (pre- & post-
               actions, such as initialise, redeploy, reconfigure, refresh) with
               Schematics.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WebHook` object
        """

        if web_hook is None:
            raise ValueError('web_hook must be provided')
        if isinstance(web_hook, WebHook):
            web_hook = convert_model(web_hook)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_webhook')
        headers.update(sdk_headers)

        data = json.dumps(web_hook)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/hooks'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_webhook(self,
        hook_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Schematics web-hook.

        Get the Schematics web-hook.

        :param str hook_id: Id of the Schematics web-hook.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WebHook` object
        """

        if hook_id is None:
            raise ValueError('hook_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_webhook')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['hook_id']
        path_param_values = self.encode_path_vars(hook_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/hooks/{hook_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def replace_webhook(self,
        hook_id: str,
        web_hook: 'WebHook',
        **kwargs
    ) -> DetailedResponse:
        """
        Replace the Schematics web-hook.

        Replace the Schematics web-hooks.

        :param str hook_id: Id of the Schematics web-hook.
        :param WebHook web_hook: Replace the Schematics web-hook.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `WebHook` object
        """

        if hook_id is None:
            raise ValueError('hook_id must be provided')
        if web_hook is None:
            raise ValueError('web_hook must be provided')
        if isinstance(web_hook, WebHook):
            web_hook = convert_model(web_hook)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='replace_webhook')
        headers.update(sdk_headers)

        data = json.dumps(web_hook)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['hook_id']
        path_param_values = self.encode_path_vars(hook_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/hooks/{hook_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def delete_webhook(self,
        hook_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Unregister the Schematics web-hook.

        Delete the Schematics web-hook.

        :param str hook_id: Id of the Schematics web-hook.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if hook_id is None:
            raise ValueError('hook_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_webhook')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['hook_id']
        path_param_values = self.encode_path_vars(hook_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/hooks/{hook_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response

    #########################
    # settings-private-cluster
    #########################


    def get_private_cluster(self,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the details of private cluster registered with Schematics.

        Get the details of private cluster registered with Schematics.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `PrivateClusterList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_private_cluster')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/private_clusters'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def create_private_cluster(self,
        private_cluster: 'PrivateCluster',
        **kwargs
    ) -> DetailedResponse:
        """
        Register your private cluster with Schematics.

        Register your private Kubernetes cluster, that will be used by schematics to run
        its Job (over a private network).

        :param PrivateCluster private_cluster: Register your private cluster with
               Schematics to run the jobs.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `PrivateCluster` object
        """

        if private_cluster is None:
            raise ValueError('private_cluster must be provided')
        if isinstance(private_cluster, PrivateCluster):
            private_cluster = convert_model(private_cluster)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_private_cluster')
        headers.update(sdk_headers)

        data = json.dumps(private_cluster)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/private_clusters'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def delete_private_cluster(self,
        **kwargs
    ) -> DetailedResponse:
        """
        Un-register your private cluster with Schematics.

        Un-register the private cluster registered with Schematics.

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_private_cluster')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        url = '/v2/settings/private_clusters'
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response

    #########################
    # settings-external-adapter
    #########################


    def list_adapter(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all Schematics Adapter definitions.

        Get all the registered Schematics Adapter definitions.

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `AdapterList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_adapter')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort,
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/adapters'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_adapter(self,
        adapter: 'Adapter',
        **kwargs
    ) -> DetailedResponse:
        """
        Register an Adapter definition with Schematics.

        Register an adapter with Schematics, used to access your SCM Repo, Action,
        Provisioner, Data, and Credentials.

        :param Adapter adapter: Adapter Register Request.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Adapter` object
        """

        if adapter is None:
            raise ValueError('adapter must be provided')
        if isinstance(adapter, Adapter):
            adapter = convert_model(adapter)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_adapter')
        headers.update(sdk_headers)

        data = json.dumps(adapter)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/adapters'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_adapter(self,
        adapter_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the Schematics Adapter definition.

        Get the Schematics Adapter definition.

        :param str adapter_id: Id of the Schematics Adapter.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Adapter` object
        """

        if adapter_id is None:
            raise ValueError('adapter_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_adapter')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['adapter_id']
        path_param_values = self.encode_path_vars(adapter_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/adapters/{adapter_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def replace_adapter(self,
        adapter_id: str,
        adapter: 'Adapter',
        **kwargs
    ) -> DetailedResponse:
        """
        Replace the Schematics Adapter definition.

        Replace the Schematics Adapter definition.

        :param str adapter_id: Id of the Schematics Adapter.
        :param Adapter adapter: Replace the Schematics Adapter definition.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Adapter` object
        """

        if adapter_id is None:
            raise ValueError('adapter_id must be provided')
        if adapter is None:
            raise ValueError('adapter must be provided')
        if isinstance(adapter, Adapter):
            adapter = convert_model(adapter)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='replace_adapter')
        headers.update(sdk_headers)

        data = json.dumps(adapter)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['adapter_id']
        path_param_values = self.encode_path_vars(adapter_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/adapters/{adapter_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def delete_adapter(self,
        adapter_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Unregister the Schematics Adapter definition.

        Delete the Schematics Adapter definition.

        :param str adapter_id: Id of the Schematics Adapter.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if adapter_id is None:
            raise ValueError('adapter_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_adapter')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['adapter_id']
        path_param_values = self.encode_path_vars(adapter_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/adapters/{adapter_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response

    #########################
    # settings-datasource
    #########################


    def list_connection(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get connection definition.

        Get all external connection definition.

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ConnectionList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_connection')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/connections'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_connection(self,
        connection: 'Connection',
        **kwargs
    ) -> DetailedResponse:
        """
        Register an connection definition for an external datastore.

        Register an external connection definition.

        :param Connection connection: Register a new connection.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Connection` object
        """

        if connection is None:
            raise ValueError('connection must be provided')
        if isinstance(connection, Connection):
            connection = convert_model(connection)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_connection')
        headers.update(sdk_headers)

        data = json.dumps(connection)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/connections'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_connection(self,
        connection_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get connection definition for external datastore.

        Get the external connection definition.

        :param str connection_id: The ID of the connection.  To find the connection
               ID, use the `GET /v2/connections` API.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ConnectionLite` object
        """

        if connection_id is None:
            raise ValueError('connection_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_connection')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['connection_id']
        path_param_values = self.encode_path_vars(connection_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/connections/{connection_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def delete_connection(self,
        connection_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Unregister connection definition.

        Delete the Schematics external data source connection definition.

        :param str connection_id: The ID of the connection.  To find the connection
               ID, use the `GET /v2/connections` API.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if connection_id is None:
            raise ValueError('connection_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_connection')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['connection_id']
        path_param_values = self.encode_path_vars(connection_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/connections/{connection_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def list_datasources(self,
        *,
        offset: int = None,
        limit: int = None,
        sort: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all datasources registered with Schematics.

        Get all datasource registered with Schematics.

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str sort: (optional) Name of the field to sort-by;  Use the '.'
               character to delineate sub-resources and sub-fields (eg. owner.last_name).
               Prepend the field with '+' or '-', indicating 'ascending' or 'descending'
               (default is ascending)   Ignore unrecognized or unsupported sort field.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `DatasourceList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_datasources')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'sort': sort
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/datasources'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_datasource(self,
        datasource: 'Datasource',
        **kwargs
    ) -> DetailedResponse:
        """
        Register a datasource definition.

        Register a datasource definition.

        :param Datasource datasource: Register a datasource.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Datasource` object
        """

        if datasource is None:
            raise ValueError('datasource must be provided')
        if isinstance(datasource, Datasource):
            datasource = convert_model(datasource)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_datasource')
        headers.update(sdk_headers)

        data = json.dumps(datasource)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/settings/datasources'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_data(self,
        datasource_id: str,
        *,
        preview: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get a data from the datasource.

        Get data from the datasource.

        :param str datasource_id: The ID of the datasource created.
        :param str preview: (optional) Preview the data from the datasource.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `PreviewData` object
        """

        if datasource_id is None:
            raise ValueError('datasource_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_data')
        headers.update(sdk_headers)

        params = {
            'preview': preview
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['datasource_id']
        path_param_values = self.encode_path_vars(datasource_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/settings/datasources/{datasource_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response

    #########################
    # fulfilment
    #########################


    def list_cart(self,
        *,
        offset: int = None,
        limit: int = None,
        service_name: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        List fulfilment job order.

        Retrieve a list of all fulfilment job order for the cart that depends on the API
        endpoint that you have access. For example, if you use an API endpoint for a
        geography, such as North America, only actions that are created in us-south or
        us-east are retrieved.
        <h3>Authorization</h3> Schematics support generic authorization for its resources.
        For more information, about Schematics access and permissions, see [Schematics
        service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str service_name: (optional) Short name of the IBM Cloud service.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CartOrderList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_cart')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'service_name': service_name
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/cart'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_cart_order(self,
        cart_order: 'CartOrder',
        **kwargs
    ) -> DetailedResponse:
        """
        Create a fulfilment job order.

        Create an IBM Cloud Schematics fulfilment job order for the cart that points to
        your account. For example, if you use an API endpoint for a geography, such as
        North America, only actions that are created in us-south or us-east are retrieved.
        Getting API endpoint:- * The Schematics API endpoint that you use to create the
        fulfilment determines where your Schematics job run and your data is stored. See
        API endpoints for more information. * If you use the API endpoint for a geography
        and not a specific location, such as North America, you can specify the location
        in your API request body. * If you do not specify the location in the request
        body, Schematics determines your fulfilment location based on availability. * If
        you use an API endpoint for a specific location, such as Frankfurt, the location
        that you enter in your API request body must match your API endpoint. * You also
        have the option to not specify a location in your API request body if you use a
        location-specific API endpoint.
        <h3>Authorization</h3> Schematics support generic authorization for its resources.
        For more information, about Schematics access and permissions, see [Schematics
        service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param CartOrder cart_order: Create fulfilment job order for the cart.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CartOrder` object
        """

        if cart_order is None:
            raise ValueError('cart_order must be provided')
        if isinstance(cart_order, CartOrder):
            cart_order = convert_model(cart_order)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_cart_order')
        headers.update(sdk_headers)

        data = json.dumps(cart_order)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/cart'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_cart_order(self,
        order_id: str,
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get fulfilment job order details.

        Retrieve detailed information for a fulfilment job order for the cart details in
        your IBM Cloud account.
        <h3>Authorization</h3> Schematics support generic authorization for its resources.
        For more information, about Schematics access and permissions, see [Schematics
        service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str order_id: Fulfilment job order Id.  Use `GET /v2/cart` API to
               look up the order ids in your IBM Cloud account.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CartOrder` object
        """

        if order_id is None:
            raise ValueError('order_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_cart_order')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['order_id']
        path_param_values = self.encode_path_vars(order_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/cart/{order_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def replace_cart_order(self,
        order_id: str,
        operation: str,
        cart_order: 'CartOrder',
        **kwargs
    ) -> DetailedResponse:
        """
        Update fulfilment job order.

        Use this API to update or replace the entire fulfilment job order for the cart in
        your IBM Cloud account.
        <h3>Authorization</h3> Schematics support generic authorization for its resources.
        For more information, about Schematics access and permissions, see [Schematics
        service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str order_id: Fulfilment job order Id.  Use `GET /v2/cart` API to
               look up the order ids in your IBM Cloud account.
        :param str operation: The name of fulfilment job operation (install,
               uninstall, configure, operate, dryrun, update, destroy).
        :param CartOrder cart_order: Update the fulfilment job order and run the
               job.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CartOrder` object
        """

        if order_id is None:
            raise ValueError('order_id must be provided')
        if operation is None:
            raise ValueError('operation must be provided')
        if cart_order is None:
            raise ValueError('cart_order must be provided')
        if isinstance(cart_order, CartOrder):
            cart_order = convert_model(cart_order)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='replace_cart_order')
        headers.update(sdk_headers)

        params = {
            'operation': operation
        }

        data = json.dumps(cart_order)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['order_id']
        path_param_values = self.encode_path_vars(order_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/cart/{order_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       params=params,
                                       data=data)

        response = self.send(request)
        return response


    def run_fulfilment_operation(self,
        order_id: str,
        operation: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Run the fulfilment job operation for the cart.

        Run the fulfilment job operation for the cart
        <h3>Authorization</h3> Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,  see [Schematics
        service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str order_id: Fulfilment job order Id.  Use `GET /v2/cart` API to
               look up the order ids in your IBM Cloud account.
        :param str operation: The name of fulfilment job operation (install,
               uninstall, configure, operate, dryrun, update, destroy).
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if order_id is None:
            raise ValueError('order_id must be provided')
        if operation is None:
            raise ValueError('operation must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='run_fulfilment_operation')
        headers.update(sdk_headers)

        params = {
            'operation': operation
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['order_id']
        path_param_values = self.encode_path_vars(order_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/cart/{order_id}'.format(**path_param_dict)
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def delete_cart_order(self,
        order_id: str,
        *,
        destroy: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete a fulfilment job order.

        Deletes a fulfilment job order for the card in your IBM Cloud account.
        <h3>Authorization</h3> Schematics support generic authorization for its resources.
         For more information, about Schematics access and permissions,  see [Schematics
        service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str order_id: Fulfilment job order Id.  Use `GET /v2/cart` API to
               look up the order ids in your IBM Cloud account.
        :param bool destroy: (optional) Destroy the resources before deleting the
               fulfilment job order (default=true).
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if order_id is None:
            raise ValueError('order_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_cart_order')
        headers.update(sdk_headers)

        params = {
            'destroy': destroy
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['order_id']
        path_param_values = self.encode_path_vars(order_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/cart/{order_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def update_cart_order(self,
        order_id: str,
        operation: str,
        update_cart_order: 'UpdateCartOrder',
        **kwargs
    ) -> DetailedResponse:
        """
        Update fulfilment job order.

        Use this API to update or replace the entire fulfilment job order for the cart in
        your IBM Cloud account.
        <h3>Authorization</h3> Schematics support generic authorization for its resources.
        For more information, about Schematics access and permissions, see [Schematics
        service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param str order_id: Fulfilment job order Id.  Use `GET /v2/cart` API to
               look up the order ids in your IBM Cloud account.
        :param str operation: The name of fulfilment job operation (install,
               uninstall, configure, operate, dryrun, update, destroy).
        :param UpdateCartOrder update_cart_order: Update the fulfilment job order
               and contextually run.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CartOrder` object
        """

        if order_id is None:
            raise ValueError('order_id must be provided')
        if operation is None:
            raise ValueError('operation must be provided')
        if update_cart_order is None:
            raise ValueError('update_cart_order must be provided')
        if isinstance(update_cart_order, UpdateCartOrder):
            update_cart_order = convert_model(update_cart_order)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_cart_order')
        headers.update(sdk_headers)

        params = {
            'operation': operation
        }

        data = json.dumps(update_cart_order)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['order_id']
        path_param_values = self.encode_path_vars(order_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/cart/{order_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       params=params,
                                       data=data)

        response = self.send(request)
        return response


    def get_cart_metadata(self,
        order_id: str,
        **kwargs
    ) -> DetailedResponse:
        """
        Get metadata for the fulfilment job order.

        Get variable and operation metadata for the fulfilment job order.

        :param str order_id: Fulfilment job order Id.  Use `GET /v2/cart` API to
               look up the order ids in your IBM Cloud account.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `ItemMetadata` object
        """

        if order_id is None:
            raise ValueError('order_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_cart_metadata')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['order_id']
        path_param_values = self.encode_path_vars(order_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/cart/{order_id}/metadata'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


    def list_cart_resources(self,
        order_id: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get current list of cloud sources, fulfilled by the cart.

        Get current list of cloud resources, fulfilled by the cart.

        :param str order_id: Fulfilment job order Id.  Use `GET /v2/cart` API to
               look up the order ids in your IBM Cloud account.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CloudResourceList` object
        """

        if order_id is None:
            raise ValueError('order_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_cart_resources')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['order_id']
        path_param_values = self.encode_path_vars(order_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/cart/{order_id}/resources'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def list_cart_order_jobs(self,
        order_id: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the list of fulfilment jobs performed on the cart.

        Get list of fulfilment jobs performed on the cart.

        :param str order_id: Fulfilment job order Id.  Use `GET /v2/cart` API to
               look up the order ids in your IBM Cloud account.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `JobList` object
        """

        if order_id is None:
            raise ValueError('order_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_cart_order_jobs')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['order_id']
        path_param_values = self.encode_path_vars(order_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/cart/{order_id}/jobs'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_cart_order_job(self,
        order_id: str,
        job_id: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get fulfilment job details.

        Get fulfilment job details.

        :param str order_id: Fulfilment job order Id.  Use `GET /v2/cart` API to
               look up the order ids in your IBM Cloud account.
        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `JobLite` object
        """

        if order_id is None:
            raise ValueError('order_id must be provided')
        if job_id is None:
            raise ValueError('job_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_cart_order_job')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['order_id', 'job_id']
        path_param_values = self.encode_path_vars(order_id, job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/cart/{order_id}/jobs/{job_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_cart_order_job_log(self,
        order_id: str,
        job_id: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the fulfilment job logs.

        Get the fulfilment job logs.

        :param str order_id: Fulfilment job order Id.  Use `GET /v2/cart` API to
               look up the order ids in your IBM Cloud account.
        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `JobLog` object
        """

        if order_id is None:
            raise ValueError('order_id must be provided')
        if job_id is None:
            raise ValueError('job_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_cart_order_job_log')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['order_id', 'job_id']
        path_param_values = self.encode_path_vars(order_id, job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/cart/{order_id}/jobs/{job_id}/logs'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_cart_order_job_resources(self,
        order_id: str,
        job_id: str,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the fulfilment job resources.

        Get the fulfilment job resources.

        :param str order_id: Fulfilment job order Id.  Use `GET /v2/cart` API to
               look up the order ids in your IBM Cloud account.
        :param str job_id: Job Id. Use `GET /v2/jobs` API to look up the Job Ids in
               your IBM Cloud account.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CloudResourceList` object
        """

        if order_id is None:
            raise ValueError('order_id must be provided')
        if job_id is None:
            raise ValueError('job_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_cart_order_job_resources')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['order_id', 'job_id']
        path_param_values = self.encode_path_vars(order_id, job_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/cart/{order_id}/jobs/{job_id}/resources'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response

    #########################
    # blueprint
    #########################


    def list_blueprint(self,
        *,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get all the blueprint instances, in the Account.

        Get all the blueprint instances, in the Account, associated with a Service.

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `BlueprintList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_blueprint')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/blueprints'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def create_blueprint(self,
        blueprint: 'Blueprint',
        **kwargs
    ) -> DetailedResponse:
        """
        Create a new blueprint.

        Create a new blueprint.

        :param Blueprint blueprint: Create blueprint.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Blueprint` object
        """

        if blueprint is None:
            raise ValueError('blueprint must be provided')
        if isinstance(blueprint, Blueprint):
            blueprint = convert_model(blueprint)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='create_blueprint')
        headers.update(sdk_headers)

        data = json.dumps(blueprint)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/blueprints'
        request = self.prepare_request(method='POST',
                                       url=url,
                                       headers=headers,
                                       data=data)

        response = self.send(request)
        return response


    def get_blueprint(self,
        blueprint_id: str,
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the blueprint details.

        Get the blueprint details.

        :param str blueprint_id: Environment Id.  Use `GET /v2/blueprints` API to
               look up the order ids in your IBM Cloud account.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Blueprint` object
        """

        if blueprint_id is None:
            raise ValueError('blueprint_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_blueprint')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['blueprint_id']
        path_param_values = self.encode_path_vars(blueprint_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/blueprints/{blueprint_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def replace_blueprint(self,
        blueprint_id: str,
        blueprint: 'Blueprint',
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Update the blueprint details.

        Update the blueprint details.

        :param str blueprint_id: Environment Id.  Use `GET /v2/blueprints` API to
               look up the order ids in your IBM Cloud account.
        :param Blueprint blueprint: Update the blueprint details.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Blueprint` object
        """

        if blueprint_id is None:
            raise ValueError('blueprint_id must be provided')
        if blueprint is None:
            raise ValueError('blueprint must be provided')
        if isinstance(blueprint, Blueprint):
            blueprint = convert_model(blueprint)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='replace_blueprint')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        data = json.dumps(blueprint)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['blueprint_id']
        path_param_values = self.encode_path_vars(blueprint_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/blueprints/{blueprint_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       params=params,
                                       data=data)

        response = self.send(request)
        return response


    def delete_blueprint(self,
        blueprint_id: str,
        *,
        profile: str = None,
        destroy: bool = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Delete the blueprint.

        Delete the blueprint.

        :param str blueprint_id: Environment Id.  Use `GET /v2/blueprints` API to
               look up the order ids in your IBM Cloud account.
        :param str profile: (optional) Level of details returned by the get method.
        :param bool destroy: (optional) Destroy the resources before deleting the
               blueprint.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse
        """

        if blueprint_id is None:
            raise ValueError('blueprint_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='delete_blueprint')
        headers.update(sdk_headers)

        params = {
            'profile': profile,
            'destroy': destroy
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))

        path_param_keys = ['blueprint_id']
        path_param_values = self.encode_path_vars(blueprint_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/blueprints/{blueprint_id}'.format(**path_param_dict)
        request = self.prepare_request(method='DELETE',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def update_blueprint(self,
        blueprint_id: str,
        blueprint: 'Blueprint',
        *,
        profile: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Update the blueprint details.

        Update the blueprint details.

        :param str blueprint_id: Environment Id.  Use `GET /v2/blueprints` API to
               look up the order ids in your IBM Cloud account.
        :param Blueprint blueprint: Update the blueprint details.
        :param str profile: (optional) Level of details returned by the get method.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `Blueprint` object
        """

        if blueprint_id is None:
            raise ValueError('blueprint_id must be provided')
        if blueprint is None:
            raise ValueError('blueprint must be provided')
        if isinstance(blueprint, Blueprint):
            blueprint = convert_model(blueprint)
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='update_blueprint')
        headers.update(sdk_headers)

        params = {
            'profile': profile
        }

        data = json.dumps(blueprint)
        headers['content-type'] = 'application/json'

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['blueprint_id']
        path_param_values = self.encode_path_vars(blueprint_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/blueprints/{blueprint_id}'.format(**path_param_dict)
        request = self.prepare_request(method='PATCH',
                                       url=url,
                                       headers=headers,
                                       params=params,
                                       data=data)

        response = self.send(request)
        return response


    def upload_template_tar_blueprint(self,
        blueprint_id: str,
        *,
        file: BinaryIO = None,
        file_content_type: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Upload a TAR file to an blueprint.

        Update your blueprint by uploading tape archive file (.tar) file from your local
        machine.

        :param str blueprint_id: Environment Id.  Use `GET /v2/blueprints` API to
               look up the order ids in your IBM Cloud account.
        :param BinaryIO file: (optional) Template tar file.
        :param str file_content_type: (optional) The content type of file.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `TemplateRepoTarUploadResponse` object
        """

        if blueprint_id is None:
            raise ValueError('blueprint_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='upload_template_tar_blueprint')
        headers.update(sdk_headers)

        form_data = []
        if file:
            form_data.append(('file', (None, file, file_content_type or 'application/octet-stream')))

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['blueprint_id']
        path_param_values = self.encode_path_vars(blueprint_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/blueprints/{blueprint_id}/template_repo_upload'.format(**path_param_dict)
        request = self.prepare_request(method='PUT',
                                       url=url,
                                       headers=headers,
                                       files=form_data)

        response = self.send(request)
        return response

    #########################
    # catalog
    #########################


    def list_catalog_items(self,
        *,
        offset: int = None,
        limit: int = None,
        catalog_id: str = None,
        catalog_name: str = None,
        **kwargs
    ) -> DetailedResponse:
        """
        List all the items from the catalog.

        Get all items in the catalog, filtered by offering kind.

        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param str catalog_id: (optional) Catalog ID to get the list of
               environments defined as part of offerings.
        :param str catalog_name: (optional) Catalog Name to get the list of
               environments defined as part of offerings.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `List[CatalogOfferingItem]` result
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_catalog_items')
        headers.update(sdk_headers)

        params = {
            'offset': offset,
            'limit': limit,
            'catalog_id': catalog_id,
            'catalog_name': catalog_name
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/catalog'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response


    def get_catalog_item(self,
        offering_id: str,
        *,
        catalog_id: str = None,
        catalog_name: str = None,
        offering_name: str = None,
        offering_version: str = None,
        offset: int = None,
        limit: int = None,
        **kwargs
    ) -> DetailedResponse:
        """
        Get the catalog item details.

        Get the catalog item details for a given catalog_id, offering_id and offering
        version.

        :param str offering_id: Catalog ID to get the list of environments defined
               as part of offerings.
        :param str catalog_id: (optional) Catalog ID to get the list of
               environments defined as part of offerings.
        :param str catalog_name: (optional) Catalog Name to get the list of
               environments defined as part of offerings.
        :param str offering_name: (optional) Offering Name to get the list of
               environments defined as part of offerings.
        :param str offering_version: (optional) Version of the offering.
        :param int offset: (optional) The starting position of the item in the list
               of items. For example, if you have three workspaces in your account, the
               first workspace is assigned position number 0, the second workspace is
               assigned position number 1, and so forth. If you have 6 workspaces and you
               want to list the details for workspaces `2-6`, enter 1. To limit the number
               of workspaces that is returned, use the `limit` option in addition to the
               `offset` option. Negative numbers are not supported and are ignored.
        :param int limit: (optional) The maximum number of items that you want to
               list. The number must be a positive integer between 1 and 2000. If no value
               is provided, 100 is used by default.
        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `CatalogOfferingItem` object
        """

        if offering_id is None:
            raise ValueError('offering_id must be provided')
        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='get_catalog_item')
        headers.update(sdk_headers)

        params = {
            'catalog_id': catalog_id,
            'catalog_name': catalog_name,
            'offering_name': offering_name,
            'offering_version': offering_version,
            'offset': offset,
            'limit': limit
        }

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        path_param_keys = ['offering_id']
        path_param_values = self.encode_path_vars(offering_id)
        path_param_dict = dict(zip(path_param_keys, path_param_values))
        url = '/v2/catalog/{offering_id}'.format(**path_param_dict)
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers,
                                       params=params)

        response = self.send(request)
        return response

    #########################
    # util
    #########################


    def list_locations(self,
        **kwargs
    ) -> DetailedResponse:
        """
        List supported locations.

        Retrieve a list of IBM Cloud locations where you can work with the Schematics
        objects.
          <h3>Authorization</h3>
          Schematics support generic authorization for its resources.
          For more information, about Schematics access and permissions,
          see [Schematics service access roles and required
        permissions](https://cloud.ibm.com/docs/schematics?topic=schematics-access#access-roles).

        :param dict headers: A `dict` containing the request headers
        :return: A `DetailedResponse` containing the result, headers and HTTP status code.
        :rtype: DetailedResponse with `dict` result representing a `SchematicsLocationsList` object
        """

        headers = {}
        sdk_headers = get_sdk_headers(service_name=self.DEFAULT_SERVICE_NAME,
                                      service_version='V2',
                                      operation_id='list_locations')
        headers.update(sdk_headers)

        if 'headers' in kwargs:
            headers.update(kwargs.get('headers'))
        headers['Accept'] = 'application/json'

        url = '/v2/locations'
        request = self.prepare_request(method='GET',
                                       url=url,
                                       headers=headers)

        response = self.send(request)
        return response


class ListWorkspacesEnums:
    """
    Enums for list_workspaces parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class GetWorkspaceEnums:
    """
    Enums for get_workspace parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class ListTemplatesInWorkspaceEnums:
    """
    Enums for list_templates_in_workspace parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class GetTemplateInWorkspaceEnums:
    """
    Enums for get_template_in_workspace parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class GetTemplateReadmeEnums:
    """
    Enums for get_template_readme parameters.
    """

    class Accept(str, Enum):
        """
        The type of the response: text/markdown or text/html. A character encoding can be
        specified by including a `charset` parameter. For example,
        'text/markdown;charset=utf-8'.
        """
        TEXT_MARKDOWN = 'text/markdown'
        TEXT_HTML = 'text/html'


class ListFlowsInWorkspaceEnums:
    """
    Enums for list_flows_in_workspace parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class GetFlowInWorkspaceEnums:
    """
    Enums for get_flow_in_workspace parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class ListActionsEnums:
    """
    Enums for list_actions parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class GetActionEnums:
    """
    Enums for get_action parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class ListJobsEnums:
    """
    Enums for list_jobs parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'
    class Resource(str, Enum):
        """
        Name of the resource (workspace, actions or controls).
        """
        WORKSPACE = 'workspace'
        ACTION = 'action'
    class List(str, Enum):
        """
        list jobs.
        """
        ALL = 'all'


class GetJobEnums:
    """
    Enums for get_job parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class GetJobFilesEnums:
    """
    Enums for get_job_files parameters.
    """

    class FileType(str, Enum):
        """
        The type of file you want to download eg.state_file, plan_json.
        """
        STATE_FILE = 'state_file'
        PLAN_JSON = 'plan_json'


class ListControlsEnums:
    """
    Enums for list_controls parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class GetControlsEnums:
    """
    Enums for get_controls parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class ListCapsulesEnums:
    """
    Enums for list_capsules parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class GetCapsuleEnums:
    """
    Enums for get_capsule parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class ListDatasetsEnums:
    """
    Enums for list_datasets parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class ListInventoriesEnums:
    """
    Enums for list_inventories parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class GetInventoryEnums:
    """
    Enums for get_inventory parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class ListResourceQueryEnums:
    """
    Enums for list_resource_query parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class ListAgentEnums:
    """
    Enums for list_agent parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class GetAgentEnums:
    """
    Enums for get_agent parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class ListAdapterEnums:
    """
    Enums for list_adapter parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class GetDataEnums:
    """
    Enums for get_data parameters.
    """

    class Preview(str, Enum):
        """
        Preview the data from the datasource.
        """
        ALL = 'all'
        KEYS = 'keys'


class GetCartOrderEnums:
    """
    Enums for get_cart_order parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        SUMMARY = 'summary'
        DETAILED = 'detailed'
        IDS = 'ids'


class GetBlueprintEnums:
    """
    Enums for get_blueprint parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class ReplaceBlueprintEnums:
    """
    Enums for replace_blueprint parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class DeleteBlueprintEnums:
    """
    Enums for delete_blueprint parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


class UpdateBlueprintEnums:
    """
    Enums for update_blueprint parameters.
    """

    class Profile(str, Enum):
        """
        Level of details returned by the get method.
        """
        IDS = 'ids'
        SUMMARY = 'summary'


##############################################################################
# Models
##############################################################################


class Action():
    """
    Complete Action details with user inputs and system generated data.

    :attr str name: (optional) The unique name of your action. The name can be up to
          128 characters long and can include alphanumeric characters, spaces, dashes, and
          underscores. **Example** you can use the name to stop action.
    :attr str description: (optional) Action description.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str resource_group: (optional) Resource-group name for an action. By
          default, an action is created in `Default` resource group.
    :attr str bastion_connection_type: (optional) Type of connection to be used when
          connecting to bastion host. If the `inventory_connection_type=winrm`, then
          `bastion_connection_type` is not supported.
    :attr str inventory_connection_type: (optional) Type of connection to be used
          when connecting to remote host. **Note** Currently, WinRM supports only Windows
          system with the public IPs and do not support Bastion host.
    :attr List[str] tags: (optional) Action tags.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr str source_readme_url: (optional) URL of the `README` file, for the source
          URL.
    :attr ExternalSource source: (optional) Source of templates, playbooks, or
          controls.
    :attr str source_type: (optional) Type of source for the Template.
    :attr str command_parameter: (optional) Schematics job command parameter
          (playbook-name).
    :attr str inventory: (optional) Target inventory record ID, used by the action
          or ansible playbook.
    :attr List[CredentialVariableData] credentials: (optional) credentials of the
          Action.
    :attr BastionResourceDefinition bastion: (optional) Describes a bastion
          resource.
    :attr CredentialVariableData bastion_credential: (optional) User editable
          credential variable data and system generated reference to the value.
    :attr str targets_ini: (optional) Inventory of host and host group for the
          playbook in `INI` file format. For example, `"targets_ini": "[webserverhost]
          172.22.192.6
           [dbhost]
           172.22.192.5"`. For more information, about an inventory host group syntax, see
          [Inventory host
          groups](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-inventory-host-grps).
    :attr List[VariableData] inputs: (optional) Input variables for the Action.
    :attr List[VariableData] outputs: (optional) Output variables for the Action.
    :attr List[VariableData] settings: (optional) Environment variables for the
          Action.
    :attr str id: (optional) Action ID.
    :attr str crn: (optional) Action Cloud Resource Name.
    :attr str account: (optional) Action account ID.
    :attr datetime source_created_at: (optional) Action Playbook Source creation
          time.
    :attr str source_created_by: (optional) E-mail address of user who created the
          Action Playbook Source.
    :attr datetime source_updated_at: (optional) The action playbook updation time.
    :attr str source_updated_by: (optional) E-mail address of user who updated the
          action playbook source.
    :attr datetime created_at: (optional) Action creation time.
    :attr str created_by: (optional) E-mail address of the user who created an
          action.
    :attr datetime updated_at: (optional) Action updation time.
    :attr str updated_by: (optional) E-mail address of the user who updated an
          action.
    :attr ActionState state: (optional) Computed state of the Action.
    :attr List[str] playbook_names: (optional) Playbook names retrieved from the
          repository.
    :attr SystemLock sys_lock: (optional) System lock status.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'location', 'resource_group', 'bastion_connection_type', 'inventory_connection_type', 'tags', 'user_state', 'source_readme_url', 'source', 'source_type', 'command_parameter', 'inventory', 'credentials', 'bastion', 'bastion_credential', 'targets_ini', 'inputs', 'outputs', 'settings', 'id', 'crn', 'account', 'source_created_at', 'source_created_by', 'source_updated_at', 'source_updated_by', 'created_at', 'created_by', 'updated_at', 'updated_by', 'state', 'playbook_names', 'sys_lock'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 location: str = None,
                 resource_group: str = None,
                 bastion_connection_type: str = None,
                 inventory_connection_type: str = None,
                 tags: List[str] = None,
                 user_state: 'UserState' = None,
                 source_readme_url: str = None,
                 source: 'ExternalSource' = None,
                 source_type: str = None,
                 command_parameter: str = None,
                 inventory: str = None,
                 credentials: List['CredentialVariableData'] = None,
                 bastion: 'BastionResourceDefinition' = None,
                 bastion_credential: 'CredentialVariableData' = None,
                 targets_ini: str = None,
                 inputs: List['VariableData'] = None,
                 outputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 id: str = None,
                 crn: str = None,
                 account: str = None,
                 source_created_at: datetime = None,
                 source_created_by: str = None,
                 source_updated_at: datetime = None,
                 source_updated_by: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 state: 'ActionState' = None,
                 playbook_names: List[str] = None,
                 sys_lock: 'SystemLock' = None,
                 **kwargs) -> None:
        """
        Initialize a Action object.

        :param str name: (optional) The unique name of your action. The name can be
               up to 128 characters long and can include alphanumeric characters, spaces,
               dashes, and underscores. **Example** you can use the name to stop action.
        :param str description: (optional) Action description.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for an action. By
               default, an action is created in `Default` resource group.
        :param str bastion_connection_type: (optional) Type of connection to be
               used when connecting to bastion host. If the
               `inventory_connection_type=winrm`, then `bastion_connection_type` is not
               supported.
        :param str inventory_connection_type: (optional) Type of connection to be
               used when connecting to remote host. **Note** Currently, WinRM supports
               only Windows system with the public IPs and do not support Bastion host.
        :param List[str] tags: (optional) Action tags.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param str source_readme_url: (optional) URL of the `README` file, for the
               source URL.
        :param ExternalSource source: (optional) Source of templates, playbooks, or
               controls.
        :param str source_type: (optional) Type of source for the Template.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name).
        :param str inventory: (optional) Target inventory record ID, used by the
               action or ansible playbook.
        :param List[CredentialVariableData] credentials: (optional) credentials of
               the Action.
        :param BastionResourceDefinition bastion: (optional) Describes a bastion
               resource.
        :param CredentialVariableData bastion_credential: (optional) User editable
               credential variable data and system generated reference to the value.
        :param str targets_ini: (optional) Inventory of host and host group for the
               playbook in `INI` file format. For example, `"targets_ini":
               "[webserverhost] 172.22.192.6
                [dbhost]
                172.22.192.5"`. For more information, about an inventory host group
               syntax, see [Inventory host
               groups](https://cloud.ibm.com/docs/schematics?topic=schematics-schematics-cli-reference#schematics-inventory-host-grps).
        :param List[VariableData] inputs: (optional) Input variables for the
               Action.
        :param List[VariableData] outputs: (optional) Output variables for the
               Action.
        :param List[VariableData] settings: (optional) Environment variables for
               the Action.
        :param ActionState state: (optional) Computed state of the Action.
        :param SystemLock sys_lock: (optional) System lock status.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.location = location
        self.resource_group = resource_group
        self.bastion_connection_type = bastion_connection_type
        self.inventory_connection_type = inventory_connection_type
        self.tags = tags
        self.user_state = user_state
        self.source_readme_url = source_readme_url
        self.source = source
        self.source_type = source_type
        self.command_parameter = command_parameter
        self.inventory = inventory
        self.credentials = credentials
        self.bastion = bastion
        self.bastion_credential = bastion_credential
        self.targets_ini = targets_ini
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.id = id
        self.crn = crn
        self.account = account
        self.source_created_at = source_created_at
        self.source_created_by = source_created_by
        self.source_updated_at = source_updated_at
        self.source_updated_by = source_updated_by
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.state = state
        self.playbook_names = playbook_names
        self.sys_lock = sys_lock
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Action':
        """Initialize a Action object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'bastion_connection_type' in _dict:
            args['bastion_connection_type'] = _dict.get('bastion_connection_type')
        if 'inventory_connection_type' in _dict:
            args['inventory_connection_type'] = _dict.get('inventory_connection_type')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'source_readme_url' in _dict:
            args['source_readme_url'] = _dict.get('source_readme_url')
        if 'source' in _dict:
            args['source'] = ExternalSource.from_dict(_dict.get('source'))
        if 'source_type' in _dict:
            args['source_type'] = _dict.get('source_type')
        if 'command_parameter' in _dict:
            args['command_parameter'] = _dict.get('command_parameter')
        if 'inventory' in _dict:
            args['inventory'] = _dict.get('inventory')
        if 'credentials' in _dict:
            args['credentials'] = [CredentialVariableData.from_dict(x) for x in _dict.get('credentials')]
        if 'bastion' in _dict:
            args['bastion'] = BastionResourceDefinition.from_dict(_dict.get('bastion'))
        if 'bastion_credential' in _dict:
            args['bastion_credential'] = CredentialVariableData.from_dict(_dict.get('bastion_credential'))
        if 'targets_ini' in _dict:
            args['targets_ini'] = _dict.get('targets_ini')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'account' in _dict:
            args['account'] = _dict.get('account')
        if 'source_created_at' in _dict:
            args['source_created_at'] = string_to_datetime(_dict.get('source_created_at'))
        if 'source_created_by' in _dict:
            args['source_created_by'] = _dict.get('source_created_by')
        if 'source_updated_at' in _dict:
            args['source_updated_at'] = string_to_datetime(_dict.get('source_updated_at'))
        if 'source_updated_by' in _dict:
            args['source_updated_by'] = _dict.get('source_updated_by')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'state' in _dict:
            args['state'] = ActionState.from_dict(_dict.get('state'))
        if 'playbook_names' in _dict:
            args['playbook_names'] = _dict.get('playbook_names')
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Action object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'bastion_connection_type') and self.bastion_connection_type is not None:
            _dict['bastion_connection_type'] = self.bastion_connection_type
        if hasattr(self, 'inventory_connection_type') and self.inventory_connection_type is not None:
            _dict['inventory_connection_type'] = self.inventory_connection_type
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'source_readme_url') and self.source_readme_url is not None:
            _dict['source_readme_url'] = self.source_readme_url
        if hasattr(self, 'source') and self.source is not None:
            _dict['source'] = self.source.to_dict()
        if hasattr(self, 'source_type') and self.source_type is not None:
            _dict['source_type'] = self.source_type
        if hasattr(self, 'command_parameter') and self.command_parameter is not None:
            _dict['command_parameter'] = self.command_parameter
        if hasattr(self, 'inventory') and self.inventory is not None:
            _dict['inventory'] = self.inventory
        if hasattr(self, 'credentials') and self.credentials is not None:
            _dict['credentials'] = [x.to_dict() for x in self.credentials]
        if hasattr(self, 'bastion') and self.bastion is not None:
            _dict['bastion'] = self.bastion.to_dict()
        if hasattr(self, 'bastion_credential') and self.bastion_credential is not None:
            _dict['bastion_credential'] = self.bastion_credential.to_dict()
        if hasattr(self, 'targets_ini') and self.targets_ini is not None:
            _dict['targets_ini'] = self.targets_ini
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'source_created_at') and getattr(self, 'source_created_at') is not None:
            _dict['source_created_at'] = datetime_to_string(getattr(self, 'source_created_at'))
        if hasattr(self, 'source_created_by') and getattr(self, 'source_created_by') is not None:
            _dict['source_created_by'] = getattr(self, 'source_created_by')
        if hasattr(self, 'source_updated_at') and getattr(self, 'source_updated_at') is not None:
            _dict['source_updated_at'] = datetime_to_string(getattr(self, 'source_updated_at'))
        if hasattr(self, 'source_updated_by') and getattr(self, 'source_updated_by') is not None:
            _dict['source_updated_by'] = getattr(self, 'source_updated_by')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        if hasattr(self, 'playbook_names') and getattr(self, 'playbook_names') is not None:
            _dict['playbook_names'] = getattr(self, 'playbook_names')
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        for _key in [k for k in vars(self).keys() if k not in Action._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Action object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Action') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Action') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


    class BastionConnectionTypeEnum(str, Enum):
        """
        Type of connection to be used when connecting to bastion host. If the
        `inventory_connection_type=winrm`, then `bastion_connection_type` is not
        supported.
        """
        SSH = 'ssh'


    class InventoryConnectionTypeEnum(str, Enum):
        """
        Type of connection to be used when connecting to remote host. **Note** Currently,
        WinRM supports only Windows system with the public IPs and do not support Bastion
        host.
        """
        SSH = 'ssh'
        WINRM = 'winrm'


    class SourceTypeEnum(str, Enum):
        """
        Type of source for the Template.
        """
        LOCAL = 'local'
        GIT_HUB = 'git_hub'
        GIT_HUB_ENTERPRISE = 'git_hub_enterprise'
        GIT_LAB = 'git_lab'
        IBM_GIT_LAB = 'ibm_git_lab'
        IBM_CLOUD_CATALOG = 'ibm_cloud_catalog'
        EXTERNAL_SCM = 'external_scm'


class ActionList():
    """
    List of Action definition response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[ActionLite] actions: (optional) List of action records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'actions'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 actions: List['ActionLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a ActionList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[ActionLite] actions: (optional) List of action records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.actions = actions
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ActionList':
        """Initialize a ActionList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in ActionList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in ActionList JSON')
        if 'actions' in _dict:
            args['actions'] = [ActionLite.from_dict(x) for x in _dict.get('actions')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ActionList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'actions') and self.actions is not None:
            _dict['actions'] = [x.to_dict() for x in self.actions]
        for _key in [k for k in vars(self).keys() if k not in ActionList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ActionList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ActionList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ActionList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ActionLite():
    """
    Action summary profile with user inputs and system generated data.

    :attr str name: (optional) Action name (unique for an account).
    :attr str description: (optional) Action description.
    :attr str id: (optional) Action Id.
    :attr str crn: (optional) Action Cloud Resource Name.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str resource_group: (optional) Resource-group name for the Action.  By
          default, Action will be created in Default Resource Group.
    :attr str namespace: (optional) name of the namespace.
    :attr List[str] tags: (optional) Action tags.
    :attr str playbook_name: (optional) Name of the selected playbook.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr ActionLiteState state: (optional) Computed state of the Action.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr datetime created_at: (optional) Action creation time.
    :attr str created_by: (optional) Email address of user who created the action.
    :attr datetime updated_at: (optional) Action updation time.
    :attr str updated_by: (optional) Email address of user who updated the action.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'id', 'crn', 'location', 'resource_group', 'namespace', 'tags', 'playbook_name', 'user_state', 'state', 'sys_lock', 'created_at', 'created_by', 'updated_at', 'updated_by'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 id: str = None,
                 crn: str = None,
                 location: str = None,
                 resource_group: str = None,
                 namespace: str = None,
                 tags: List[str] = None,
                 playbook_name: str = None,
                 user_state: 'UserState' = None,
                 state: 'ActionLiteState' = None,
                 sys_lock: 'SystemLock' = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a ActionLite object.

        :param str name: (optional) Action name (unique for an account).
        :param str description: (optional) Action description.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param ActionLiteState state: (optional) Computed state of the Action.
        :param SystemLock sys_lock: (optional) System lock status.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.id = id
        self.crn = crn
        self.location = location
        self.resource_group = resource_group
        self.namespace = namespace
        self.tags = tags
        self.playbook_name = playbook_name
        self.user_state = user_state
        self.state = state
        self.sys_lock = sys_lock
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ActionLite':
        """Initialize a ActionLite object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'namespace' in _dict:
            args['namespace'] = _dict.get('namespace')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'playbook_name' in _dict:
            args['playbook_name'] = _dict.get('playbook_name')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'state' in _dict:
            args['state'] = ActionLiteState.from_dict(_dict.get('state'))
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ActionLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and getattr(self, 'resource_group') is not None:
            _dict['resource_group'] = getattr(self, 'resource_group')
        if hasattr(self, 'namespace') and getattr(self, 'namespace') is not None:
            _dict['namespace'] = getattr(self, 'namespace')
        if hasattr(self, 'tags') and getattr(self, 'tags') is not None:
            _dict['tags'] = getattr(self, 'tags')
        if hasattr(self, 'playbook_name') and getattr(self, 'playbook_name') is not None:
            _dict['playbook_name'] = getattr(self, 'playbook_name')
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        for _key in [k for k in vars(self).keys() if k not in ActionLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ActionLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ActionLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ActionLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class ActionLiteState():
    """
    Computed state of the Action.

    :attr str status_code: (optional) Status of automation (workspace or action).
    :attr str status_message: (optional) Automation status message - to be displayed
          along with the status_code.
    """

    # The set of defined properties for the class
    _properties = frozenset(['status_code', 'status_message'])

    def __init__(self,
                 *,
                 status_code: str = None,
                 status_message: str = None,
                 **kwargs) -> None:
        """
        Initialize a ActionLiteState object.

        :param str status_code: (optional) Status of automation (workspace or
               action).
        :param str status_message: (optional) Automation status message - to be
               displayed along with the status_code.
        :param **kwargs: (optional) Any additional properties.
        """
        self.status_code = status_code
        self.status_message = status_message
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ActionLiteState':
        """Initialize a ActionLiteState object from a json dictionary."""
        args = {}
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ActionLiteState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        for _key in [k for k in vars(self).keys() if k not in ActionLiteState._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ActionLiteState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ActionLiteState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ActionLiteState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of automation (workspace or action).
        """
        NORMAL = 'normal'
        PENDING = 'pending'
        DISABLED = 'disabled'
        CRITICAL = 'critical'


class ActionState():
    """
    Computed state of the Action.

    :attr str status_code: (optional) Status of automation (workspace or action).
    :attr str status_job_id: (optional) Job id reference for this status.
    :attr str status_message: (optional) Automation status message - to be displayed
          along with the status_code.
    """

    # The set of defined properties for the class
    _properties = frozenset(['status_code', 'status_job_id', 'status_message'])

    def __init__(self,
                 *,
                 status_code: str = None,
                 status_job_id: str = None,
                 status_message: str = None,
                 **kwargs) -> None:
        """
        Initialize a ActionState object.

        :param str status_code: (optional) Status of automation (workspace or
               action).
        :param str status_job_id: (optional) Job id reference for this status.
        :param str status_message: (optional) Automation status message - to be
               displayed along with the status_code.
        :param **kwargs: (optional) Any additional properties.
        """
        self.status_code = status_code
        self.status_job_id = status_job_id
        self.status_message = status_message
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ActionState':
        """Initialize a ActionState object from a json dictionary."""
        args = {}
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_job_id' in _dict:
            args['status_job_id'] = _dict.get('status_job_id')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ActionState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_job_id') and self.status_job_id is not None:
            _dict['status_job_id'] = self.status_job_id
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        for _key in [k for k in vars(self).keys() if k not in ActionState._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ActionState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ActionState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ActionState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of automation (workspace or action).
        """
        NORMAL = 'normal'
        PENDING = 'pending'
        DISABLED = 'disabled'
        CRITICAL = 'critical'


class Adapter():
    """
    Complete Schematics Adapter details provided by user and system generated.

    :attr str adapter_name: (optional) Name of the Adapter.
    :attr str adapter_type: (optional) Type of external schematics adapters.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str resource_group: (optional) Resource-group id for the Adapter.
    :attr List[str] tags: (optional) Adapter tags.
    :attr str adapter_endpoint_url: (optional) Endpoint URL for the Adapter.
    :attr str service_id: (optional) Service-ID to connect to the Adapter; if this
          is not provided, Schematics will used the IAM token of the user to connect to
          the Adapter.
    :attr str apikey: (optional) API Key for the Service ID.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr bool ignore_inflight_operations: (optional) True - Replace the Adapter
          definition, without waiting for completion of all inflight Schematics
          operations; False -  Block all new Schematics operations in the Account, and
          wait for inflight operations to complete - before changing the Adapter
          definition.
    :attr str adapter_id: (optional) Id of the Adapter.
    :attr str registered_by: (optional) Name of the user who registered the Adapter.
    :attr datetime registered_at: (optional) Timestamp of Adapter registration.
    :attr datetime updated_at: (optional) Adapter updation time.
    :attr str updated_by: (optional) Name of user who updated the Adapter
          definition.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr str adapter_health: (optional) Health of the adapter.
    :attr datetime last_health_checked_at: (optional) Timestamp of the last health
          check.
    """

    # The set of defined properties for the class
    _properties = frozenset(['adapter_name', 'adapter_type', 'location', 'resource_group', 'tags', 'adapter_endpoint_url', 'service_id', 'apikey', 'user_state', 'ignore_inflight_operations', 'adapter_id', 'registered_by', 'registered_at', 'updated_at', 'updated_by', 'sys_lock', 'adapter_health', 'last_health_checked_at'])

    def __init__(self,
                 *,
                 adapter_name: str = None,
                 adapter_type: str = None,
                 location: str = None,
                 resource_group: str = None,
                 tags: List[str] = None,
                 adapter_endpoint_url: str = None,
                 service_id: str = None,
                 apikey: str = None,
                 user_state: 'UserState' = None,
                 ignore_inflight_operations: bool = None,
                 adapter_id: str = None,
                 registered_by: str = None,
                 registered_at: datetime = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 sys_lock: 'SystemLock' = None,
                 adapter_health: str = None,
                 last_health_checked_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a Adapter object.

        :param str adapter_name: (optional) Name of the Adapter.
        :param str adapter_type: (optional) Type of external schematics adapters.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group id for the Adapter.
        :param List[str] tags: (optional) Adapter tags.
        :param str adapter_endpoint_url: (optional) Endpoint URL for the Adapter.
        :param str service_id: (optional) Service-ID to connect to the Adapter; if
               this is not provided, Schematics will used the IAM token of the user to
               connect to the Adapter.
        :param str apikey: (optional) API Key for the Service ID.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param bool ignore_inflight_operations: (optional) True - Replace the
               Adapter definition, without waiting for completion of all inflight
               Schematics operations; False -  Block all new Schematics operations in the
               Account, and wait for inflight operations to complete - before changing the
               Adapter definition.
        :param str adapter_id: (optional) Id of the Adapter.
        :param str registered_by: (optional) Name of the user who registered the
               Adapter.
        :param datetime registered_at: (optional) Timestamp of Adapter
               registration.
        :param datetime updated_at: (optional) Adapter updation time.
        :param str updated_by: (optional) Name of user who updated the Adapter
               definition.
        :param SystemLock sys_lock: (optional) System lock status.
        :param str adapter_health: (optional) Health of the adapter.
        :param datetime last_health_checked_at: (optional) Timestamp of the last
               health check.
        :param **kwargs: (optional) Any additional properties.
        """
        self.adapter_name = adapter_name
        self.adapter_type = adapter_type
        self.location = location
        self.resource_group = resource_group
        self.tags = tags
        self.adapter_endpoint_url = adapter_endpoint_url
        self.service_id = service_id
        self.apikey = apikey
        self.user_state = user_state
        self.ignore_inflight_operations = ignore_inflight_operations
        self.adapter_id = adapter_id
        self.registered_by = registered_by
        self.registered_at = registered_at
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.sys_lock = sys_lock
        self.adapter_health = adapter_health
        self.last_health_checked_at = last_health_checked_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Adapter':
        """Initialize a Adapter object from a json dictionary."""
        args = {}
        if 'adapter_name' in _dict:
            args['adapter_name'] = _dict.get('adapter_name')
        if 'adapter_type' in _dict:
            args['adapter_type'] = _dict.get('adapter_type')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'adapter_endpoint_url' in _dict:
            args['adapter_endpoint_url'] = _dict.get('adapter_endpoint_url')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        if 'apikey' in _dict:
            args['apikey'] = _dict.get('apikey')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'ignore_inflight_operations' in _dict:
            args['ignore_inflight_operations'] = _dict.get('ignore_inflight_operations')
        if 'adapter_id' in _dict:
            args['adapter_id'] = _dict.get('adapter_id')
        if 'registered_by' in _dict:
            args['registered_by'] = _dict.get('registered_by')
        if 'registered_at' in _dict:
            args['registered_at'] = string_to_datetime(_dict.get('registered_at'))
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'adapter_health' in _dict:
            args['adapter_health'] = _dict.get('adapter_health')
        if 'last_health_checked_at' in _dict:
            args['last_health_checked_at'] = string_to_datetime(_dict.get('last_health_checked_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Adapter object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'adapter_name') and self.adapter_name is not None:
            _dict['adapter_name'] = self.adapter_name
        if hasattr(self, 'adapter_type') and self.adapter_type is not None:
            _dict['adapter_type'] = self.adapter_type
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'adapter_endpoint_url') and self.adapter_endpoint_url is not None:
            _dict['adapter_endpoint_url'] = self.adapter_endpoint_url
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        if hasattr(self, 'apikey') and self.apikey is not None:
            _dict['apikey'] = self.apikey
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'ignore_inflight_operations') and self.ignore_inflight_operations is not None:
            _dict['ignore_inflight_operations'] = self.ignore_inflight_operations
        if hasattr(self, 'adapter_id') and self.adapter_id is not None:
            _dict['adapter_id'] = self.adapter_id
        if hasattr(self, 'registered_by') and self.registered_by is not None:
            _dict['registered_by'] = self.registered_by
        if hasattr(self, 'registered_at') and self.registered_at is not None:
            _dict['registered_at'] = datetime_to_string(self.registered_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'updated_by') and self.updated_by is not None:
            _dict['updated_by'] = self.updated_by
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'adapter_health') and self.adapter_health is not None:
            _dict['adapter_health'] = self.adapter_health
        if hasattr(self, 'last_health_checked_at') and self.last_health_checked_at is not None:
            _dict['last_health_checked_at'] = datetime_to_string(self.last_health_checked_at)
        for _key in [k for k in vars(self).keys() if k not in Adapter._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Adapter object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Adapter') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Adapter') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class AdapterTypeEnum(str, Enum):
        """
        Type of external schematics adapters.
        """
        SCM_ADAPTER = 'scm_adapter'
        VAULT_ADAPTER = 'vault_adapter'
        CATALOG_ADAPTER = 'catalog_adapter'
        WORKSPACE_DATA_ADAPTER = 'workspace_data_adapter'
        PROVISIONER_ADAPTER = 'provisioner_adapter'
        POLICY_AGENT_ADAPTER = 'policy_agent_adapter'


    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


    class AdapterHealthEnum(str, Enum):
        """
        Health of the adapter.
        """
        ACTIVE = 'active'
        INACTIVE = 'inactive'


class AdapterList():
    """
    List of schematics adapter details.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[Adapter] adapters: (optional) List of external schematics adapters.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'adapters'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 adapters: List['Adapter'] = None,
                 **kwargs) -> None:
        """
        Initialize a AdapterList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[Adapter] adapters: (optional) List of external schematics
               adapters.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.adapters = adapters
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AdapterList':
        """Initialize a AdapterList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in AdapterList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in AdapterList JSON')
        if 'adapters' in _dict:
            args['adapters'] = [Adapter.from_dict(x) for x in _dict.get('adapters')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AdapterList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'adapters') and self.adapters is not None:
            _dict['adapters'] = [x.to_dict() for x in self.adapters]
        for _key in [k for k in vars(self).keys() if k not in AdapterList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AdapterList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AdapterList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AdapterList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class Agent():
    """
    Agent registration details, with user inputs and system generated data.

    :attr str name: Name of the agent (must be unique, for an account).
    :attr str description: (optional) Agent description.
    :attr str resource_group: (optional) Resource-group name for the agent.  By
          default, Agent will be registered in Default Resource Group.
    :attr List[str] tags: (optional) Tags for the agent.
    :attr str location: (optional) User defined location of the Agent.
    :attr str profile_id: IAM trusted profile id, used by the Agent instance.
    :attr str agent_id: Agent id, obtained from the Schematics Agent deployment
          configuration.
    :attr str crn: (optional) Agent CRN.
    :attr str account: (optional) Account id.
    :attr str id: (optional) Agent registration id.
    :attr datetime registered_at: (optional) Agent registration date-time.
    :attr str registered_by: (optional) Email address of user who registered the
          Agent.
    :attr datetime updated_at: (optional) Agent registration updation time.
    :attr str updated_by: (optional) Email address of user who updated the Agent
          registration.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr AgentHealth agent_health: (optional) Health check details of the agent.
    :attr AgentSystemState system_state: (optional) Computed state of the agent.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'resource_group', 'tags', 'location', 'profile_id', 'agent_id', 'crn', 'account', 'id', 'registered_at', 'registered_by', 'updated_at', 'updated_by', 'user_state', 'agent_health', 'system_state'])

    def __init__(self,
                 name: str,
                 profile_id: str,
                 agent_id: str,
                 *,
                 description: str = None,
                 resource_group: str = None,
                 tags: List[str] = None,
                 location: str = None,
                 crn: str = None,
                 account: str = None,
                 id: str = None,
                 registered_at: datetime = None,
                 registered_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 user_state: 'UserState' = None,
                 agent_health: 'AgentHealth' = None,
                 system_state: 'AgentSystemState' = None,
                 **kwargs) -> None:
        """
        Initialize a Agent object.

        :param str name: Name of the agent (must be unique, for an account).
        :param str profile_id: IAM trusted profile id, used by the Agent instance.
        :param str agent_id: Agent id, obtained from the Schematics Agent
               deployment configuration.
        :param str description: (optional) Agent description.
        :param str resource_group: (optional) Resource-group name for the agent.
               By default, Agent will be registered in Default Resource Group.
        :param List[str] tags: (optional) Tags for the agent.
        :param str location: (optional) User defined location of the Agent.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param AgentHealth agent_health: (optional) Health check details of the
               agent.
        :param AgentSystemState system_state: (optional) Computed state of the
               agent.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.resource_group = resource_group
        self.tags = tags
        self.location = location
        self.profile_id = profile_id
        self.agent_id = agent_id
        self.crn = crn
        self.account = account
        self.id = id
        self.registered_at = registered_at
        self.registered_by = registered_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.user_state = user_state
        self.agent_health = agent_health
        self.system_state = system_state
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Agent':
        """Initialize a Agent object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in Agent JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'profile_id' in _dict:
            args['profile_id'] = _dict.get('profile_id')
        else:
            raise ValueError('Required property \'profile_id\' not present in Agent JSON')
        if 'agent_id' in _dict:
            args['agent_id'] = _dict.get('agent_id')
        else:
            raise ValueError('Required property \'agent_id\' not present in Agent JSON')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'account' in _dict:
            args['account'] = _dict.get('account')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'registered_at' in _dict:
            args['registered_at'] = string_to_datetime(_dict.get('registered_at'))
        if 'registered_by' in _dict:
            args['registered_by'] = _dict.get('registered_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'agent_health' in _dict:
            args['agent_health'] = AgentHealth.from_dict(_dict.get('agent_health'))
        if 'system_state' in _dict:
            args['system_state'] = AgentSystemState.from_dict(_dict.get('system_state'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Agent object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'profile_id') and self.profile_id is not None:
            _dict['profile_id'] = self.profile_id
        if hasattr(self, 'agent_id') and self.agent_id is not None:
            _dict['agent_id'] = self.agent_id
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'registered_at') and getattr(self, 'registered_at') is not None:
            _dict['registered_at'] = datetime_to_string(getattr(self, 'registered_at'))
        if hasattr(self, 'registered_by') and getattr(self, 'registered_by') is not None:
            _dict['registered_by'] = getattr(self, 'registered_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'agent_health') and self.agent_health is not None:
            _dict['agent_health'] = self.agent_health.to_dict()
        if hasattr(self, 'system_state') and self.system_state is not None:
            _dict['system_state'] = self.system_state.to_dict()
        for _key in [k for k in vars(self).keys() if k not in Agent._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Agent object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Agent') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Agent') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class AgentHealth():
    """
    Health check details of the agent.

    :attr str state: (optional) User-defined states
            * `Connected` When Schematics is able to connect to the agent.
            * `Disconnected` When Schematics is able not connect to the agent.
    :attr datetime checked_at: (optional) When the health check is performed.
    """

    # The set of defined properties for the class
    _properties = frozenset(['state', 'checked_at'])

    def __init__(self,
                 *,
                 state: str = None,
                 checked_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a AgentHealth object.

        :param str state: (optional) User-defined states
                 * `Connected` When Schematics is able to connect to the agent.
                 * `Disconnected` When Schematics is able not connect to the agent.
        :param datetime checked_at: (optional) When the health check is performed.
        :param **kwargs: (optional) Any additional properties.
        """
        self.state = state
        self.checked_at = checked_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentHealth':
        """Initialize a AgentHealth object from a json dictionary."""
        args = {}
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'checked_at' in _dict:
            args['checked_at'] = string_to_datetime(_dict.get('checked_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentHealth object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state
        if hasattr(self, 'checked_at') and self.checked_at is not None:
            _dict['checked_at'] = datetime_to_string(self.checked_at)
        for _key in [k for k in vars(self).keys() if k not in AgentHealth._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentHealth object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentHealth') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentHealth') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StateEnum(str, Enum):
        """
        User-defined states
          * `Connected` When Schematics is able to connect to the agent.
          * `Disconnected` When Schematics is able not connect to the agent.
        """
        CONNECTED = 'Connected'
        DISCONNECTED = 'Disconnected'


class AgentList():
    """
    List of agent.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[Agent] agents: (optional) List of agent in the account.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'agents'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 agents: List['Agent'] = None,
                 **kwargs) -> None:
        """
        Initialize a AgentList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param List[Agent] agents: (optional) List of agent in the account.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.agents = agents
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentList':
        """Initialize a AgentList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in AgentList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in AgentList JSON')
        if 'agents' in _dict:
            args['agents'] = [Agent.from_dict(x) for x in _dict.get('agents')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and getattr(self, 'total_count') is not None:
            _dict['total_count'] = getattr(self, 'total_count')
        if hasattr(self, 'limit') and getattr(self, 'limit') is not None:
            _dict['limit'] = getattr(self, 'limit')
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'agents') and self.agents is not None:
            _dict['agents'] = [x.to_dict() for x in self.agents]
        for _key in [k for k in vars(self).keys() if k not in AgentList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class AgentSystemState():
    """
    Computed state of the agent.

    :attr str state: (optional) Status of while registering the agent.
    :attr str message: (optional) Agent status message.
    """

    # The set of defined properties for the class
    _properties = frozenset(['state', 'message'])

    def __init__(self,
                 *,
                 state: str = None,
                 message: str = None,
                 **kwargs) -> None:
        """
        Initialize a AgentSystemState object.

        :param str state: (optional) Status of while registering the agent.
        :param str message: (optional) Agent status message.
        :param **kwargs: (optional) Any additional properties.
        """
        self.state = state
        self.message = message
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'AgentSystemState':
        """Initialize a AgentSystemState object from a json dictionary."""
        args = {}
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'message' in _dict:
            args['message'] = _dict.get('message')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a AgentSystemState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state
        if hasattr(self, 'message') and self.message is not None:
            _dict['message'] = self.message
        for _key in [k for k in vars(self).keys() if k not in AgentSystemState._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this AgentSystemState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'AgentSystemState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'AgentSystemState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StateEnum(str, Enum):
        """
        Status of while registering the agent.
        """
        ERROR = 'error'
        ACTIVE = 'active'


class BastionResourceDefinition():
    """
    Describes a bastion resource.

    :attr str name: (optional) Bastion Name(Unique).
    :attr str host: (optional) Reference to the Inventory resource definition.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'host'])

    def __init__(self,
                 *,
                 name: str = None,
                 host: str = None,
                 **kwargs) -> None:
        """
        Initialize a BastionResourceDefinition object.

        :param str name: (optional) Bastion Name(Unique).
        :param str host: (optional) Reference to the Inventory resource definition.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.host = host
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BastionResourceDefinition':
        """Initialize a BastionResourceDefinition object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'host' in _dict:
            args['host'] = _dict.get('host')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BastionResourceDefinition object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'host') and self.host is not None:
            _dict['host'] = self.host
        for _key in [k for k in vars(self).keys() if k not in BastionResourceDefinition._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BastionResourceDefinition object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BastionResourceDefinition') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BastionResourceDefinition') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class Blueprint():
    """
    Blueprint details with user inputs and system generated data.

    :attr str name: Blueprint name (unique for an account).
    :attr str schema_version: (optional) Schema version.
    :attr ExternalSource source: (optional) Source of templates, playbooks, or
          controls.
    :attr List[BlueprintConfigItem] config: (optional) Blueprint input configuration
          definition.
    :attr str description: (optional) Blueprint description.
    :attr str resource_group: (optional) Resource-group name for the Blueprint.  By
          default, Blueprint will be created in Default Resource Group.
    :attr List[str] tags: (optional) Blueprint instance tags.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr List[VariableData] inputs: (optional) Additional inputs configuration for
          the blueprint.
    :attr List[VariableData] settings: (optional) Input environemnt settings for
          blueprint.
    :attr List[VariableData] outputs: (optional) Output variables for the blueprint.
    :attr List[BlueprintComponent] components: (optional) Components of the
          blueprint.
    :attr BlueprintFlow flow: (optional) Flow definitions for all the Blueprint
          command.
    :attr str blueprint_id: (optional) System generated Blueprint Id.
    :attr str crn: (optional) Blueprint CRN.
    :attr str account: (optional) Account id.
    :attr datetime created_at: (optional) Blueprint creation time.
    :attr str created_by: (optional) User who created the Blueprint.
    :attr datetime updated_at: (optional) Blueprint updation time.
    :attr str updated_by: (optional) User who updated the Blueprint.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr BlueprintLiteState state: (optional) Computed state of the Blueprint.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'schema_version', 'source', 'config', 'description', 'resource_group', 'tags', 'location', 'inputs', 'settings', 'outputs', 'components', 'flow', 'blueprint_id', 'crn', 'account', 'created_at', 'created_by', 'updated_at', 'updated_by', 'sys_lock', 'user_state', 'state'])

    def __init__(self,
                 name: str,
                 *,
                 schema_version: str = None,
                 source: 'ExternalSource' = None,
                 config: List['BlueprintConfigItem'] = None,
                 description: str = None,
                 resource_group: str = None,
                 tags: List[str] = None,
                 location: str = None,
                 inputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 outputs: List['VariableData'] = None,
                 components: List['BlueprintComponent'] = None,
                 flow: 'BlueprintFlow' = None,
                 blueprint_id: str = None,
                 crn: str = None,
                 account: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 sys_lock: 'SystemLock' = None,
                 user_state: 'UserState' = None,
                 state: 'BlueprintLiteState' = None,
                 **kwargs) -> None:
        """
        Initialize a Blueprint object.

        :param str name: Blueprint name (unique for an account).
        :param str schema_version: (optional) Schema version.
        :param ExternalSource source: (optional) Source of templates, playbooks, or
               controls.
        :param List[BlueprintConfigItem] config: (optional) Blueprint input
               configuration definition.
        :param str description: (optional) Blueprint description.
        :param str resource_group: (optional) Resource-group name for the
               Blueprint.  By default, Blueprint will be created in Default Resource
               Group.
        :param List[str] tags: (optional) Blueprint instance tags.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param List[VariableData] inputs: (optional) Additional inputs
               configuration for the blueprint.
        :param List[VariableData] settings: (optional) Input environemnt settings
               for blueprint.
        :param BlueprintFlow flow: (optional) Flow definitions for all the
               Blueprint command.
        :param SystemLock sys_lock: (optional) System lock status.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param BlueprintLiteState state: (optional) Computed state of the
               Blueprint.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.schema_version = schema_version
        self.source = source
        self.config = config
        self.description = description
        self.resource_group = resource_group
        self.tags = tags
        self.location = location
        self.inputs = inputs
        self.settings = settings
        self.outputs = outputs
        self.components = components
        self.flow = flow
        self.blueprint_id = blueprint_id
        self.crn = crn
        self.account = account
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.sys_lock = sys_lock
        self.user_state = user_state
        self.state = state
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Blueprint':
        """Initialize a Blueprint object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in Blueprint JSON')
        if 'schema_version' in _dict:
            args['schema_version'] = _dict.get('schema_version')
        if 'source' in _dict:
            args['source'] = ExternalSource.from_dict(_dict.get('source'))
        if 'config' in _dict:
            args['config'] = [BlueprintConfigItem.from_dict(x) for x in _dict.get('config')]
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        if 'components' in _dict:
            args['components'] = [BlueprintComponent.from_dict(x) for x in _dict.get('components')]
        if 'flow' in _dict:
            args['flow'] = BlueprintFlow.from_dict(_dict.get('flow'))
        if 'blueprint_id' in _dict:
            args['blueprint_id'] = _dict.get('blueprint_id')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'account' in _dict:
            args['account'] = _dict.get('account')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'state' in _dict:
            args['state'] = BlueprintLiteState.from_dict(_dict.get('state'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Blueprint object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'schema_version') and self.schema_version is not None:
            _dict['schema_version'] = self.schema_version
        if hasattr(self, 'source') and self.source is not None:
            _dict['source'] = self.source.to_dict()
        if hasattr(self, 'config') and self.config is not None:
            _dict['config'] = [x.to_dict() for x in self.config]
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'outputs') and getattr(self, 'outputs') is not None:
            _dict['outputs'] = [x.to_dict() for x in getattr(self, 'outputs')]
        if hasattr(self, 'components') and getattr(self, 'components') is not None:
            _dict['components'] = [x.to_dict() for x in getattr(self, 'components')]
        if hasattr(self, 'flow') and self.flow is not None:
            _dict['flow'] = self.flow.to_dict()
        if hasattr(self, 'blueprint_id') and getattr(self, 'blueprint_id') is not None:
            _dict['blueprint_id'] = getattr(self, 'blueprint_id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        for _key in [k for k in vars(self).keys() if k not in Blueprint._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Blueprint object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Blueprint') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Blueprint') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class BlueprintComponent():
    """
    Component for the Blueprint.

    :attr str component_id: (optional) Component id.
    :attr str component_type: (optional) Name of the Schematics automation resource.
    :attr str name: (optional) Name of the component.
    :attr str layer: (optional) Layer for the component.
    :attr ExternalSource source: (optional) Source of templates, playbooks, or
          controls.
    :attr List[InjectTerraformTemplateInner] injectors: (optional) Array of
          injectable terraform blocks.
    :attr str tags: (optional) Tags used by the component.
    :attr List[BlueprintVariableData] inputs: (optional) Inputs used by the
          component.
    :attr List[BlueprintVariableData] settings: (optional) Environment settings for
          the component.
    :attr List[BlueprintVariableData] outputs: (optional) Outputs from the
          component.
    :attr BlueprintComponentLastJob last_job: (optional) Status of the last job
          executed by the component.
    """

    # The set of defined properties for the class
    _properties = frozenset(['component_id', 'component_type', 'name', 'layer', 'source', 'injectors', 'tags', 'inputs', 'settings', 'outputs', 'last_job'])

    def __init__(self,
                 *,
                 component_id: str = None,
                 component_type: str = None,
                 name: str = None,
                 layer: str = None,
                 source: 'ExternalSource' = None,
                 injectors: List['InjectTerraformTemplateInner'] = None,
                 tags: str = None,
                 inputs: List['BlueprintVariableData'] = None,
                 settings: List['BlueprintVariableData'] = None,
                 outputs: List['BlueprintVariableData'] = None,
                 last_job: 'BlueprintComponentLastJob' = None,
                 **kwargs) -> None:
        """
        Initialize a BlueprintComponent object.

        :param str component_type: (optional) Name of the Schematics automation
               resource.
        :param ExternalSource source: (optional) Source of templates, playbooks, or
               controls.
        :param List[InjectTerraformTemplateInner] injectors: (optional) Array of
               injectable terraform blocks.
        :param BlueprintComponentLastJob last_job: (optional) Status of the last
               job executed by the component.
        :param **kwargs: (optional) Any additional properties.
        """
        self.component_id = component_id
        self.component_type = component_type
        self.name = name
        self.layer = layer
        self.source = source
        self.injectors = injectors
        self.tags = tags
        self.inputs = inputs
        self.settings = settings
        self.outputs = outputs
        self.last_job = last_job
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BlueprintComponent':
        """Initialize a BlueprintComponent object from a json dictionary."""
        args = {}
        if 'component_id' in _dict:
            args['component_id'] = _dict.get('component_id')
        if 'component_type' in _dict:
            args['component_type'] = _dict.get('component_type')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'layer' in _dict:
            args['layer'] = _dict.get('layer')
        if 'source' in _dict:
            args['source'] = ExternalSource.from_dict(_dict.get('source'))
        if 'injectors' in _dict:
            args['injectors'] = [InjectTerraformTemplateInner.from_dict(x) for x in _dict.get('injectors')]
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'inputs' in _dict:
            args['inputs'] = [BlueprintVariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'settings' in _dict:
            args['settings'] = [BlueprintVariableData.from_dict(x) for x in _dict.get('settings')]
        if 'outputs' in _dict:
            args['outputs'] = [BlueprintVariableData.from_dict(x) for x in _dict.get('outputs')]
        if 'last_job' in _dict:
            args['last_job'] = BlueprintComponentLastJob.from_dict(_dict.get('last_job'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BlueprintComponent object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'component_id') and getattr(self, 'component_id') is not None:
            _dict['component_id'] = getattr(self, 'component_id')
        if hasattr(self, 'component_type') and self.component_type is not None:
            _dict['component_type'] = self.component_type
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'layer') and getattr(self, 'layer') is not None:
            _dict['layer'] = getattr(self, 'layer')
        if hasattr(self, 'source') and self.source is not None:
            _dict['source'] = self.source.to_dict()
        if hasattr(self, 'injectors') and self.injectors is not None:
            _dict['injectors'] = [x.to_dict() for x in self.injectors]
        if hasattr(self, 'tags') and getattr(self, 'tags') is not None:
            _dict['tags'] = getattr(self, 'tags')
        if hasattr(self, 'inputs') and getattr(self, 'inputs') is not None:
            _dict['inputs'] = [x.to_dict() for x in getattr(self, 'inputs')]
        if hasattr(self, 'settings') and getattr(self, 'settings') is not None:
            _dict['settings'] = [x.to_dict() for x in getattr(self, 'settings')]
        if hasattr(self, 'outputs') and getattr(self, 'outputs') is not None:
            _dict['outputs'] = [x.to_dict() for x in getattr(self, 'outputs')]
        if hasattr(self, 'last_job') and self.last_job is not None:
            _dict['last_job'] = self.last_job.to_dict()
        for _key in [k for k in vars(self).keys() if k not in BlueprintComponent._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BlueprintComponent object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BlueprintComponent') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BlueprintComponent') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ComponentTypeEnum(str, Enum):
        """
        Name of the Schematics automation resource.
        """
        WORKSPACE = 'workspace'
        ACTION = 'action'
        SYSTEM = 'system'
        ENVIRONMENT = 'environment'


class BlueprintComponentLastJob():
    """
    Status of the last job executed by the component.

    :attr str command_object: (optional) Name of the Schematics automation resource.
    :attr str command_object_name: (optional) Name of the command object id, maps to
          workspace_name or action_name.
    :attr str command_object_id: (optional) Component command object id, maps to
          workspace_id or action_id.
    :attr str command_name: (optional) Schematics job command name.
    :attr str job_status: (optional) Status of Jobs.
    """

    # The set of defined properties for the class
    _properties = frozenset(['command_object', 'command_object_name', 'command_object_id', 'command_name', 'job_status'])

    def __init__(self,
                 *,
                 command_object: str = None,
                 command_object_name: str = None,
                 command_object_id: str = None,
                 command_name: str = None,
                 job_status: str = None,
                 **kwargs) -> None:
        """
        Initialize a BlueprintComponentLastJob object.

        :param str command_object: (optional) Name of the Schematics automation
               resource.
        :param str command_object_name: (optional) Name of the command object id,
               maps to workspace_name or action_name.
        :param str command_object_id: (optional) Component command object id, maps
               to workspace_id or action_id.
        :param str command_name: (optional) Schematics job command name.
        :param str job_status: (optional) Status of Jobs.
        :param **kwargs: (optional) Any additional properties.
        """
        self.command_object = command_object
        self.command_object_name = command_object_name
        self.command_object_id = command_object_id
        self.command_name = command_name
        self.job_status = job_status
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BlueprintComponentLastJob':
        """Initialize a BlueprintComponentLastJob object from a json dictionary."""
        args = {}
        if 'command_object' in _dict:
            args['command_object'] = _dict.get('command_object')
        if 'command_object_name' in _dict:
            args['command_object_name'] = _dict.get('command_object_name')
        if 'command_object_id' in _dict:
            args['command_object_id'] = _dict.get('command_object_id')
        if 'command_name' in _dict:
            args['command_name'] = _dict.get('command_name')
        if 'job_status' in _dict:
            args['job_status'] = _dict.get('job_status')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BlueprintComponentLastJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command_object') and self.command_object is not None:
            _dict['command_object'] = self.command_object
        if hasattr(self, 'command_object_name') and self.command_object_name is not None:
            _dict['command_object_name'] = self.command_object_name
        if hasattr(self, 'command_object_id') and self.command_object_id is not None:
            _dict['command_object_id'] = self.command_object_id
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'job_status') and self.job_status is not None:
            _dict['job_status'] = self.job_status
        for _key in [k for k in vars(self).keys() if k not in BlueprintComponentLastJob._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BlueprintComponentLastJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BlueprintComponentLastJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BlueprintComponentLastJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class CommandObjectEnum(str, Enum):
        """
        Name of the Schematics automation resource.
        """
        WORKSPACE = 'workspace'
        ACTION = 'action'
        SYSTEM = 'system'
        ENVIRONMENT = 'environment'


    class CommandNameEnum(str, Enum):
        """
        Schematics job command name.
        """
        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        CREATE_ENVIRONMENT = 'create_environment'
        PUT_ENVIRONMENT = 'put_environment'
        DELETE_ENVIRONMENT = 'delete_environment'
        ENVIRONMENT_INIT = 'environment_init'
        ENVIRONMENT_INSTALL = 'environment_install'
        ENVIRONMENT_UNINSTALL = 'environment_uninstall'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'


    class JobStatusEnum(str, Enum):
        """
        Status of Jobs.
        """
        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'


class BlueprintConfigItem():
    """
    Blueprint configuration item.

    :attr str name: (optional) Name of the blueprint configuration item.
    :attr str description: (optional) Description for the blueprint configuration
          item.
    :attr ExternalSource source: (optional) Source of templates, playbooks, or
          controls.
    :attr List[BlueprintVariableData] inputs: (optional) Input variables and values
          for the blueprint configuration item.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'source', 'inputs'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 source: 'ExternalSource' = None,
                 inputs: List['BlueprintVariableData'] = None,
                 **kwargs) -> None:
        """
        Initialize a BlueprintConfigItem object.

        :param str name: (optional) Name of the blueprint configuration item.
        :param str description: (optional) Description for the blueprint
               configuration item.
        :param ExternalSource source: (optional) Source of templates, playbooks, or
               controls.
        :param List[BlueprintVariableData] inputs: (optional) Input variables and
               values for the blueprint configuration item.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.source = source
        self.inputs = inputs
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BlueprintConfigItem':
        """Initialize a BlueprintConfigItem object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'source' in _dict:
            args['source'] = ExternalSource.from_dict(_dict.get('source'))
        if 'inputs' in _dict:
            args['inputs'] = [BlueprintVariableData.from_dict(x) for x in _dict.get('inputs')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BlueprintConfigItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'source') and self.source is not None:
            _dict['source'] = self.source.to_dict()
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        for _key in [k for k in vars(self).keys() if k not in BlueprintConfigItem._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BlueprintConfigItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BlueprintConfigItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BlueprintConfigItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class BlueprintFlow():
    """
    Flow definitions for all the Blueprint command.

    :attr List[BlueprintFlowSpecs] specs: (optional) Blueprint flow specification.
    """

    # The set of defined properties for the class
    _properties = frozenset(['specs'])

    def __init__(self,
                 *,
                 specs: List['BlueprintFlowSpecs'] = None,
                 **kwargs) -> None:
        """
        Initialize a BlueprintFlow object.

        :param **kwargs: (optional) Any additional properties.
        """
        self.specs = specs
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BlueprintFlow':
        """Initialize a BlueprintFlow object from a json dictionary."""
        args = {}
        if 'specs' in _dict:
            args['specs'] = [BlueprintFlowSpecs.from_dict(x) for x in _dict.get('specs')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BlueprintFlow object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'specs') and getattr(self, 'specs') is not None:
            _dict['specs'] = [x.to_dict() for x in getattr(self, 'specs')]
        for _key in [k for k in vars(self).keys() if k not in BlueprintFlow._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BlueprintFlow object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BlueprintFlow') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BlueprintFlow') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class BlueprintFlowSequenceFlow():
    """
    BlueprintFlowSequenceFlow.

    :attr int sequence_number: (optional) Sequence number in the order or execution.
    :attr str item_name: (optional) Name of the layer or component to run this
          command.
    """

    # The set of defined properties for the class
    _properties = frozenset(['sequence_number', 'item_name'])

    def __init__(self,
                 *,
                 sequence_number: int = None,
                 item_name: str = None,
                 **kwargs) -> None:
        """
        Initialize a BlueprintFlowSequenceFlow object.

        :param int sequence_number: (optional) Sequence number in the order or
               execution.
        :param str item_name: (optional) Name of the layer or component to run this
               command.
        :param **kwargs: (optional) Any additional properties.
        """
        self.sequence_number = sequence_number
        self.item_name = item_name
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BlueprintFlowSequenceFlow':
        """Initialize a BlueprintFlowSequenceFlow object from a json dictionary."""
        args = {}
        if 'sequence_number' in _dict:
            args['sequence_number'] = _dict.get('sequence_number')
        if 'item_name' in _dict:
            args['item_name'] = _dict.get('item_name')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BlueprintFlowSequenceFlow object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'sequence_number') and self.sequence_number is not None:
            _dict['sequence_number'] = self.sequence_number
        if hasattr(self, 'item_name') and self.item_name is not None:
            _dict['item_name'] = self.item_name
        for _key in [k for k in vars(self).keys() if k not in BlueprintFlowSequenceFlow._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BlueprintFlowSequenceFlow object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BlueprintFlowSequenceFlow') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BlueprintFlowSequenceFlow') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class BlueprintFlowSpecs():
    """
    BlueprintFlowSpecs.

    :attr str command_name: (optional) Schematics job command name.
    :attr str flow_type: (optional) Type of Blueprint flow specification.
    :attr List[BlueprintFlowSequenceFlow] sequence_flow: (optional) Ordered items in
          the simple sequence.
    :attr str conditional_flow: (optional) Placeholder for conditional flow.
    """

    # The set of defined properties for the class
    _properties = frozenset(['command_name', 'flow_type', 'sequence_flow', 'conditional_flow'])

    def __init__(self,
                 *,
                 command_name: str = None,
                 flow_type: str = None,
                 sequence_flow: List['BlueprintFlowSequenceFlow'] = None,
                 conditional_flow: str = None,
                 **kwargs) -> None:
        """
        Initialize a BlueprintFlowSpecs object.

        :param str command_name: (optional) Schematics job command name.
        :param str flow_type: (optional) Type of Blueprint flow specification.
        :param List[BlueprintFlowSequenceFlow] sequence_flow: (optional) Ordered
               items in the simple sequence.
        :param str conditional_flow: (optional) Placeholder for conditional flow.
        :param **kwargs: (optional) Any additional properties.
        """
        self.command_name = command_name
        self.flow_type = flow_type
        self.sequence_flow = sequence_flow
        self.conditional_flow = conditional_flow
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BlueprintFlowSpecs':
        """Initialize a BlueprintFlowSpecs object from a json dictionary."""
        args = {}
        if 'command_name' in _dict:
            args['command_name'] = _dict.get('command_name')
        if 'flow_type' in _dict:
            args['flow_type'] = _dict.get('flow_type')
        if 'sequence_flow' in _dict:
            args['sequence_flow'] = [BlueprintFlowSequenceFlow.from_dict(x) for x in _dict.get('sequence_flow')]
        if 'conditional_flow' in _dict:
            args['conditional_flow'] = _dict.get('conditional_flow')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BlueprintFlowSpecs object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'flow_type') and self.flow_type is not None:
            _dict['flow_type'] = self.flow_type
        if hasattr(self, 'sequence_flow') and self.sequence_flow is not None:
            _dict['sequence_flow'] = [x.to_dict() for x in self.sequence_flow]
        if hasattr(self, 'conditional_flow') and self.conditional_flow is not None:
            _dict['conditional_flow'] = self.conditional_flow
        for _key in [k for k in vars(self).keys() if k not in BlueprintFlowSpecs._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BlueprintFlowSpecs object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BlueprintFlowSpecs') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BlueprintFlowSpecs') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class CommandNameEnum(str, Enum):
        """
        Schematics job command name.
        """
        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        CREATE_ENVIRONMENT = 'create_environment'
        PUT_ENVIRONMENT = 'put_environment'
        DELETE_ENVIRONMENT = 'delete_environment'
        ENVIRONMENT_INIT = 'environment_init'
        ENVIRONMENT_INSTALL = 'environment_install'
        ENVIRONMENT_UNINSTALL = 'environment_uninstall'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'


    class FlowTypeEnum(str, Enum):
        """
        Type of Blueprint flow specification.
        """
        SEQUENCE_FLOW = 'sequence_flow'
        CONDITIONAL_FLOW = 'conditional_flow'


class BlueprintList():
    """
    List of Blueprints.

    :attr int total_count: (optional) Total number of Blueprint records.
    :attr int limit: Number of Blueprint records returned.
    :attr int offset: Skipped number of Blueprint records.
    :attr List[BlueprintLite] blueprints: (optional) List of Blueprints.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'blueprints'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 blueprints: List['BlueprintLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a BlueprintList object.

        :param int limit: Number of Blueprint records returned.
        :param int offset: Skipped number of Blueprint records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.blueprints = blueprints
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BlueprintList':
        """Initialize a BlueprintList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in BlueprintList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in BlueprintList JSON')
        if 'blueprints' in _dict:
            args['blueprints'] = [BlueprintLite.from_dict(x) for x in _dict.get('blueprints')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BlueprintList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and getattr(self, 'total_count') is not None:
            _dict['total_count'] = getattr(self, 'total_count')
        if hasattr(self, 'limit') and getattr(self, 'limit') is not None:
            _dict['limit'] = getattr(self, 'limit')
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'blueprints') and getattr(self, 'blueprints') is not None:
            _dict['blueprints'] = [x.to_dict() for x in getattr(self, 'blueprints')]
        for _key in [k for k in vars(self).keys() if k not in BlueprintList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BlueprintList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BlueprintList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BlueprintList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class BlueprintLite():
    """
    Blueprint summary profile.

    :attr str name: Blueprint name (unique for an account).
    :attr str description: (optional) Blueprint description.
    :attr str resource_group: (optional) Resource-group name for the Blueprint.  By
          default, Blueprint will be created in Default Resource Group.
    :attr List[str] tags: (optional) Blueprint tags.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str id: (optional) System generated Blueprint Id.
    :attr str crn: (optional) Blueprint CRN.
    :attr str account: (optional) Account id for the Blueprint.
    :attr datetime created_at: (optional) Blueprint creation time.
    :attr str created_by: (optional) User who created the Cart order.
    :attr datetime updated_at: (optional) Blueprint updation time.
    :attr str updated_by: (optional) User who updated the Cart order.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr BlueprintLiteState state: (optional) Computed state of the Blueprint.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'resource_group', 'tags', 'location', 'id', 'crn', 'account', 'created_at', 'created_by', 'updated_at', 'updated_by', 'sys_lock', 'user_state', 'state'])

    def __init__(self,
                 name: str,
                 *,
                 description: str = None,
                 resource_group: str = None,
                 tags: List[str] = None,
                 location: str = None,
                 id: str = None,
                 crn: str = None,
                 account: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 sys_lock: 'SystemLock' = None,
                 user_state: 'UserState' = None,
                 state: 'BlueprintLiteState' = None,
                 **kwargs) -> None:
        """
        Initialize a BlueprintLite object.

        :param str name: Blueprint name (unique for an account).
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param SystemLock sys_lock: (optional) System lock status.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param BlueprintLiteState state: (optional) Computed state of the
               Blueprint.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.resource_group = resource_group
        self.tags = tags
        self.location = location
        self.id = id
        self.crn = crn
        self.account = account
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.sys_lock = sys_lock
        self.user_state = user_state
        self.state = state
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BlueprintLite':
        """Initialize a BlueprintLite object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in BlueprintLite JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'account' in _dict:
            args['account'] = _dict.get('account')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'state' in _dict:
            args['state'] = BlueprintLiteState.from_dict(_dict.get('state'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BlueprintLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'description') and getattr(self, 'description') is not None:
            _dict['description'] = getattr(self, 'description')
        if hasattr(self, 'resource_group') and getattr(self, 'resource_group') is not None:
            _dict['resource_group'] = getattr(self, 'resource_group')
        if hasattr(self, 'tags') and getattr(self, 'tags') is not None:
            _dict['tags'] = getattr(self, 'tags')
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        for _key in [k for k in vars(self).keys() if k not in BlueprintLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BlueprintLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BlueprintLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BlueprintLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class BlueprintLiteState():
    """
    Computed state of the Blueprint.

    :attr str status_code: (optional) User-defined states
            * `Blueprint_Create_Init` When Create Blueprint POST API is invoked and
          CreateBlueprint process is initiated.
            * `Blueprint_Create_InProgress` When Create Blueprint process is in progress.
            * `Blueprint_Create_Success` Repos are downloaded and underlying objects are
          created
            * `Blueprint_Create_Failed` Failed to create Blueprint or underlying
          schematics objects.
    :attr str status_message: (optional) Automation status message - to be displayed
          along with the status_code.
    """

    # The set of defined properties for the class
    _properties = frozenset(['status_code', 'status_message'])

    def __init__(self,
                 *,
                 status_code: str = None,
                 status_message: str = None,
                 **kwargs) -> None:
        """
        Initialize a BlueprintLiteState object.

        :param str status_code: (optional) User-defined states
                 * `Blueprint_Create_Init` When Create Blueprint POST API is invoked and
               CreateBlueprint process is initiated.
                 * `Blueprint_Create_InProgress` When Create Blueprint process is in
               progress.
                 * `Blueprint_Create_Success` Repos are downloaded and underlying objects
               are created
                 * `Blueprint_Create_Failed` Failed to create Blueprint or underlying
               schematics objects.
        :param str status_message: (optional) Automation status message - to be
               displayed along with the status_code.
        :param **kwargs: (optional) Any additional properties.
        """
        self.status_code = status_code
        self.status_message = status_message
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BlueprintLiteState':
        """Initialize a BlueprintLiteState object from a json dictionary."""
        args = {}
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BlueprintLiteState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        for _key in [k for k in vars(self).keys() if k not in BlueprintLiteState._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BlueprintLiteState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BlueprintLiteState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BlueprintLiteState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        User-defined states
          * `Blueprint_Create_Init` When Create Blueprint POST API is invoked and
        CreateBlueprint process is initiated.
          * `Blueprint_Create_InProgress` When Create Blueprint process is in progress.
          * `Blueprint_Create_Success` Repos are downloaded and underlying objects are
        created
          * `Blueprint_Create_Failed` Failed to create Blueprint or underlying schematics
        objects.
        """
        BLUEPRINT_CREATE_INIT = 'Blueprint_Create_Init'
        BLUEPRINT_CREATE_INPROGRESS = 'Blueprint_Create_InProgress'
        BLUEPRINT_CREATE_SUCCESS = 'Blueprint_Create_Success'
        BLUEPRINT_CREATE_FAILED = 'Blueprint_Create_Failed'


class BlueprintVariableData():
    """
    User editable variable data & system generated reference to value.

    :attr str name: (optional) Name of the variable.
    :attr str value: (optional) Value for the variable or reference to the value.
    :attr str link: (optional) Reference link to the variable value By default the
          expression will point to self.value.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'value', 'link'])

    def __init__(self,
                 *,
                 name: str = None,
                 value: str = None,
                 link: str = None,
                 **kwargs) -> None:
        """
        Initialize a BlueprintVariableData object.

        :param str name: (optional) Name of the variable.
        :param str value: (optional) Value for the variable or reference to the
               value.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.value = value
        self.link = link
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'BlueprintVariableData':
        """Initialize a BlueprintVariableData object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        if 'link' in _dict:
            args['link'] = _dict.get('link')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a BlueprintVariableData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        if hasattr(self, 'link') and getattr(self, 'link') is not None:
            _dict['link'] = getattr(self, 'link')
        for _key in [k for k in vars(self).keys() if k not in BlueprintVariableData._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this BlueprintVariableData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'BlueprintVariableData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'BlueprintVariableData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class Capsule():
    """
    Complete capsule definition record.

    :attr str name: (optional) Name of the capsule.
    :attr str description: (optional) Capsule description.
    :attr str type: (optional) capsule type.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr str package: (optional) Policy package path.
    :attr int severity: (optional) Severity.
    :attr str inventory: (optional) Target inventory record ID, used to evaluate the
          policy.
    :attr str trigger_record_id: (optional) Id to the Trigger.
    :attr List[TriggerJob] job_triggers: (optional) List of Job Triggers.
    :attr List[TriggerScheduled] scheduled_triggers: (optional) List of Scheduled
          Triggers.
    :attr List[VariableData] inputs: (optional) Input data for the capsule.
    :attr List[ControlsDecision] decisions: (optional) List of decisions.
    :attr List[ControlsEscalation] escalations: (optional) List of escalations.
    :attr str id: (optional) Capsule Id.
    :attr str status: (optional) Capsule status.
    :attr str controls_id: (optional) Controls Id.
    :attr str controls_name: (optional) Controls name.
    :attr datetime created_at: (optional) Control policy creation time.
    :attr str created_by: (optional) Name of user who created the control policy.
    :attr datetime updated_at: (optional) Control policy updation time.
    :attr str updated_by: (optional) Name of user who updated the control policy.
    :attr ControlsLiteState state: (optional) Computed state of the Controls.
    :attr JobDataCapsule last_job_data: (optional) Capsule Job data.
    :attr SystemLock sys_lock: (optional) System lock status.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'type', 'user_state', 'package', 'severity', 'inventory', 'trigger_record_id', 'job_triggers', 'scheduled_triggers', 'inputs', 'decisions', 'escalations', 'id', 'status', 'controls_id', 'controls_name', 'created_at', 'created_by', 'updated_at', 'updated_by', 'state', 'last_job_data', 'sys_lock'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 type: str = None,
                 user_state: 'UserState' = None,
                 package: str = None,
                 severity: int = None,
                 inventory: str = None,
                 trigger_record_id: str = None,
                 job_triggers: List['TriggerJob'] = None,
                 scheduled_triggers: List['TriggerScheduled'] = None,
                 inputs: List['VariableData'] = None,
                 decisions: List['ControlsDecision'] = None,
                 escalations: List['ControlsEscalation'] = None,
                 id: str = None,
                 status: str = None,
                 controls_id: str = None,
                 controls_name: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 state: 'ControlsLiteState' = None,
                 last_job_data: 'JobDataCapsule' = None,
                 sys_lock: 'SystemLock' = None,
                 **kwargs) -> None:
        """
        Initialize a Capsule object.

        :param str name: (optional) Name of the capsule.
        :param str description: (optional) Capsule description.
        :param str type: (optional) capsule type.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param str package: (optional) Policy package path.
        :param int severity: (optional) Severity.
        :param str inventory: (optional) Target inventory record ID, used to
               evaluate the policy.
        :param str trigger_record_id: (optional) Id to the Trigger.
        :param List[TriggerJob] job_triggers: (optional) List of Job Triggers.
        :param List[TriggerScheduled] scheduled_triggers: (optional) List of
               Scheduled Triggers.
        :param List[VariableData] inputs: (optional) Input data for the capsule.
        :param List[ControlsDecision] decisions: (optional) List of decisions.
        :param List[ControlsEscalation] escalations: (optional) List of
               escalations.
        :param str id: (optional) Capsule Id.
        :param str status: (optional) Capsule status.
        :param str controls_id: (optional) Controls Id.
        :param str controls_name: (optional) Controls name.
        :param datetime created_at: (optional) Control policy creation time.
        :param str created_by: (optional) Name of user who created the control
               policy.
        :param datetime updated_at: (optional) Control policy updation time.
        :param str updated_by: (optional) Name of user who updated the control
               policy.
        :param ControlsLiteState state: (optional) Computed state of the Controls.
        :param JobDataCapsule last_job_data: (optional) Capsule Job data.
        :param SystemLock sys_lock: (optional) System lock status.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.type = type
        self.user_state = user_state
        self.package = package
        self.severity = severity
        self.inventory = inventory
        self.trigger_record_id = trigger_record_id
        self.job_triggers = job_triggers
        self.scheduled_triggers = scheduled_triggers
        self.inputs = inputs
        self.decisions = decisions
        self.escalations = escalations
        self.id = id
        self.status = status
        self.controls_id = controls_id
        self.controls_name = controls_name
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.state = state
        self.last_job_data = last_job_data
        self.sys_lock = sys_lock
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Capsule':
        """Initialize a Capsule object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'package' in _dict:
            args['package'] = _dict.get('package')
        if 'severity' in _dict:
            args['severity'] = _dict.get('severity')
        if 'inventory' in _dict:
            args['inventory'] = _dict.get('inventory')
        if 'trigger_record_id' in _dict:
            args['trigger_record_id'] = _dict.get('trigger_record_id')
        if 'job_triggers' in _dict:
            args['job_triggers'] = [TriggerJob.from_dict(x) for x in _dict.get('job_triggers')]
        if 'scheduled_triggers' in _dict:
            args['scheduled_triggers'] = [TriggerScheduled.from_dict(x) for x in _dict.get('scheduled_triggers')]
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'decisions' in _dict:
            args['decisions'] = [ControlsDecision.from_dict(x) for x in _dict.get('decisions')]
        if 'escalations' in _dict:
            args['escalations'] = [ControlsEscalation.from_dict(x) for x in _dict.get('escalations')]
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'status' in _dict:
            args['status'] = _dict.get('status')
        if 'controls_id' in _dict:
            args['controls_id'] = _dict.get('controls_id')
        if 'controls_name' in _dict:
            args['controls_name'] = _dict.get('controls_name')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'state' in _dict:
            args['state'] = ControlsLiteState.from_dict(_dict.get('state'))
        if 'last_job_data' in _dict:
            args['last_job_data'] = JobDataCapsule.from_dict(_dict.get('last_job_data'))
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Capsule object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'package') and self.package is not None:
            _dict['package'] = self.package
        if hasattr(self, 'severity') and self.severity is not None:
            _dict['severity'] = self.severity
        if hasattr(self, 'inventory') and self.inventory is not None:
            _dict['inventory'] = self.inventory
        if hasattr(self, 'trigger_record_id') and self.trigger_record_id is not None:
            _dict['trigger_record_id'] = self.trigger_record_id
        if hasattr(self, 'job_triggers') and self.job_triggers is not None:
            _dict['job_triggers'] = [x.to_dict() for x in self.job_triggers]
        if hasattr(self, 'scheduled_triggers') and self.scheduled_triggers is not None:
            _dict['scheduled_triggers'] = [x.to_dict() for x in self.scheduled_triggers]
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'decisions') and self.decisions is not None:
            _dict['decisions'] = [x.to_dict() for x in self.decisions]
        if hasattr(self, 'escalations') and self.escalations is not None:
            _dict['escalations'] = [x.to_dict() for x in self.escalations]
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status
        if hasattr(self, 'controls_id') and self.controls_id is not None:
            _dict['controls_id'] = self.controls_id
        if hasattr(self, 'controls_name') and self.controls_name is not None:
            _dict['controls_name'] = self.controls_name
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'updated_by') and self.updated_by is not None:
            _dict['updated_by'] = self.updated_by
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        if hasattr(self, 'last_job_data') and self.last_job_data is not None:
            _dict['last_job_data'] = self.last_job_data.to_dict()
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        for _key in [k for k in vars(self).keys() if k not in Capsule._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Capsule object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Capsule') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Capsule') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CapsuleList():
    """
    List of Capsule definitions response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[CapsuleLite] capsules: (optional) List of capsule records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'capsules'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 capsules: List['CapsuleLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a CapsuleList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[CapsuleLite] capsules: (optional) List of capsule records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.capsules = capsules
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CapsuleList':
        """Initialize a CapsuleList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in CapsuleList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in CapsuleList JSON')
        if 'capsules' in _dict:
            args['capsules'] = [CapsuleLite.from_dict(x) for x in _dict.get('capsules')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CapsuleList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'capsules') and self.capsules is not None:
            _dict['capsules'] = [x.to_dict() for x in self.capsules]
        for _key in [k for k in vars(self).keys() if k not in CapsuleList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CapsuleList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CapsuleList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CapsuleList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CapsuleLite():
    """
    Capsule summary profile with user inputs and system generated data.

    :attr str name: (optional) Capsule name (unique for an account).
    :attr str description: (optional) Capsule description.
    :attr str id: (optional) Capsule Id.
    :attr str crn: (optional) Capsule Cloud Resource Name.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str resource_group: (optional) Resource-group name for the Capsule.  By
          default, Capsule will be created in Default Resource Group.
    :attr List[str] tags: (optional) Capsule tags.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr CapsuleLiteState state: (optional) Computed state of the Capsule.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr datetime created_at: (optional) Capsule creation time.
    :attr str created_by: (optional) Email address of user who created the Capsule.
    :attr datetime updated_at: (optional) Capsule updation time.
    :attr str updated_by: (optional) Email address of user who updated the Capsule.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'id', 'crn', 'location', 'resource_group', 'tags', 'user_state', 'state', 'sys_lock', 'created_at', 'created_by', 'updated_at', 'updated_by'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 id: str = None,
                 crn: str = None,
                 location: str = None,
                 resource_group: str = None,
                 tags: List[str] = None,
                 user_state: 'UserState' = None,
                 state: 'CapsuleLiteState' = None,
                 sys_lock: 'SystemLock' = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a CapsuleLite object.

        :param str name: (optional) Capsule name (unique for an account).
        :param str description: (optional) Capsule description.
        :param str id: (optional) Capsule Id.
        :param str crn: (optional) Capsule Cloud Resource Name.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for the Capsule.
               By default, Capsule will be created in Default Resource Group.
        :param List[str] tags: (optional) Capsule tags.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param CapsuleLiteState state: (optional) Computed state of the Capsule.
        :param SystemLock sys_lock: (optional) System lock status.
        :param datetime created_at: (optional) Capsule creation time.
        :param str created_by: (optional) Email address of user who created the
               Capsule.
        :param datetime updated_at: (optional) Capsule updation time.
        :param str updated_by: (optional) Email address of user who updated the
               Capsule.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.id = id
        self.crn = crn
        self.location = location
        self.resource_group = resource_group
        self.tags = tags
        self.user_state = user_state
        self.state = state
        self.sys_lock = sys_lock
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CapsuleLite':
        """Initialize a CapsuleLite object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'state' in _dict:
            args['state'] = CapsuleLiteState.from_dict(_dict.get('state'))
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CapsuleLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'updated_by') and self.updated_by is not None:
            _dict['updated_by'] = self.updated_by
        for _key in [k for k in vars(self).keys() if k not in CapsuleLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CapsuleLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CapsuleLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CapsuleLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class CapsuleLiteState():
    """
    Computed state of the Capsule.

    :attr str status_code: (optional) Status of automation (workspace or action).
    :attr str status_message: (optional) Automation status message - to be displayed
          along with the status_code.
    """

    # The set of defined properties for the class
    _properties = frozenset(['status_code', 'status_message'])

    def __init__(self,
                 *,
                 status_code: str = None,
                 status_message: str = None,
                 **kwargs) -> None:
        """
        Initialize a CapsuleLiteState object.

        :param str status_code: (optional) Status of automation (workspace or
               action).
        :param str status_message: (optional) Automation status message - to be
               displayed along with the status_code.
        :param **kwargs: (optional) Any additional properties.
        """
        self.status_code = status_code
        self.status_message = status_message
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CapsuleLiteState':
        """Initialize a CapsuleLiteState object from a json dictionary."""
        args = {}
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CapsuleLiteState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        for _key in [k for k in vars(self).keys() if k not in CapsuleLiteState._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CapsuleLiteState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CapsuleLiteState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CapsuleLiteState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of automation (workspace or action).
        """
        NORMAL = 'normal'
        PENDING = 'pending'
        DISABLED = 'disabled'
        CRITICAL = 'critical'


class CapsuleResultEvidences():
    """
    List of capsule evidences.

    :attr List[CapsuleResultResources] resources: (optional) List of resources.
    """

    # The set of defined properties for the class
    _properties = frozenset(['resources'])

    def __init__(self,
                 *,
                 resources: List['CapsuleResultResources'] = None,
                 **kwargs) -> None:
        """
        Initialize a CapsuleResultEvidences object.

        :param List[CapsuleResultResources] resources: (optional) List of
               resources.
        :param **kwargs: (optional) Any additional properties.
        """
        self.resources = resources
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CapsuleResultEvidences':
        """Initialize a CapsuleResultEvidences object from a json dictionary."""
        args = {}
        if 'resources' in _dict:
            args['resources'] = [CapsuleResultResources.from_dict(x) for x in _dict.get('resources')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CapsuleResultEvidences object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'resources') and self.resources is not None:
            _dict['resources'] = [x.to_dict() for x in self.resources]
        for _key in [k for k in vars(self).keys() if k not in CapsuleResultEvidences._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CapsuleResultEvidences object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CapsuleResultEvidences') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CapsuleResultEvidences') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CapsuleResultResources():
    """
    Resource details.

    :attr str name: (optional) Name of the resource.
    :attr str type: (optional) Type of resource.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'type'])

    def __init__(self,
                 *,
                 name: str = None,
                 type: str = None,
                 **kwargs) -> None:
        """
        Initialize a CapsuleResultResources object.

        :param str name: (optional) Name of the resource.
        :param str type: (optional) Type of resource.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.type = type
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CapsuleResultResources':
        """Initialize a CapsuleResultResources object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CapsuleResultResources object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        for _key in [k for k in vars(self).keys() if k not in CapsuleResultResources._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CapsuleResultResources object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CapsuleResultResources') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CapsuleResultResources') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CartOrder():
    """
    Complete Cart order details with user inputs and system generated data.

    :attr str name: Cart order name (unique for an account).
    :attr str description: (optional) Cart order description.
    :attr List[str] tags: (optional) Cart order tags.
    :attr List[OrderItemConfiguration] cart_items: (optional)
    :attr str service_name: (optional) Service short name.
    :attr str resource_group: (optional) Resource-group name for the Cart order.  By
          default, Cart order will be created in Default Resource Group.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr CartOrderUserState user_state: (optional) User defined status of the
          Schematics object.
    :attr str cart_order_id: (optional) System generated Cart order Id.
    :attr str crn: (optional) Cart order CRN.
    :attr str account: (optional) Account id.
    :attr datetime created_at: (optional) Cart order creation time.
    :attr str created_by: (optional) Email address of user who created the Cart
          order.
    :attr datetime updated_at: (optional) Cart order updation time.
    :attr str updated_by: (optional) Email address of user who updated the Cart
          order.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr CartOrderLiteState state: (optional) Computed state of the CartOrder.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'tags', 'cart_items', 'service_name', 'resource_group', 'location', 'user_state', 'cart_order_id', 'crn', 'account', 'created_at', 'created_by', 'updated_at', 'updated_by', 'sys_lock', 'state'])

    def __init__(self,
                 name: str,
                 *,
                 description: str = None,
                 tags: List[str] = None,
                 cart_items: List['OrderItemConfiguration'] = None,
                 service_name: str = None,
                 resource_group: str = None,
                 location: str = None,
                 user_state: 'CartOrderUserState' = None,
                 cart_order_id: str = None,
                 crn: str = None,
                 account: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 sys_lock: 'SystemLock' = None,
                 state: 'CartOrderLiteState' = None,
                 **kwargs) -> None:
        """
        Initialize a CartOrder object.

        :param str name: Cart order name (unique for an account).
        :param str description: (optional) Cart order description.
        :param List[str] tags: (optional) Cart order tags.
        :param List[OrderItemConfiguration] cart_items: (optional)
        :param str service_name: (optional) Service short name.
        :param str resource_group: (optional) Resource-group name for the Cart
               order.  By default, Cart order will be created in Default Resource Group.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param CartOrderUserState user_state: (optional) User defined status of the
               Schematics object.
        :param SystemLock sys_lock: (optional) System lock status.
        :param CartOrderLiteState state: (optional) Computed state of the
               CartOrder.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.tags = tags
        self.cart_items = cart_items
        self.service_name = service_name
        self.resource_group = resource_group
        self.location = location
        self.user_state = user_state
        self.cart_order_id = cart_order_id
        self.crn = crn
        self.account = account
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.sys_lock = sys_lock
        self.state = state
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CartOrder':
        """Initialize a CartOrder object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in CartOrder JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'cart_items' in _dict:
            args['cart_items'] = [OrderItemConfiguration.from_dict(x) for x in _dict.get('cart_items')]
        if 'service_name' in _dict:
            args['service_name'] = _dict.get('service_name')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'user_state' in _dict:
            args['user_state'] = CartOrderUserState.from_dict(_dict.get('user_state'))
        if 'cart_order_id' in _dict:
            args['cart_order_id'] = _dict.get('cart_order_id')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'account' in _dict:
            args['account'] = _dict.get('account')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'state' in _dict:
            args['state'] = CartOrderLiteState.from_dict(_dict.get('state'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CartOrder object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'cart_items') and self.cart_items is not None:
            _dict['cart_items'] = [x.to_dict() for x in self.cart_items]
        if hasattr(self, 'service_name') and self.service_name is not None:
            _dict['service_name'] = self.service_name
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'cart_order_id') and getattr(self, 'cart_order_id') is not None:
            _dict['cart_order_id'] = getattr(self, 'cart_order_id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        for _key in [k for k in vars(self).keys() if k not in CartOrder._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CartOrder object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CartOrder') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CartOrder') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class CartOrderList():
    """
    List of Cart orders.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[CartOrderLite] cart: (optional) List of Cart order records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'cart'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 cart: List['CartOrderLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a CartOrderList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param List[CartOrderLite] cart: (optional) List of Cart order records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.cart = cart
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CartOrderList':
        """Initialize a CartOrderList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in CartOrderList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in CartOrderList JSON')
        if 'cart' in _dict:
            args['cart'] = [CartOrderLite.from_dict(x) for x in _dict.get('cart')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CartOrderList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and getattr(self, 'total_count') is not None:
            _dict['total_count'] = getattr(self, 'total_count')
        if hasattr(self, 'limit') and getattr(self, 'limit') is not None:
            _dict['limit'] = getattr(self, 'limit')
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'cart') and self.cart is not None:
            _dict['cart'] = [x.to_dict() for x in self.cart]
        for _key in [k for k in vars(self).keys() if k not in CartOrderList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CartOrderList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CartOrderList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CartOrderList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CartOrderLite():
    """
    Cart order summary profile.

    :attr str name: Unique account name for Cart order(unique for an account).
    :attr str description: (optional) Cart order description.
    :attr str service_name: (optional) Service short name.
    :attr str resource_group: (optional) Resource-group name for the Cart order.  By
          default, Cart order will be created in Default Resource Group.
    :attr List[str] tags: (optional) Cart order tags.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str id: (optional) System generated cart order Id.
    :attr str crn: (optional) Cart order CRN.
    :attr str account: (optional) Account id.
    :attr datetime created_at: (optional) Cart order creation time.
    :attr str created_by: (optional) Email address of user who created the Cart
          order.
    :attr datetime updated_at: (optional) Cart order updation time.
    :attr str updated_by: (optional) Email address of user who updated the Cart
          order.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr CartOrderUserState user_state: (optional) User defined status of the
          Schematics object.
    :attr CartOrderLiteState state: (optional) Computed state of the CartOrder.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'service_name', 'resource_group', 'tags', 'location', 'id', 'crn', 'account', 'created_at', 'created_by', 'updated_at', 'updated_by', 'sys_lock', 'user_state', 'state'])

    def __init__(self,
                 name: str,
                 *,
                 description: str = None,
                 service_name: str = None,
                 resource_group: str = None,
                 tags: List[str] = None,
                 location: str = None,
                 id: str = None,
                 crn: str = None,
                 account: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 sys_lock: 'SystemLock' = None,
                 user_state: 'CartOrderUserState' = None,
                 state: 'CartOrderLiteState' = None,
                 **kwargs) -> None:
        """
        Initialize a CartOrderLite object.

        :param str name: Unique account name for Cart order(unique for an account).
        :param str description: (optional) Cart order description.
        :param str service_name: (optional) Service short name.
        :param str resource_group: (optional) Resource-group name for the Cart
               order.  By default, Cart order will be created in Default Resource Group.
        :param List[str] tags: (optional) Cart order tags.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param SystemLock sys_lock: (optional) System lock status.
        :param CartOrderUserState user_state: (optional) User defined status of the
               Schematics object.
        :param CartOrderLiteState state: (optional) Computed state of the
               CartOrder.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.service_name = service_name
        self.resource_group = resource_group
        self.tags = tags
        self.location = location
        self.id = id
        self.crn = crn
        self.account = account
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.sys_lock = sys_lock
        self.user_state = user_state
        self.state = state
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CartOrderLite':
        """Initialize a CartOrderLite object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in CartOrderLite JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'service_name' in _dict:
            args['service_name'] = _dict.get('service_name')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'account' in _dict:
            args['account'] = _dict.get('account')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'user_state' in _dict:
            args['user_state'] = CartOrderUserState.from_dict(_dict.get('user_state'))
        if 'state' in _dict:
            args['state'] = CartOrderLiteState.from_dict(_dict.get('state'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CartOrderLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'service_name') and self.service_name is not None:
            _dict['service_name'] = self.service_name
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        for _key in [k for k in vars(self).keys() if k not in CartOrderLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CartOrderLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CartOrderLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CartOrderLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class CartOrderLiteState():
    """
    Computed state of the CartOrder.

    :attr str status_code: (optional) Status of automation (workspace or action).
    :attr str status_message: (optional) Automation status message - to be displayed
          along with the status_code.
    """

    # The set of defined properties for the class
    _properties = frozenset(['status_code', 'status_message'])

    def __init__(self,
                 *,
                 status_code: str = None,
                 status_message: str = None,
                 **kwargs) -> None:
        """
        Initialize a CartOrderLiteState object.

        :param str status_code: (optional) Status of automation (workspace or
               action).
        :param str status_message: (optional) Automation status message - to be
               displayed along with the status_code.
        :param **kwargs: (optional) Any additional properties.
        """
        self.status_code = status_code
        self.status_message = status_message
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CartOrderLiteState':
        """Initialize a CartOrderLiteState object from a json dictionary."""
        args = {}
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CartOrderLiteState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        for _key in [k for k in vars(self).keys() if k not in CartOrderLiteState._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CartOrderLiteState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CartOrderLiteState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CartOrderLiteState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of automation (workspace or action).
        """
        NORMAL = 'normal'
        PENDING = 'pending'
        DISABLED = 'disabled'
        CRITICAL = 'critical'


class CartOrderUserState():
    """
    User defined status of the Schematics object.

    :attr str state: (optional) User-defined states
            * `Order_Create_Init` When Create Order POST API is invoked and CreateOrder
          process is initiated.
            * `Order_Create_InProgress` When CreateOrder process is in progress.
            * `Order_Create_Success` Repos are downloaded and underlying objects are
          created
            * `Order_Create_Failed` Failed to create CartOrder or underlying schematics
          objects
            * `Order_Fulfilment_Pending` Fulfilment operation is triggered and waiting to
          be picked up by orchestrator.
            * `Order_Fulfilment_InProgress` Actively processing fulfilment operation
            * `Order_Fulfilment_Success` Fulfilment successful
            * `Order_Fulfilment_Failed` Fulfilment failed.
    :attr str set_by: (optional) Name of the User who set the state of the Object.
    :attr datetime set_at: (optional) When the User who set the state of the Object.
    """

    # The set of defined properties for the class
    _properties = frozenset(['state', 'set_by', 'set_at'])

    def __init__(self,
                 *,
                 state: str = None,
                 set_by: str = None,
                 set_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a CartOrderUserState object.

        :param str state: (optional) User-defined states
                 * `Order_Create_Init` When Create Order POST API is invoked and
               CreateOrder process is initiated.
                 * `Order_Create_InProgress` When CreateOrder process is in progress.
                 * `Order_Create_Success` Repos are downloaded and underlying objects are
               created
                 * `Order_Create_Failed` Failed to create CartOrder or underlying
               schematics objects
                 * `Order_Fulfilment_Pending` Fulfilment operation is triggered and
               waiting to be picked up by orchestrator.
                 * `Order_Fulfilment_InProgress` Actively processing fulfilment operation
                 * `Order_Fulfilment_Success` Fulfilment successful
                 * `Order_Fulfilment_Failed` Fulfilment failed.
        :param str set_by: (optional) Name of the User who set the state of the
               Object.
        :param datetime set_at: (optional) When the User who set the state of the
               Object.
        :param **kwargs: (optional) Any additional properties.
        """
        self.state = state
        self.set_by = set_by
        self.set_at = set_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CartOrderUserState':
        """Initialize a CartOrderUserState object from a json dictionary."""
        args = {}
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'set_by' in _dict:
            args['set_by'] = _dict.get('set_by')
        if 'set_at' in _dict:
            args['set_at'] = string_to_datetime(_dict.get('set_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CartOrderUserState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state
        if hasattr(self, 'set_by') and self.set_by is not None:
            _dict['set_by'] = self.set_by
        if hasattr(self, 'set_at') and self.set_at is not None:
            _dict['set_at'] = datetime_to_string(self.set_at)
        for _key in [k for k in vars(self).keys() if k not in CartOrderUserState._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CartOrderUserState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CartOrderUserState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CartOrderUserState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StateEnum(str, Enum):
        """
        User-defined states
          * `Order_Create_Init` When Create Order POST API is invoked and CreateOrder
        process is initiated.
          * `Order_Create_InProgress` When CreateOrder process is in progress.
          * `Order_Create_Success` Repos are downloaded and underlying objects are created
          * `Order_Create_Failed` Failed to create CartOrder or underlying schematics
        objects
          * `Order_Fulfilment_Pending` Fulfilment operation is triggered and waiting to be
        picked up by orchestrator.
          * `Order_Fulfilment_InProgress` Actively processing fulfilment operation
          * `Order_Fulfilment_Success` Fulfilment successful
          * `Order_Fulfilment_Failed` Fulfilment failed.
        """
        ORDER_CREATE_INIT = 'Order_Create_Init'
        ORDER_CREATE_INPROGRESS = 'Order_Create_InProgress'
        ORDER_CREATE_SUCCESS = 'Order_Create_Success'
        ORDER_CREATE_FAILED = 'Order_Create_Failed'
        ORDER_FULFILMENT_PENDING = 'Order_Fulfilment_Pending'
        ORDER_FULFILMENT_SUCCESS = 'Order_Fulfilment_Success'
        ORDER_FULFILMENT_FAILED = 'Order_Fulfilment_Failed'


class CatalogOfferingItem():
    """
    Catalog offering details.

    :attr str name: (optional) Catalog offering item name.
    :attr str label: (optional) Catalog offering item label name.
    :attr str offering_id: (optional) Offering Id.
    :attr str short_description: (optional)
    :attr str crn: (optional) CRN of the catalog item.
    :attr str offering_url: (optional) Offering url.
    :attr List[CatalogOfferingItemVersions] versions: (optional) Offering version.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'label', 'offering_id', 'short_description', 'crn', 'offering_url', 'versions'])

    def __init__(self,
                 *,
                 name: str = None,
                 label: str = None,
                 offering_id: str = None,
                 short_description: str = None,
                 crn: str = None,
                 offering_url: str = None,
                 versions: List['CatalogOfferingItemVersions'] = None,
                 **kwargs) -> None:
        """
        Initialize a CatalogOfferingItem object.

        :param str name: (optional) Catalog offering item name.
        :param str label: (optional) Catalog offering item label name.
        :param str offering_id: (optional) Offering Id.
        :param str short_description: (optional)
        :param str crn: (optional) CRN of the catalog item.
        :param str offering_url: (optional) Offering url.
        :param List[CatalogOfferingItemVersions] versions: (optional) Offering
               version.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.label = label
        self.offering_id = offering_id
        self.short_description = short_description
        self.crn = crn
        self.offering_url = offering_url
        self.versions = versions
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CatalogOfferingItem':
        """Initialize a CatalogOfferingItem object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'label' in _dict:
            args['label'] = _dict.get('label')
        if 'offering_id' in _dict:
            args['offering_id'] = _dict.get('offering_id')
        if 'short_description' in _dict:
            args['short_description'] = _dict.get('short_description')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'offering_url' in _dict:
            args['offering_url'] = _dict.get('offering_url')
        if 'versions' in _dict:
            args['versions'] = [CatalogOfferingItemVersions.from_dict(x) for x in _dict.get('versions')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CatalogOfferingItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'label') and self.label is not None:
            _dict['label'] = self.label
        if hasattr(self, 'offering_id') and self.offering_id is not None:
            _dict['offering_id'] = self.offering_id
        if hasattr(self, 'short_description') and self.short_description is not None:
            _dict['short_description'] = self.short_description
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'offering_url') and self.offering_url is not None:
            _dict['offering_url'] = self.offering_url
        if hasattr(self, 'versions') and self.versions is not None:
            _dict['versions'] = [x.to_dict() for x in self.versions]
        for _key in [k for k in vars(self).keys() if k not in CatalogOfferingItem._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CatalogOfferingItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CatalogOfferingItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CatalogOfferingItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CatalogOfferingItemVersions():
    """
    CatalogOfferingItemVersions.

    :attr str version: (optional)
    :attr str versionid: (optional)
    """

    # The set of defined properties for the class
    _properties = frozenset(['version', 'versionid'])

    def __init__(self,
                 *,
                 version: str = None,
                 versionid: str = None,
                 **kwargs) -> None:
        """
        Initialize a CatalogOfferingItemVersions object.

        :param str version: (optional)
        :param str versionid: (optional)
        :param **kwargs: (optional) Any additional properties.
        """
        self.version = version
        self.versionid = versionid
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CatalogOfferingItemVersions':
        """Initialize a CatalogOfferingItemVersions object from a json dictionary."""
        args = {}
        if 'version' in _dict:
            args['version'] = _dict.get('version')
        if 'versionid' in _dict:
            args['versionid'] = _dict.get('versionid')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CatalogOfferingItemVersions object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'version') and self.version is not None:
            _dict['version'] = self.version
        if hasattr(self, 'versionid') and self.versionid is not None:
            _dict['versionid'] = self.versionid
        for _key in [k for k in vars(self).keys() if k not in CatalogOfferingItemVersions._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CatalogOfferingItemVersions object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CatalogOfferingItemVersions') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CatalogOfferingItemVersions') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CloudResource():
    """
    Cloud resource data.

    :attr str resource_id: (optional) Cloud resource id.
    :attr str cloud_resource_name: (optional) Cloud resource name.
    :attr str terraform_resource_name: (optional) Terraform cloud resource name.
    :attr str crn: (optional) Cloud resource CRN (if applicable).
    :attr str resource_state: (optional) State of the Cloud resource.
    :attr List[str] tags: (optional) Cloud resource tags.
    """

    # The set of defined properties for the class
    _properties = frozenset(['resource_id', 'cloud_resource_name', 'terraform_resource_name', 'crn', 'resource_state', 'tags'])

    def __init__(self,
                 *,
                 resource_id: str = None,
                 cloud_resource_name: str = None,
                 terraform_resource_name: str = None,
                 crn: str = None,
                 resource_state: str = None,
                 tags: List[str] = None,
                 **kwargs) -> None:
        """
        Initialize a CloudResource object.

        :param str resource_id: (optional) Cloud resource id.
        :param str cloud_resource_name: (optional) Cloud resource name.
        :param str terraform_resource_name: (optional) Terraform cloud resource
               name.
        :param str crn: (optional) Cloud resource CRN (if applicable).
        :param str resource_state: (optional) State of the Cloud resource.
        :param List[str] tags: (optional) Cloud resource tags.
        :param **kwargs: (optional) Any additional properties.
        """
        self.resource_id = resource_id
        self.cloud_resource_name = cloud_resource_name
        self.terraform_resource_name = terraform_resource_name
        self.crn = crn
        self.resource_state = resource_state
        self.tags = tags
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CloudResource':
        """Initialize a CloudResource object from a json dictionary."""
        args = {}
        if 'resource_id' in _dict:
            args['resource_id'] = _dict.get('resource_id')
        if 'cloud_resource_name' in _dict:
            args['cloud_resource_name'] = _dict.get('cloud_resource_name')
        if 'terraform_resource_name' in _dict:
            args['terraform_resource_name'] = _dict.get('terraform_resource_name')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'resource_state' in _dict:
            args['resource_state'] = _dict.get('resource_state')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CloudResource object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'resource_id') and self.resource_id is not None:
            _dict['resource_id'] = self.resource_id
        if hasattr(self, 'cloud_resource_name') and self.cloud_resource_name is not None:
            _dict['cloud_resource_name'] = self.cloud_resource_name
        if hasattr(self, 'terraform_resource_name') and self.terraform_resource_name is not None:
            _dict['terraform_resource_name'] = self.terraform_resource_name
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'resource_state') and self.resource_state is not None:
            _dict['resource_state'] = self.resource_state
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        for _key in [k for k in vars(self).keys() if k not in CloudResource._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CloudResource object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CloudResource') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CloudResource') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CloudResourceList():
    """
    List of cloud resources.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[CloudResource] outputs: (optional) List of cloud resource details.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'outputs'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 outputs: List['CloudResource'] = None,
                 **kwargs) -> None:
        """
        Initialize a CloudResourceList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[CloudResource] outputs: (optional) List of cloud resource
               details.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.outputs = outputs
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CloudResourceList':
        """Initialize a CloudResourceList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in CloudResourceList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in CloudResourceList JSON')
        if 'outputs' in _dict:
            args['outputs'] = [CloudResource.from_dict(x) for x in _dict.get('outputs')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CloudResourceList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        for _key in [k for k in vars(self).keys() if k not in CloudResourceList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CloudResourceList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CloudResourceList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CloudResourceList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CommandList():
    """
    List of Schematics commands.

    :attr List[CommandListCommands] commands: (optional) List of Schematics command
          names and parameters.
    """

    # The set of defined properties for the class
    _properties = frozenset(['commands'])

    def __init__(self,
                 *,
                 commands: List['CommandListCommands'] = None,
                 **kwargs) -> None:
        """
        Initialize a CommandList object.

        :param List[CommandListCommands] commands: (optional) List of Schematics
               command names and parameters.
        :param **kwargs: (optional) Any additional properties.
        """
        self.commands = commands
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CommandList':
        """Initialize a CommandList object from a json dictionary."""
        args = {}
        if 'commands' in _dict:
            args['commands'] = [CommandListCommands.from_dict(x) for x in _dict.get('commands')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CommandList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'commands') and self.commands is not None:
            _dict['commands'] = [x.to_dict() for x in self.commands]
        for _key in [k for k in vars(self).keys() if k not in CommandList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CommandList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CommandList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CommandList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CommandListCommands():
    """
    CommandListCommands.

    :attr str command_name: (optional) Schematics job command name.
    :attr str command_parameter: (optional) Schematics job command parameter
          (playbook-name, capsule-name or flow-name).
    """

    # The set of defined properties for the class
    _properties = frozenset(['command_name', 'command_parameter'])

    def __init__(self,
                 *,
                 command_name: str = None,
                 command_parameter: str = None,
                 **kwargs) -> None:
        """
        Initialize a CommandListCommands object.

        :param str command_name: (optional) Schematics job command name.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name, capsule-name or flow-name).
        :param **kwargs: (optional) Any additional properties.
        """
        self.command_name = command_name
        self.command_parameter = command_parameter
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CommandListCommands':
        """Initialize a CommandListCommands object from a json dictionary."""
        args = {}
        if 'command_name' in _dict:
            args['command_name'] = _dict.get('command_name')
        if 'command_parameter' in _dict:
            args['command_parameter'] = _dict.get('command_parameter')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CommandListCommands object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'command_parameter') and self.command_parameter is not None:
            _dict['command_parameter'] = self.command_parameter
        for _key in [k for k in vars(self).keys() if k not in CommandListCommands._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CommandListCommands object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CommandListCommands') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CommandListCommands') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class CommandNameEnum(str, Enum):
        """
        Schematics job command name.
        """
        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        CREATE_ENVIRONMENT = 'create_environment'
        PUT_ENVIRONMENT = 'put_environment'
        DELETE_ENVIRONMENT = 'delete_environment'
        ENVIRONMENT_INIT = 'environment_init'
        ENVIRONMENT_INSTALL = 'environment_install'
        ENVIRONMENT_UNINSTALL = 'environment_uninstall'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'


class CommandsInfo():
    """
    Workspace commands run as part of the job.

    :attr str name: (optional) Name of the command.
    :attr str outcome: (optional) outcome of the command.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'outcome'])

    def __init__(self,
                 *,
                 name: str = None,
                 outcome: str = None,
                 **kwargs) -> None:
        """
        Initialize a CommandsInfo object.

        :param str name: (optional) Name of the command.
        :param str outcome: (optional) outcome of the command.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.outcome = outcome
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CommandsInfo':
        """Initialize a CommandsInfo object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'outcome' in _dict:
            args['outcome'] = _dict.get('outcome')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CommandsInfo object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'outcome') and self.outcome is not None:
            _dict['outcome'] = self.outcome
        for _key in [k for k in vars(self).keys() if k not in CommandsInfo._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CommandsInfo object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CommandsInfo') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CommandsInfo') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class Connection():
    """
    External connection definition with unique id.

    :attr str name: (optional) connection name (unique for an account).
    :attr str description: (optional) connection description.
    :attr str resource_group: (optional) Resource-group id for the connection.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr List[str] tags: (optional) connection tags.
    :attr str crn: (optional) The CRN of the connection.
    :attr str connection_type: (optional) Name of the plugin used for the
          connection.
    :attr List[VariableData] connection_properties: (optional)
    :attr str id: (optional) Generated connection id.
    :attr str account: (optional) account id.
    :attr datetime created_at: (optional) connection creation time.
    :attr str created_by: (optional) Email address of user who created the
          connection.
    :attr datetime updated_at: (optional) connection updation time.
    :attr str updated_by: (optional) Email address of user who updated the
          connection.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'resource_group', 'location', 'tags', 'crn', 'connection_type', 'connection_properties', 'id', 'account', 'created_at', 'created_by', 'updated_at', 'updated_by'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 resource_group: str = None,
                 location: str = None,
                 tags: List[str] = None,
                 crn: str = None,
                 connection_type: str = None,
                 connection_properties: List['VariableData'] = None,
                 id: str = None,
                 account: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a Connection object.

        :param str name: (optional) connection name (unique for an account).
        :param str description: (optional) connection description.
        :param str resource_group: (optional) Resource-group id for the connection.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param List[str] tags: (optional) connection tags.
        :param str connection_type: (optional) Name of the plugin used for the
               connection.
        :param List[VariableData] connection_properties: (optional)
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.resource_group = resource_group
        self.location = location
        self.tags = tags
        self.crn = crn
        self.connection_type = connection_type
        self.connection_properties = connection_properties
        self.id = id
        self.account = account
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Connection':
        """Initialize a Connection object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'connection_type' in _dict:
            args['connection_type'] = _dict.get('connection_type')
        if 'connection_properties' in _dict:
            args['connection_properties'] = [VariableData.from_dict(x) for x in _dict.get('connection_properties')]
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'account' in _dict:
            args['account'] = _dict.get('account')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Connection object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'connection_type') and self.connection_type is not None:
            _dict['connection_type'] = self.connection_type
        if hasattr(self, 'connection_properties') and self.connection_properties is not None:
            _dict['connection_properties'] = [x.to_dict() for x in self.connection_properties]
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        for _key in [k for k in vars(self).keys() if k not in Connection._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Connection object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Connection') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Connection') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class ConnectionList():
    """
    List of external connection definition.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[ConnectionLite] connections: (optional) List of connection records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'connections'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 connections: List['ConnectionLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a ConnectionList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[ConnectionLite] connections: (optional) List of connection
               records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.connections = connections
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConnectionList':
        """Initialize a ConnectionList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in ConnectionList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in ConnectionList JSON')
        if 'connections' in _dict:
            args['connections'] = [ConnectionLite.from_dict(x) for x in _dict.get('connections')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ConnectionList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'connections') and self.connections is not None:
            _dict['connections'] = [x.to_dict() for x in self.connections]
        for _key in [k for k in vars(self).keys() if k not in ConnectionList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ConnectionList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ConnectionList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ConnectionList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ConnectionLite():
    """
    External connection definition required to connect external services.

    :attr str name: (optional) Connection name (unique for an account).
    :attr str resource_group: (optional) Resource-group id for the connection.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr List[str] tags: (optional) connection tags.
    :attr str connection_type: (optional) Name of the plugin used for the
          connection.
    :attr str id: (optional) Generated connection id.
    :attr datetime created_at: (optional) connection creation time.
    :attr str created_by: (optional) Email address of user who created the
          connection.
    :attr datetime updated_at: (optional) connection updation time.
    :attr str updated_by: (optional) Email address of user who updated the
          connection.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'resource_group', 'location', 'tags', 'connection_type', 'id', 'created_at', 'created_by', 'updated_at', 'updated_by'])

    def __init__(self,
                 *,
                 name: str = None,
                 resource_group: str = None,
                 location: str = None,
                 tags: List[str] = None,
                 connection_type: str = None,
                 id: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a ConnectionLite object.

        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str connection_type: (optional) Name of the plugin used for the
               connection.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.resource_group = resource_group
        self.location = location
        self.tags = tags
        self.connection_type = connection_type
        self.id = id
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ConnectionLite':
        """Initialize a ConnectionLite object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'connection_type' in _dict:
            args['connection_type'] = _dict.get('connection_type')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ConnectionLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'resource_group') and getattr(self, 'resource_group') is not None:
            _dict['resource_group'] = getattr(self, 'resource_group')
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'tags') and getattr(self, 'tags') is not None:
            _dict['tags'] = getattr(self, 'tags')
        if hasattr(self, 'connection_type') and self.connection_type is not None:
            _dict['connection_type'] = self.connection_type
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        for _key in [k for k in vars(self).keys() if k not in ConnectionLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ConnectionLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ConnectionLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ConnectionLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class Controls():
    """
    Complete Controls definition with user input and system generated data.

    :attr str name: (optional) Controls name (unique for an account).
    :attr str type: (optional) Controls type.
    :attr str description: (optional) Control description.
    :attr str resource_group: (optional) Resource-group name for the Controls. By
          default, controls will be created in Default Resource Group.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr List[str] tags: (optional) Tags for the Controls definition.
    :attr str source_readme_url: (optional) URL of the Readme file, for the source.
    :attr ExternalSource source: (optional) Source of templates, playbooks, or
          controls.
    :attr str source_type: (optional) Type of source for the Template.
    :attr List[VariableData] inputs: (optional) Input variables for the Controls.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr str id: (optional) Controls Id.
    :attr str crn: (optional) Controls Cloud Resource Name.
    :attr datetime source_created_at: (optional) Controls Source creation time.
    :attr str source_created_by: (optional) Email address of user who created the
          Controls Source.
    :attr datetime source_updated_at: (optional) Controls Source updation time.
    :attr str source_updated_by: (optional) Email address of user who updated the
          Controls Source.
    :attr datetime created_at: (optional) Controls creation time.
    :attr str created_by: (optional) Name of user who created the controls.
    :attr datetime updated_at: (optional) Controls updation time.
    :attr str updated_by: (optional) Name of user who updated the controls.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr List[Capsule] capsules: (optional) List of capsules.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'type', 'description', 'resource_group', 'location', 'tags', 'source_readme_url', 'source', 'source_type', 'inputs', 'user_state', 'id', 'crn', 'source_created_at', 'source_created_by', 'source_updated_at', 'source_updated_by', 'created_at', 'created_by', 'updated_at', 'updated_by', 'sys_lock', 'capsules'])

    def __init__(self,
                 *,
                 name: str = None,
                 type: str = None,
                 description: str = None,
                 resource_group: str = None,
                 location: str = None,
                 tags: List[str] = None,
                 source_readme_url: str = None,
                 source: 'ExternalSource' = None,
                 source_type: str = None,
                 inputs: List['VariableData'] = None,
                 user_state: 'UserState' = None,
                 id: str = None,
                 crn: str = None,
                 source_created_at: datetime = None,
                 source_created_by: str = None,
                 source_updated_at: datetime = None,
                 source_updated_by: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 sys_lock: 'SystemLock' = None,
                 capsules: List['Capsule'] = None,
                 **kwargs) -> None:
        """
        Initialize a Controls object.

        :param str name: (optional) Controls name (unique for an account).
        :param str type: (optional) Controls type.
        :param str description: (optional) Control description.
        :param str resource_group: (optional) Resource-group name for the Controls.
               By default, controls will be created in Default Resource Group.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param List[str] tags: (optional) Tags for the Controls definition.
        :param str source_readme_url: (optional) URL of the Readme file, for the
               source.
        :param ExternalSource source: (optional) Source of templates, playbooks, or
               controls.
        :param str source_type: (optional) Type of source for the Template.
        :param List[VariableData] inputs: (optional) Input variables for the
               Controls.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param SystemLock sys_lock: (optional) System lock status.
        :param List[Capsule] capsules: (optional) List of capsules.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.type = type
        self.description = description
        self.resource_group = resource_group
        self.location = location
        self.tags = tags
        self.source_readme_url = source_readme_url
        self.source = source
        self.source_type = source_type
        self.inputs = inputs
        self.user_state = user_state
        self.id = id
        self.crn = crn
        self.source_created_at = source_created_at
        self.source_created_by = source_created_by
        self.source_updated_at = source_updated_at
        self.source_updated_by = source_updated_by
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.sys_lock = sys_lock
        self.capsules = capsules
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Controls':
        """Initialize a Controls object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'source_readme_url' in _dict:
            args['source_readme_url'] = _dict.get('source_readme_url')
        if 'source' in _dict:
            args['source'] = ExternalSource.from_dict(_dict.get('source'))
        if 'source_type' in _dict:
            args['source_type'] = _dict.get('source_type')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'source_created_at' in _dict:
            args['source_created_at'] = string_to_datetime(_dict.get('source_created_at'))
        if 'source_created_by' in _dict:
            args['source_created_by'] = _dict.get('source_created_by')
        if 'source_updated_at' in _dict:
            args['source_updated_at'] = string_to_datetime(_dict.get('source_updated_at'))
        if 'source_updated_by' in _dict:
            args['source_updated_by'] = _dict.get('source_updated_by')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'capsules' in _dict:
            args['capsules'] = [Capsule.from_dict(x) for x in _dict.get('capsules')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Controls object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'source_readme_url') and self.source_readme_url is not None:
            _dict['source_readme_url'] = self.source_readme_url
        if hasattr(self, 'source') and self.source is not None:
            _dict['source'] = self.source.to_dict()
        if hasattr(self, 'source_type') and self.source_type is not None:
            _dict['source_type'] = self.source_type
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'source_created_at') and getattr(self, 'source_created_at') is not None:
            _dict['source_created_at'] = datetime_to_string(getattr(self, 'source_created_at'))
        if hasattr(self, 'source_created_by') and getattr(self, 'source_created_by') is not None:
            _dict['source_created_by'] = getattr(self, 'source_created_by')
        if hasattr(self, 'source_updated_at') and getattr(self, 'source_updated_at') is not None:
            _dict['source_updated_at'] = datetime_to_string(getattr(self, 'source_updated_at'))
        if hasattr(self, 'source_updated_by') and getattr(self, 'source_updated_by') is not None:
            _dict['source_updated_by'] = getattr(self, 'source_updated_by')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'capsules') and self.capsules is not None:
            _dict['capsules'] = [x.to_dict() for x in self.capsules]
        for _key in [k for k in vars(self).keys() if k not in Controls._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Controls object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Controls') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Controls') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Controls type.
        """
        IT_CONTROLS = 'it_controls'
        SECURITY_CONTROLS = 'security_controls'
        FINANCIAL_CONTROLS = 'financial_controls'
        OTHER_CONTROLS = 'other_controls'


    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


    class SourceTypeEnum(str, Enum):
        """
        Type of source for the Template.
        """
        LOCAL = 'local'
        GIT_HUB = 'git_hub'
        GIT_HUB_ENTERPRISE = 'git_hub_enterprise'
        GIT_LAB = 'git_lab'
        IBM_GIT_LAB = 'ibm_git_lab'
        IBM_CLOUD_CATALOG = 'ibm_cloud_catalog'
        EXTERNAL_SCM = 'external_scm'


class ControlsDecision():
    """
    Policy ControlsDecision definition.

    :attr str rule: (optional) ControlsDecision rules.
    :attr str pass_value: (optional) Pass value.
    :attr str pass_expr: (optional) Pass expression.
    :attr str evidence_found_in: (optional) Evidence found in.
    """

    # The set of defined properties for the class
    _properties = frozenset(['rule', 'pass_value', 'pass_expr', 'evidence_found_in'])

    def __init__(self,
                 *,
                 rule: str = None,
                 pass_value: str = None,
                 pass_expr: str = None,
                 evidence_found_in: str = None,
                 **kwargs) -> None:
        """
        Initialize a ControlsDecision object.

        :param str rule: (optional) ControlsDecision rules.
        :param str pass_value: (optional) Pass value.
        :param str pass_expr: (optional) Pass expression.
        :param str evidence_found_in: (optional) Evidence found in.
        :param **kwargs: (optional) Any additional properties.
        """
        self.rule = rule
        self.pass_value = pass_value
        self.pass_expr = pass_expr
        self.evidence_found_in = evidence_found_in
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ControlsDecision':
        """Initialize a ControlsDecision object from a json dictionary."""
        args = {}
        if 'rule' in _dict:
            args['rule'] = _dict.get('rule')
        if 'pass_value' in _dict:
            args['pass_value'] = _dict.get('pass_value')
        if 'pass_expr' in _dict:
            args['pass_expr'] = _dict.get('pass_expr')
        if 'evidence_found_in' in _dict:
            args['evidence_found_in'] = _dict.get('evidence_found_in')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ControlsDecision object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'rule') and self.rule is not None:
            _dict['rule'] = self.rule
        if hasattr(self, 'pass_value') and self.pass_value is not None:
            _dict['pass_value'] = self.pass_value
        if hasattr(self, 'pass_expr') and self.pass_expr is not None:
            _dict['pass_expr'] = self.pass_expr
        if hasattr(self, 'evidence_found_in') and self.evidence_found_in is not None:
            _dict['evidence_found_in'] = self.evidence_found_in
        for _key in [k for k in vars(self).keys() if k not in ControlsDecision._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ControlsDecision object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ControlsDecision') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ControlsDecision') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class PassValueEnum(str, Enum):
        """
        Pass value.
        """
        BEFORE = 'before'
        AFTER = 'after'


class ControlsEscalation():
    """
    ControlsEscalation definition.

    :attr str action_id: (optional) ControlsEscalation details (placeholder).
    """

    # The set of defined properties for the class
    _properties = frozenset(['action_id'])

    def __init__(self,
                 *,
                 action_id: str = None,
                 **kwargs) -> None:
        """
        Initialize a ControlsEscalation object.

        :param str action_id: (optional) ControlsEscalation details (placeholder).
        :param **kwargs: (optional) Any additional properties.
        """
        self.action_id = action_id
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ControlsEscalation':
        """Initialize a ControlsEscalation object from a json dictionary."""
        args = {}
        if 'action_id' in _dict:
            args['action_id'] = _dict.get('action_id')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ControlsEscalation object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_id') and self.action_id is not None:
            _dict['action_id'] = self.action_id
        for _key in [k for k in vars(self).keys() if k not in ControlsEscalation._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ControlsEscalation object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ControlsEscalation') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ControlsEscalation') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ControlsList():
    """
    List of Controls definition response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[ControlsLite] controls: (optional) List of control records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'controls'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 controls: List['ControlsLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a ControlsList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[ControlsLite] controls: (optional) List of control records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.controls = controls
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ControlsList':
        """Initialize a ControlsList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in ControlsList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in ControlsList JSON')
        if 'controls' in _dict:
            args['controls'] = [ControlsLite.from_dict(x) for x in _dict.get('controls')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ControlsList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'controls') and self.controls is not None:
            _dict['controls'] = [x.to_dict() for x in self.controls]
        for _key in [k for k in vars(self).keys() if k not in ControlsList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ControlsList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ControlsList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ControlsList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ControlsLite():
    """
    Controls summary profile with user inputs and system generated data.

    :attr str name: (optional) Controls name (unique for an account).
    :attr str description: (optional) Controls description.
    :attr str id: (optional) Controls Id.
    :attr str crn: (optional) Controls Cloud Resource Name.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str resource_group: (optional) Resource-group name for the Controls.  By
          default, Controls will be created in Default Resource Group.
    :attr List[str] tags: (optional) Controls tags.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr ControlsLiteState state: (optional) Computed state of the Controls.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr datetime created_at: (optional) Controls creation time.
    :attr str created_by: (optional) Email address of user who created the Controls.
    :attr datetime updated_at: (optional) Controls updation time.
    :attr str updated_by: (optional) Email address of user who updated the Controls.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'id', 'crn', 'location', 'resource_group', 'tags', 'user_state', 'state', 'sys_lock', 'created_at', 'created_by', 'updated_at', 'updated_by'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 id: str = None,
                 crn: str = None,
                 location: str = None,
                 resource_group: str = None,
                 tags: List[str] = None,
                 user_state: 'UserState' = None,
                 state: 'ControlsLiteState' = None,
                 sys_lock: 'SystemLock' = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a ControlsLite object.

        :param str name: (optional) Controls name (unique for an account).
        :param str description: (optional) Controls description.
        :param str id: (optional) Controls Id.
        :param str crn: (optional) Controls Cloud Resource Name.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for the Controls.
                By default, Controls will be created in Default Resource Group.
        :param List[str] tags: (optional) Controls tags.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param ControlsLiteState state: (optional) Computed state of the Controls.
        :param SystemLock sys_lock: (optional) System lock status.
        :param datetime created_at: (optional) Controls creation time.
        :param str created_by: (optional) Email address of user who created the
               Controls.
        :param datetime updated_at: (optional) Controls updation time.
        :param str updated_by: (optional) Email address of user who updated the
               Controls.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.id = id
        self.crn = crn
        self.location = location
        self.resource_group = resource_group
        self.tags = tags
        self.user_state = user_state
        self.state = state
        self.sys_lock = sys_lock
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ControlsLite':
        """Initialize a ControlsLite object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'state' in _dict:
            args['state'] = ControlsLiteState.from_dict(_dict.get('state'))
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ControlsLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'updated_by') and self.updated_by is not None:
            _dict['updated_by'] = self.updated_by
        for _key in [k for k in vars(self).keys() if k not in ControlsLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ControlsLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ControlsLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ControlsLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class ControlsLiteState():
    """
    Computed state of the Controls.

    :attr str status_code: (optional) Status of automation (workspace or action).
    :attr str status_message: (optional) Automation status message - to be displayed
          along with the status_code.
    """

    # The set of defined properties for the class
    _properties = frozenset(['status_code', 'status_message'])

    def __init__(self,
                 *,
                 status_code: str = None,
                 status_message: str = None,
                 **kwargs) -> None:
        """
        Initialize a ControlsLiteState object.

        :param str status_code: (optional) Status of automation (workspace or
               action).
        :param str status_message: (optional) Automation status message - to be
               displayed along with the status_code.
        :param **kwargs: (optional) Any additional properties.
        """
        self.status_code = status_code
        self.status_message = status_message
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ControlsLiteState':
        """Initialize a ControlsLiteState object from a json dictionary."""
        args = {}
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ControlsLiteState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        for _key in [k for k in vars(self).keys() if k not in ControlsLiteState._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ControlsLiteState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ControlsLiteState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ControlsLiteState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of automation (workspace or action).
        """
        NORMAL = 'normal'
        PENDING = 'pending'
        DISABLED = 'disabled'
        CRITICAL = 'critical'


class CredentialVariableData():
    """
    User editable credential variable data and system generated reference to the value.

    :attr str name: (optional) The name of the credential variable.
    :attr str value: (optional) The credential value for the variable or reference
          to the value. For example, `value = "<provide your ssh_key_value with \n>"`.
          **Note** The SSH key should contain `\n` at the end of the key details in case
          of command line or API calls.
    :attr bool use_default: (optional) True, will ignore the data in the value
          attribute, instead the data in metadata.default_value will be used.
    :attr CredentialVariableMetadata metadata: (optional) An user editable metadata
          for the credential variables.
    :attr str link: (optional) The reference link to the variable value By default
          the expression points to `$self.value`.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'value', 'use_default', 'metadata', 'link'])

    def __init__(self,
                 *,
                 name: str = None,
                 value: str = None,
                 use_default: bool = None,
                 metadata: 'CredentialVariableMetadata' = None,
                 link: str = None,
                 **kwargs) -> None:
        """
        Initialize a CredentialVariableData object.

        :param str name: (optional) The name of the credential variable.
        :param str value: (optional) The credential value for the variable or
               reference to the value. For example, `value = "<provide your ssh_key_value
               with \n>"`. **Note** The SSH key should contain `\n` at the end of the key
               details in case of command line or API calls.
        :param bool use_default: (optional) True, will ignore the data in the value
               attribute, instead the data in metadata.default_value will be used.
        :param CredentialVariableMetadata metadata: (optional) An user editable
               metadata for the credential variables.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.value = value
        self.use_default = use_default
        self.metadata = metadata
        self.link = link
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CredentialVariableData':
        """Initialize a CredentialVariableData object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        if 'use_default' in _dict:
            args['use_default'] = _dict.get('use_default')
        if 'metadata' in _dict:
            args['metadata'] = CredentialVariableMetadata.from_dict(_dict.get('metadata'))
        if 'link' in _dict:
            args['link'] = _dict.get('link')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CredentialVariableData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        if hasattr(self, 'use_default') and self.use_default is not None:
            _dict['use_default'] = self.use_default
        if hasattr(self, 'metadata') and self.metadata is not None:
            _dict['metadata'] = self.metadata.to_dict()
        if hasattr(self, 'link') and getattr(self, 'link') is not None:
            _dict['link'] = getattr(self, 'link')
        for _key in [k for k in vars(self).keys() if k not in CredentialVariableData._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CredentialVariableData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CredentialVariableData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CredentialVariableData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class CredentialVariableMetadata():
    """
    An user editable metadata for the credential variables.

    :attr str type: (optional) Type of the variable.
    :attr List[str] aliases: (optional) The list of aliases for the variable name.
    :attr str description: (optional) The description of the meta data.
    :attr str cloud_data_type: (optional) Cloud data type of the credential
          variable. eg. api_key, iam_token, profile_id.
    :attr str default_value: (optional) Default value for the variable only if the
          override value is not specified.
    :attr str link_status: (optional) The status of the link.
    :attr bool immutable: (optional) Is the variable readonly ?.
    :attr bool hidden: (optional) If **true**, the variable is not displayed on UI
          or Command line.
    :attr bool required: (optional) If the variable required?.
    :attr int position: (optional) The relative position of this variable in a list.
    :attr str group_by: (optional) The display name of the group this variable
          belongs to.
    :attr str source: (optional) The source of this meta-data.
    """

    # The set of defined properties for the class
    _properties = frozenset(['type', 'aliases', 'description', 'cloud_data_type', 'default_value', 'link_status', 'immutable', 'hidden', 'required', 'position', 'group_by', 'source'])

    def __init__(self,
                 *,
                 type: str = None,
                 aliases: List[str] = None,
                 description: str = None,
                 cloud_data_type: str = None,
                 default_value: str = None,
                 link_status: str = None,
                 immutable: bool = None,
                 hidden: bool = None,
                 required: bool = None,
                 position: int = None,
                 group_by: str = None,
                 source: str = None,
                 **kwargs) -> None:
        """
        Initialize a CredentialVariableMetadata object.

        :param str type: (optional) Type of the variable.
        :param List[str] aliases: (optional) The list of aliases for the variable
               name.
        :param str description: (optional) The description of the meta data.
        :param str cloud_data_type: (optional) Cloud data type of the credential
               variable. eg. api_key, iam_token, profile_id.
        :param str default_value: (optional) Default value for the variable only if
               the override value is not specified.
        :param str link_status: (optional) The status of the link.
        :param bool immutable: (optional) Is the variable readonly ?.
        :param bool hidden: (optional) If **true**, the variable is not displayed
               on UI or Command line.
        :param bool required: (optional) If the variable required?.
        :param int position: (optional) The relative position of this variable in a
               list.
        :param str group_by: (optional) The display name of the group this variable
               belongs to.
        :param str source: (optional) The source of this meta-data.
        :param **kwargs: (optional) Any additional properties.
        """
        self.type = type
        self.aliases = aliases
        self.description = description
        self.cloud_data_type = cloud_data_type
        self.default_value = default_value
        self.link_status = link_status
        self.immutable = immutable
        self.hidden = hidden
        self.required = required
        self.position = position
        self.group_by = group_by
        self.source = source
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'CredentialVariableMetadata':
        """Initialize a CredentialVariableMetadata object from a json dictionary."""
        args = {}
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'aliases' in _dict:
            args['aliases'] = _dict.get('aliases')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'cloud_data_type' in _dict:
            args['cloud_data_type'] = _dict.get('cloud_data_type')
        if 'default_value' in _dict:
            args['default_value'] = _dict.get('default_value')
        if 'link_status' in _dict:
            args['link_status'] = _dict.get('link_status')
        if 'immutable' in _dict:
            args['immutable'] = _dict.get('immutable')
        if 'hidden' in _dict:
            args['hidden'] = _dict.get('hidden')
        if 'required' in _dict:
            args['required'] = _dict.get('required')
        if 'position' in _dict:
            args['position'] = _dict.get('position')
        if 'group_by' in _dict:
            args['group_by'] = _dict.get('group_by')
        if 'source' in _dict:
            args['source'] = _dict.get('source')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a CredentialVariableMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'aliases') and self.aliases is not None:
            _dict['aliases'] = self.aliases
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'cloud_data_type') and self.cloud_data_type is not None:
            _dict['cloud_data_type'] = self.cloud_data_type
        if hasattr(self, 'default_value') and self.default_value is not None:
            _dict['default_value'] = self.default_value
        if hasattr(self, 'link_status') and self.link_status is not None:
            _dict['link_status'] = self.link_status
        if hasattr(self, 'immutable') and self.immutable is not None:
            _dict['immutable'] = self.immutable
        if hasattr(self, 'hidden') and self.hidden is not None:
            _dict['hidden'] = self.hidden
        if hasattr(self, 'required') and self.required is not None:
            _dict['required'] = self.required
        if hasattr(self, 'position') and self.position is not None:
            _dict['position'] = self.position
        if hasattr(self, 'group_by') and self.group_by is not None:
            _dict['group_by'] = self.group_by
        if hasattr(self, 'source') and self.source is not None:
            _dict['source'] = self.source
        for _key in [k for k in vars(self).keys() if k not in CredentialVariableMetadata._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this CredentialVariableMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'CredentialVariableMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'CredentialVariableMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Type of the variable.
        """
        STRING = 'string'
        LINK = 'link'


    class LinkStatusEnum(str, Enum):
        """
        The status of the link.
        """
        NORMAL = 'normal'
        BROKEN = 'broken'


class Dataset():
    """
    Complete details of the Dataset record.

    :attr str name: (optional) Shared dataset name (unique for an account).
    :attr str type: (optional) Dataset types.
    :attr str description: (optional) Shared dataset description.
    :attr str resource_group: (optional) Resource-group id for the shared dataset.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr List[str] tags: (optional) Shared dataset tags.
    :attr List[VariableData] data: (optional) Local shared dataset.
    :attr str datasource: (optional) Reference to Datasource ID.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr str dataset_id: (optional) Dataset Id.
    :attr str account: (optional) Account id.
    :attr datetime created_at: (optional) Dataset creation time.
    :attr str created_by: (optional) Name of user who created the shared dataset.
    :attr datetime updated_at: (optional) Dataset updation time.
    :attr str updated_by: (optional) Name of user who updated the shared dataset.
    :attr List[str] affected_resource_ids: (optional) List of resouce-ids
          (Workspace, Action, Controls) that are impacted by the change in shared dataset
          values.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'type', 'description', 'resource_group', 'location', 'tags', 'data', 'datasource', 'user_state', 'dataset_id', 'account', 'created_at', 'created_by', 'updated_at', 'updated_by', 'affected_resource_ids'])

    def __init__(self,
                 *,
                 name: str = None,
                 type: str = None,
                 description: str = None,
                 resource_group: str = None,
                 location: str = None,
                 tags: List[str] = None,
                 data: List['VariableData'] = None,
                 datasource: str = None,
                 user_state: 'UserState' = None,
                 dataset_id: str = None,
                 account: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 affected_resource_ids: List[str] = None,
                 **kwargs) -> None:
        """
        Initialize a Dataset object.

        :param str name: (optional) Shared dataset name (unique for an account).
        :param str type: (optional) Dataset types.
        :param str description: (optional) Shared dataset description.
        :param str resource_group: (optional) Resource-group id for the shared
               dataset.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param List[str] tags: (optional) Shared dataset tags.
        :param List[VariableData] data: (optional) Local shared dataset.
        :param str datasource: (optional) Reference to Datasource ID.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.type = type
        self.description = description
        self.resource_group = resource_group
        self.location = location
        self.tags = tags
        self.data = data
        self.datasource = datasource
        self.user_state = user_state
        self.dataset_id = dataset_id
        self.account = account
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.affected_resource_ids = affected_resource_ids
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Dataset':
        """Initialize a Dataset object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'data' in _dict:
            args['data'] = [VariableData.from_dict(x) for x in _dict.get('data')]
        if 'datasource' in _dict:
            args['datasource'] = _dict.get('datasource')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'dataset_id' in _dict:
            args['dataset_id'] = _dict.get('dataset_id')
        if 'account' in _dict:
            args['account'] = _dict.get('account')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'affected_resource_ids' in _dict:
            args['affected_resource_ids'] = _dict.get('affected_resource_ids')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Dataset object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'data') and self.data is not None:
            _dict['data'] = [x.to_dict() for x in self.data]
        if hasattr(self, 'datasource') and self.datasource is not None:
            _dict['datasource'] = self.datasource
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'dataset_id') and getattr(self, 'dataset_id') is not None:
            _dict['dataset_id'] = getattr(self, 'dataset_id')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'affected_resource_ids') and getattr(self, 'affected_resource_ids') is not None:
            _dict['affected_resource_ids'] = getattr(self, 'affected_resource_ids')
        for _key in [k for k in vars(self).keys() if k not in Dataset._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Dataset object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Dataset') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Dataset') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Dataset types.
        """
        CREDENTIAL = 'credential'
        CONFIGURATION = 'configuration'


    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class DatasetList():
    """
    List of dataset definition response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[DatasetLite] datasets: (optional) List of dataset records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'datasets'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 datasets: List['DatasetLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a DatasetList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[DatasetLite] datasets: (optional) List of dataset records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.datasets = datasets
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'DatasetList':
        """Initialize a DatasetList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in DatasetList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in DatasetList JSON')
        if 'datasets' in _dict:
            args['datasets'] = [DatasetLite.from_dict(x) for x in _dict.get('datasets')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a DatasetList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'datasets') and self.datasets is not None:
            _dict['datasets'] = [x.to_dict() for x in self.datasets]
        for _key in [k for k in vars(self).keys() if k not in DatasetList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this DatasetList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'DatasetList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'DatasetList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class DatasetLite():
    """
    Summary Profile of the Dataset.

    :attr str name: (optional) Dataset name (unique for an account).
    :attr str dataset_id: (optional) Dataset Id.
    :attr str type: (optional) Dataset types.
    :attr str description: (optional) Dataset description.
    :attr str resource_group: (optional) Resource-group id for the shared dataset.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr List[str] tags: (optional) Dataset tags.
    :attr str source_type: (optional) Type of source for the Template.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr datetime created_at: (optional) Dataset creation time.
    :attr str created_by: (optional) Name of user who created the shared dataset.
    :attr datetime updated_at: (optional) Dataset updation time.
    :attr str updated_by: (optional) Name of user who updated the dataset.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'dataset_id', 'type', 'description', 'resource_group', 'location', 'tags', 'source_type', 'user_state', 'created_at', 'created_by', 'updated_at', 'updated_by'])

    def __init__(self,
                 *,
                 name: str = None,
                 dataset_id: str = None,
                 type: str = None,
                 description: str = None,
                 resource_group: str = None,
                 location: str = None,
                 tags: List[str] = None,
                 source_type: str = None,
                 user_state: 'UserState' = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a DatasetLite object.

        :param str type: (optional) Dataset types.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str source_type: (optional) Type of source for the Template.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.dataset_id = dataset_id
        self.type = type
        self.description = description
        self.resource_group = resource_group
        self.location = location
        self.tags = tags
        self.source_type = source_type
        self.user_state = user_state
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'DatasetLite':
        """Initialize a DatasetLite object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'dataset_id' in _dict:
            args['dataset_id'] = _dict.get('dataset_id')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'source_type' in _dict:
            args['source_type'] = _dict.get('source_type')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a DatasetLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'dataset_id') and getattr(self, 'dataset_id') is not None:
            _dict['dataset_id'] = getattr(self, 'dataset_id')
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'description') and getattr(self, 'description') is not None:
            _dict['description'] = getattr(self, 'description')
        if hasattr(self, 'resource_group') and getattr(self, 'resource_group') is not None:
            _dict['resource_group'] = getattr(self, 'resource_group')
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'tags') and getattr(self, 'tags') is not None:
            _dict['tags'] = getattr(self, 'tags')
        if hasattr(self, 'source_type') and self.source_type is not None:
            _dict['source_type'] = self.source_type
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        for _key in [k for k in vars(self).keys() if k not in DatasetLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this DatasetLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'DatasetLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'DatasetLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Dataset types.
        """
        CREDENTIAL = 'credential'
        CONFIGURATION = 'configuration'


    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


    class SourceTypeEnum(str, Enum):
        """
        Type of source for the Template.
        """
        LOCAL = 'local'
        GIT_HUB = 'git_hub'
        GIT_HUB_ENTERPRISE = 'git_hub_enterprise'
        GIT_LAB = 'git_lab'
        IBM_GIT_LAB = 'ibm_git_lab'
        IBM_CLOUD_CATALOG = 'ibm_cloud_catalog'
        EXTERNAL_SCM = 'external_scm'


class Datasource():
    """
    External datasource definition.

    :attr str name: (optional) External data source name (unique for an account).
    :attr str description: (optional) data source description.
    :attr str resource_group: (optional) Resource-group id for the data source.
    :attr List[str] tags: (optional) data source tags.
    :attr str connection: (optional) Named connection from settings.
    :attr List[VariableData] datasource_properties: (optional)
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str id: (optional) Generated datasource id.
    :attr str account: (optional) account id.
    :attr datetime created_at: (optional) datasource creation time.
    :attr str created_by: (optional) Email address of user who created the
          datasource.
    :attr datetime updated_at: (optional) datasource updation time.
    :attr str updated_by: (optional) Email address of user who updated the
          datasource.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'resource_group', 'tags', 'connection', 'datasource_properties', 'location', 'id', 'account', 'created_at', 'created_by', 'updated_at', 'updated_by'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 resource_group: str = None,
                 tags: List[str] = None,
                 connection: str = None,
                 datasource_properties: List['VariableData'] = None,
                 location: str = None,
                 id: str = None,
                 account: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a Datasource object.

        :param str name: (optional) External data source name (unique for an
               account).
        :param str description: (optional) data source description.
        :param str resource_group: (optional) Resource-group id for the data
               source.
        :param List[str] tags: (optional) data source tags.
        :param str connection: (optional) Named connection from settings.
        :param List[VariableData] datasource_properties: (optional)
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.resource_group = resource_group
        self.tags = tags
        self.connection = connection
        self.datasource_properties = datasource_properties
        self.location = location
        self.id = id
        self.account = account
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Datasource':
        """Initialize a Datasource object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'connection' in _dict:
            args['connection'] = _dict.get('connection')
        if 'datasource_properties' in _dict:
            args['datasource_properties'] = [VariableData.from_dict(x) for x in _dict.get('datasource_properties')]
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'account' in _dict:
            args['account'] = _dict.get('account')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Datasource object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'connection') and self.connection is not None:
            _dict['connection'] = self.connection
        if hasattr(self, 'datasource_properties') and self.datasource_properties is not None:
            _dict['datasource_properties'] = [x.to_dict() for x in self.datasource_properties]
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        for _key in [k for k in vars(self).keys() if k not in Datasource._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Datasource object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Datasource') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Datasource') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class DatasourceList():
    """
    List of datasource definition.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[DatasourceLite] datasources: (optional) List of data source records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'datasources'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 datasources: List['DatasourceLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a DatasourceList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[DatasourceLite] datasources: (optional) List of data source
               records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.datasources = datasources
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'DatasourceList':
        """Initialize a DatasourceList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in DatasourceList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in DatasourceList JSON')
        if 'datasources' in _dict:
            args['datasources'] = [DatasourceLite.from_dict(x) for x in _dict.get('datasources')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a DatasourceList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'datasources') and self.datasources is not None:
            _dict['datasources'] = [x.to_dict() for x in self.datasources]
        for _key in [k for k in vars(self).keys() if k not in DatasourceList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this DatasourceList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'DatasourceList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'DatasourceList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class DatasourceLite():
    """
    User editable datasource details.

    :attr str name: (optional) data source name (unique for an account).
    :attr str description: (optional) data source description.
    :attr str resource_group: (optional) Resource-group id for the data source.
    :attr List[str] tags: (optional) data source tags.
    :attr str connection: (optional) Named connection from settings.
    :attr str id: (optional) Generated datasource id.
    :attr datetime created_at: (optional) datasource creation time.
    :attr str created_by: (optional) Email address of user who created the
          datasource.
    :attr datetime updated_at: (optional) datasource updation time.
    :attr str updated_by: (optional) Email address of user who updated the
          datasource.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'resource_group', 'tags', 'connection', 'id', 'created_at', 'created_by', 'updated_at', 'updated_by'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 resource_group: str = None,
                 tags: List[str] = None,
                 connection: str = None,
                 id: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a DatasourceLite object.

        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.resource_group = resource_group
        self.tags = tags
        self.connection = connection
        self.id = id
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'DatasourceLite':
        """Initialize a DatasourceLite object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'connection' in _dict:
            args['connection'] = _dict.get('connection')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a DatasourceLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'description') and getattr(self, 'description') is not None:
            _dict['description'] = getattr(self, 'description')
        if hasattr(self, 'resource_group') and getattr(self, 'resource_group') is not None:
            _dict['resource_group'] = getattr(self, 'resource_group')
        if hasattr(self, 'tags') and getattr(self, 'tags') is not None:
            _dict['tags'] = getattr(self, 'tags')
        if hasattr(self, 'connection') and getattr(self, 'connection') is not None:
            _dict['connection'] = getattr(self, 'connection')
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        for _key in [k for k in vars(self).keys() if k not in DatasourceLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this DatasourceLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'DatasourceLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'DatasourceLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ExternalSource():
    """
    Source of templates, playbooks, or controls.

    :attr str source_type: Type of source for the Template.
    :attr ExternalSourceGit git: (optional) The connection details to the Git source
          repository.
    :attr ExternalSourceCatalog catalog: (optional) The connection details to the
          IBM Cloud Catalog source.
    """

    # The set of defined properties for the class
    _properties = frozenset(['source_type', 'git', 'catalog'])

    def __init__(self,
                 source_type: str,
                 *,
                 git: 'ExternalSourceGit' = None,
                 catalog: 'ExternalSourceCatalog' = None,
                 **kwargs) -> None:
        """
        Initialize a ExternalSource object.

        :param str source_type: Type of source for the Template.
        :param ExternalSourceGit git: (optional) The connection details to the Git
               source repository.
        :param ExternalSourceCatalog catalog: (optional) The connection details to
               the IBM Cloud Catalog source.
        :param **kwargs: (optional) Any additional properties.
        """
        self.source_type = source_type
        self.git = git
        self.catalog = catalog
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ExternalSource':
        """Initialize a ExternalSource object from a json dictionary."""
        args = {}
        if 'source_type' in _dict:
            args['source_type'] = _dict.get('source_type')
        else:
            raise ValueError('Required property \'source_type\' not present in ExternalSource JSON')
        if 'git' in _dict:
            args['git'] = ExternalSourceGit.from_dict(_dict.get('git'))
        if 'catalog' in _dict:
            args['catalog'] = ExternalSourceCatalog.from_dict(_dict.get('catalog'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ExternalSource object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'source_type') and self.source_type is not None:
            _dict['source_type'] = self.source_type
        if hasattr(self, 'git') and self.git is not None:
            _dict['git'] = self.git.to_dict()
        if hasattr(self, 'catalog') and self.catalog is not None:
            _dict['catalog'] = self.catalog.to_dict()
        for _key in [k for k in vars(self).keys() if k not in ExternalSource._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ExternalSource object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ExternalSource') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ExternalSource') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SourceTypeEnum(str, Enum):
        """
        Type of source for the Template.
        """
        LOCAL = 'local'
        GIT_HUB = 'git_hub'
        GIT_HUB_ENTERPRISE = 'git_hub_enterprise'
        GIT_LAB = 'git_lab'
        IBM_GIT_LAB = 'ibm_git_lab'
        IBM_CLOUD_CATALOG = 'ibm_cloud_catalog'
        EXTERNAL_SCM = 'external_scm'


class ExternalSourceCatalog():
    """
    The connection details to the IBM Cloud Catalog source.

    :attr str catalog_name: (optional) The name of the private catalog.
    :attr str offering_name: (optional) The name of an offering in the IBM Cloud
          Catalog.
    :attr str offering_version: (optional) The version string of an offering in the
          IBM Cloud Catalog.
    :attr str offering_kind: (optional) The type of an offering, in the IBM Cloud
          Catalog.
    :attr str offering_id: (optional) The ID of an offering in the IBM Cloud
          Catalog.
    :attr str offering_version_id: (optional) The ID of an offering version the IBM
          Cloud Catalog.
    :attr str offering_repo_url: (optional) The repository URL of an offering, in
          the IBM Cloud Catalog.
    """

    # The set of defined properties for the class
    _properties = frozenset(['catalog_name', 'offering_name', 'offering_version', 'offering_kind', 'offering_id', 'offering_version_id', 'offering_repo_url'])

    def __init__(self,
                 *,
                 catalog_name: str = None,
                 offering_name: str = None,
                 offering_version: str = None,
                 offering_kind: str = None,
                 offering_id: str = None,
                 offering_version_id: str = None,
                 offering_repo_url: str = None,
                 **kwargs) -> None:
        """
        Initialize a ExternalSourceCatalog object.

        :param str catalog_name: (optional) The name of the private catalog.
        :param str offering_name: (optional) The name of an offering in the IBM
               Cloud Catalog.
        :param str offering_version: (optional) The version string of an offering
               in the IBM Cloud Catalog.
        :param str offering_kind: (optional) The type of an offering, in the IBM
               Cloud Catalog.
        :param str offering_id: (optional) The ID of an offering in the IBM Cloud
               Catalog.
        :param str offering_version_id: (optional) The ID of an offering version
               the IBM Cloud Catalog.
        :param str offering_repo_url: (optional) The repository URL of an offering,
               in the IBM Cloud Catalog.
        :param **kwargs: (optional) Any additional properties.
        """
        self.catalog_name = catalog_name
        self.offering_name = offering_name
        self.offering_version = offering_version
        self.offering_kind = offering_kind
        self.offering_id = offering_id
        self.offering_version_id = offering_version_id
        self.offering_repo_url = offering_repo_url
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ExternalSourceCatalog':
        """Initialize a ExternalSourceCatalog object from a json dictionary."""
        args = {}
        if 'catalog_name' in _dict:
            args['catalog_name'] = _dict.get('catalog_name')
        if 'offering_name' in _dict:
            args['offering_name'] = _dict.get('offering_name')
        if 'offering_version' in _dict:
            args['offering_version'] = _dict.get('offering_version')
        if 'offering_kind' in _dict:
            args['offering_kind'] = _dict.get('offering_kind')
        if 'offering_id' in _dict:
            args['offering_id'] = _dict.get('offering_id')
        if 'offering_version_id' in _dict:
            args['offering_version_id'] = _dict.get('offering_version_id')
        if 'offering_repo_url' in _dict:
            args['offering_repo_url'] = _dict.get('offering_repo_url')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ExternalSourceCatalog object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'catalog_name') and self.catalog_name is not None:
            _dict['catalog_name'] = self.catalog_name
        if hasattr(self, 'offering_name') and self.offering_name is not None:
            _dict['offering_name'] = self.offering_name
        if hasattr(self, 'offering_version') and self.offering_version is not None:
            _dict['offering_version'] = self.offering_version
        if hasattr(self, 'offering_kind') and self.offering_kind is not None:
            _dict['offering_kind'] = self.offering_kind
        if hasattr(self, 'offering_id') and self.offering_id is not None:
            _dict['offering_id'] = self.offering_id
        if hasattr(self, 'offering_version_id') and self.offering_version_id is not None:
            _dict['offering_version_id'] = self.offering_version_id
        if hasattr(self, 'offering_repo_url') and self.offering_repo_url is not None:
            _dict['offering_repo_url'] = self.offering_repo_url
        for _key in [k for k in vars(self).keys() if k not in ExternalSourceCatalog._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ExternalSourceCatalog object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ExternalSourceCatalog') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ExternalSourceCatalog') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ExternalSourceGit():
    """
    The connection details to the Git source repository.

    :attr str computed_git_repo_url: (optional) The complete URL which is computed
          by the **git_repo_url**, **git_repo_folder**, and **branch**.
    :attr str git_repo_url: (optional) The URL to the Git repository that can be
          used to clone the template.
    :attr str git_token: (optional) The Personal Access Token (PAT) to connect to
          the Git URLs.
    :attr str git_repo_folder: (optional) The name of the folder in the Git
          repository, that contains the template.
    :attr str git_release: (optional) The name of the release tag that are used to
          fetch the Git repository.
    :attr str git_branch: (optional) The name of the branch that are used to fetch
          the Git repository.
    """

    # The set of defined properties for the class
    _properties = frozenset(['computed_git_repo_url', 'git_repo_url', 'git_token', 'git_repo_folder', 'git_release', 'git_branch'])

    def __init__(self,
                 *,
                 computed_git_repo_url: str = None,
                 git_repo_url: str = None,
                 git_token: str = None,
                 git_repo_folder: str = None,
                 git_release: str = None,
                 git_branch: str = None,
                 **kwargs) -> None:
        """
        Initialize a ExternalSourceGit object.

        :param str computed_git_repo_url: (optional) The complete URL which is
               computed by the **git_repo_url**, **git_repo_folder**, and **branch**.
        :param str git_repo_url: (optional) The URL to the Git repository that can
               be used to clone the template.
        :param str git_token: (optional) The Personal Access Token (PAT) to connect
               to the Git URLs.
        :param str git_repo_folder: (optional) The name of the folder in the Git
               repository, that contains the template.
        :param str git_release: (optional) The name of the release tag that are
               used to fetch the Git repository.
        :param str git_branch: (optional) The name of the branch that are used to
               fetch the Git repository.
        :param **kwargs: (optional) Any additional properties.
        """
        self.computed_git_repo_url = computed_git_repo_url
        self.git_repo_url = git_repo_url
        self.git_token = git_token
        self.git_repo_folder = git_repo_folder
        self.git_release = git_release
        self.git_branch = git_branch
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ExternalSourceGit':
        """Initialize a ExternalSourceGit object from a json dictionary."""
        args = {}
        if 'computed_git_repo_url' in _dict:
            args['computed_git_repo_url'] = _dict.get('computed_git_repo_url')
        if 'git_repo_url' in _dict:
            args['git_repo_url'] = _dict.get('git_repo_url')
        if 'git_token' in _dict:
            args['git_token'] = _dict.get('git_token')
        if 'git_repo_folder' in _dict:
            args['git_repo_folder'] = _dict.get('git_repo_folder')
        if 'git_release' in _dict:
            args['git_release'] = _dict.get('git_release')
        if 'git_branch' in _dict:
            args['git_branch'] = _dict.get('git_branch')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ExternalSourceGit object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'computed_git_repo_url') and self.computed_git_repo_url is not None:
            _dict['computed_git_repo_url'] = self.computed_git_repo_url
        if hasattr(self, 'git_repo_url') and self.git_repo_url is not None:
            _dict['git_repo_url'] = self.git_repo_url
        if hasattr(self, 'git_token') and self.git_token is not None:
            _dict['git_token'] = self.git_token
        if hasattr(self, 'git_repo_folder') and self.git_repo_folder is not None:
            _dict['git_repo_folder'] = self.git_repo_folder
        if hasattr(self, 'git_release') and self.git_release is not None:
            _dict['git_release'] = self.git_release
        if hasattr(self, 'git_branch') and self.git_branch is not None:
            _dict['git_branch'] = self.git_branch
        for _key in [k for k in vars(self).keys() if k not in ExternalSourceGit._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ExternalSourceGit object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ExternalSourceGit') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ExternalSourceGit') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class InjectTerraformTemplateInnerTftParametersItem():
    """
    InjectTerraformTemplateInnerTftParametersItem.

    :attr str name: (optional) Key name to replace.
    :attr str value: (optional) Value to replace.
    """

    def __init__(self,
                 *,
                 name: str = None,
                 value: str = None) -> None:
        """
        Initialize a InjectTerraformTemplateInnerTftParametersItem object.

        :param str name: (optional) Key name to replace.
        :param str value: (optional) Value to replace.
        """
        self.name = name
        self.value = value

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'InjectTerraformTemplateInnerTftParametersItem':
        """Initialize a InjectTerraformTemplateInnerTftParametersItem object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a InjectTerraformTemplateInnerTftParametersItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this InjectTerraformTemplateInnerTftParametersItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'InjectTerraformTemplateInnerTftParametersItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'InjectTerraformTemplateInnerTftParametersItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class InjectTerraformTemplateInner():
    """
    InjectTerraformTemplateInner.

    :attr str tft_git_url: (optional) Git repo url hosting terraform template files.
    :attr str tft_git_token: (optional) Token to access the git repository
          (Optional).
    :attr str tft_prefix: (optional) Optional prefix word to append to files
          (Optional).
    :attr str injection_type: (optional) Injection type. Default is 'override'.
    :attr str tft_name: (optional) Terraform template name. Maps to folder name in
          git repo.
    :attr List[InjectTerraformTemplateInnerTftParametersItem] tft_parameters:
          (optional)
    """

    # The set of defined properties for the class
    _properties = frozenset(['tft_git_url', 'tft_git_token', 'tft_prefix', 'injection_type', 'tft_name', 'tft_parameters'])

    def __init__(self,
                 *,
                 tft_git_url: str = None,
                 tft_git_token: str = None,
                 tft_prefix: str = None,
                 injection_type: str = None,
                 tft_name: str = None,
                 tft_parameters: List['InjectTerraformTemplateInnerTftParametersItem'] = None,
                 **kwargs) -> None:
        """
        Initialize a InjectTerraformTemplateInner object.

        :param str tft_git_url: (optional) Git repo url hosting terraform template
               files.
        :param str tft_git_token: (optional) Token to access the git repository
               (Optional).
        :param str tft_prefix: (optional) Optional prefix word to append to files
               (Optional).
        :param str injection_type: (optional) Injection type. Default is
               'override'.
        :param str tft_name: (optional) Terraform template name. Maps to folder
               name in git repo.
        :param List[InjectTerraformTemplateInnerTftParametersItem] tft_parameters:
               (optional)
        :param **kwargs: (optional) Any additional properties.
        """
        self.tft_git_url = tft_git_url
        self.tft_git_token = tft_git_token
        self.tft_prefix = tft_prefix
        self.injection_type = injection_type
        self.tft_name = tft_name
        self.tft_parameters = tft_parameters
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'InjectTerraformTemplateInner':
        """Initialize a InjectTerraformTemplateInner object from a json dictionary."""
        args = {}
        if 'tft_git_url' in _dict:
            args['tft_git_url'] = _dict.get('tft_git_url')
        if 'tft_git_token' in _dict:
            args['tft_git_token'] = _dict.get('tft_git_token')
        if 'tft_prefix' in _dict:
            args['tft_prefix'] = _dict.get('tft_prefix')
        if 'injection_type' in _dict:
            args['injection_type'] = _dict.get('injection_type')
        if 'tft_name' in _dict:
            args['tft_name'] = _dict.get('tft_name')
        if 'tft_parameters' in _dict:
            args['tft_parameters'] = [InjectTerraformTemplateInnerTftParametersItem.from_dict(x) for x in _dict.get('tft_parameters')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a InjectTerraformTemplateInner object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'tft_git_url') and self.tft_git_url is not None:
            _dict['tft_git_url'] = self.tft_git_url
        if hasattr(self, 'tft_git_token') and self.tft_git_token is not None:
            _dict['tft_git_token'] = self.tft_git_token
        if hasattr(self, 'tft_prefix') and self.tft_prefix is not None:
            _dict['tft_prefix'] = self.tft_prefix
        if hasattr(self, 'injection_type') and self.injection_type is not None:
            _dict['injection_type'] = self.injection_type
        if hasattr(self, 'tft_name') and self.tft_name is not None:
            _dict['tft_name'] = self.tft_name
        if hasattr(self, 'tft_parameters') and self.tft_parameters is not None:
            _dict['tft_parameters'] = [x.to_dict() for x in self.tft_parameters]
        for _key in [k for k in vars(self).keys() if k not in InjectTerraformTemplateInner._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this InjectTerraformTemplateInner object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'InjectTerraformTemplateInner') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'InjectTerraformTemplateInner') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class InputVariableDataList():
    """
    List of Input variable data record response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[VariableData] inputs: (optional) List of input variables and values.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'inputs'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 inputs: List['VariableData'] = None,
                 **kwargs) -> None:
        """
        Initialize a InputVariableDataList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[VariableData] inputs: (optional) List of input variables and
               values.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.inputs = inputs
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'InputVariableDataList':
        """Initialize a InputVariableDataList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in InputVariableDataList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in InputVariableDataList JSON')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a InputVariableDataList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        for _key in [k for k in vars(self).keys() if k not in InputVariableDataList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this InputVariableDataList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'InputVariableDataList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'InputVariableDataList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class InventoryResourceDefinition():
    """
    Inventory definition.

    :attr str name: (optional) The unique name of your Inventory definition. The
          name can be up to 128 characters long and can include alphanumeric characters,
          spaces, dashes, and underscores.
    :attr str description: (optional) The description of your Inventory definition.
          The description can be up to 2048 characters long in size.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str resource_group: (optional) Resource-group name for the Inventory
          definition.   By default, Inventory definition will be created in Default
          Resource Group.
    :attr str inventories_ini: (optional) Input inventory of host and host group for
          the playbook, in the `.ini` file format.
    :attr List[str] resource_queries: (optional) Input resource query definitions
          that is used to dynamically generate the inventory of host and host group for
          the playbook.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'location', 'resource_group', 'inventories_ini', 'resource_queries'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 location: str = None,
                 resource_group: str = None,
                 inventories_ini: str = None,
                 resource_queries: List[str] = None,
                 **kwargs) -> None:
        """
        Initialize a InventoryResourceDefinition object.

        :param str name: (optional) The unique name of your Inventory definition.
               The name can be up to 128 characters long and can include alphanumeric
               characters, spaces, dashes, and underscores.
        :param str description: (optional) The description of your Inventory
               definition. The description can be up to 2048 characters long in size.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for the Inventory
               definition.   By default, Inventory definition will be created in Default
               Resource Group.
        :param str inventories_ini: (optional) Input inventory of host and host
               group for the playbook, in the `.ini` file format.
        :param List[str] resource_queries: (optional) Input resource query
               definitions that is used to dynamically generate the inventory of host and
               host group for the playbook.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.location = location
        self.resource_group = resource_group
        self.inventories_ini = inventories_ini
        self.resource_queries = resource_queries
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'InventoryResourceDefinition':
        """Initialize a InventoryResourceDefinition object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'inventories_ini' in _dict:
            args['inventories_ini'] = _dict.get('inventories_ini')
        if 'resource_queries' in _dict:
            args['resource_queries'] = _dict.get('resource_queries')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a InventoryResourceDefinition object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'inventories_ini') and self.inventories_ini is not None:
            _dict['inventories_ini'] = self.inventories_ini
        if hasattr(self, 'resource_queries') and self.resource_queries is not None:
            _dict['resource_queries'] = self.resource_queries
        for _key in [k for k in vars(self).keys() if k not in InventoryResourceDefinition._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this InventoryResourceDefinition object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'InventoryResourceDefinition') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'InventoryResourceDefinition') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class InventoryResourceRecord():
    """
    Complete inventory definition details.

    :attr str name: (optional) The unique name of your Inventory.  The name can be
          up to 128 characters long and can include alphanumeric  characters, spaces,
          dashes, and underscores.
    :attr str id: (optional) Inventory id.
    :attr str description: (optional) The description of your Inventory.  The
          description can be up to 2048 characters long in size.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str resource_group: (optional) Resource-group name for the Inventory
          definition.  By default, Inventory will be created in Default Resource Group.
    :attr datetime created_at: (optional) Inventory creation time.
    :attr str created_by: (optional) Email address of user who created the
          Inventory.
    :attr datetime updated_at: (optional) Inventory updation time.
    :attr str updated_by: (optional) Email address of user who updated the
          Inventory.
    :attr str inventories_ini: (optional) Input inventory of host and host group for
          the playbook,  in the .ini file format.
    :attr List[str] resource_queries: (optional) Input resource queries that is used
          to dynamically generate  the inventory of host and host group for the playbook.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'id', 'description', 'location', 'resource_group', 'created_at', 'created_by', 'updated_at', 'updated_by', 'inventories_ini', 'resource_queries'])

    def __init__(self,
                 *,
                 name: str = None,
                 id: str = None,
                 description: str = None,
                 location: str = None,
                 resource_group: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 inventories_ini: str = None,
                 resource_queries: List[str] = None,
                 **kwargs) -> None:
        """
        Initialize a InventoryResourceRecord object.

        :param str name: (optional) The unique name of your Inventory.  The name
               can be up to 128 characters long and can include alphanumeric  characters,
               spaces, dashes, and underscores.
        :param str description: (optional) The description of your Inventory.  The
               description can be up to 2048 characters long in size.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for the Inventory
               definition.  By default, Inventory will be created in Default Resource
               Group.
        :param str inventories_ini: (optional) Input inventory of host and host
               group for the playbook,  in the .ini file format.
        :param List[str] resource_queries: (optional) Input resource queries that
               is used to dynamically generate  the inventory of host and host group for
               the playbook.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.id = id
        self.description = description
        self.location = location
        self.resource_group = resource_group
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.inventories_ini = inventories_ini
        self.resource_queries = resource_queries
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'InventoryResourceRecord':
        """Initialize a InventoryResourceRecord object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'inventories_ini' in _dict:
            args['inventories_ini'] = _dict.get('inventories_ini')
        if 'resource_queries' in _dict:
            args['resource_queries'] = _dict.get('resource_queries')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a InventoryResourceRecord object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'inventories_ini') and self.inventories_ini is not None:
            _dict['inventories_ini'] = self.inventories_ini
        if hasattr(self, 'resource_queries') and self.resource_queries is not None:
            _dict['resource_queries'] = self.resource_queries
        for _key in [k for k in vars(self).keys() if k not in InventoryResourceRecord._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this InventoryResourceRecord object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'InventoryResourceRecord') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'InventoryResourceRecord') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class InventoryResourceRecordList():
    """
    List of Inventory definition records.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[InventoryResourceRecord] inventories: (optional) List of inventory
          definition records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'inventories'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 inventories: List['InventoryResourceRecord'] = None,
                 **kwargs) -> None:
        """
        Initialize a InventoryResourceRecordList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[InventoryResourceRecord] inventories: (optional) List of
               inventory definition records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.inventories = inventories
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'InventoryResourceRecordList':
        """Initialize a InventoryResourceRecordList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in InventoryResourceRecordList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in InventoryResourceRecordList JSON')
        if 'inventories' in _dict:
            args['inventories'] = [InventoryResourceRecord.from_dict(x) for x in _dict.get('inventories')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a InventoryResourceRecordList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'inventories') and self.inventories is not None:
            _dict['inventories'] = [x.to_dict() for x in self.inventories]
        for _key in [k for k in vars(self).keys() if k not in InventoryResourceRecordList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this InventoryResourceRecordList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'InventoryResourceRecordList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'InventoryResourceRecordList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ItemMetadata():
    """
    Variables and operations metadata of the catalog item.  Variable metadata will be
    fetched from the template in the repo. Operations metadata will be fetched from
    metadataFileName in the repo.

    :attr str item_id: (optional) Catalog item Id.
    :attr str offering_id: offering Id.
    :attr str offering_kind_id: (optional) Offering kind id.
    :attr str offering_version_id: Offering version id.
    :attr str name: (optional) Catalog item name.
    :attr str description: (optional) Catalog item description.
    :attr List[str] operations: (optional) List of supported operation.
    :attr List[VariableData] inputs: (optional) Input variables metadata.
    :attr List[VariableData] settings: (optional) Input environment variables
          metadata.
    :attr List[VariableData] outputs: (optional) Output variables metadata.
    """

    # The set of defined properties for the class
    _properties = frozenset(['item_id', 'offering_id', 'offering_kind_id', 'offering_version_id', 'name', 'description', 'operations', 'inputs', 'settings', 'outputs'])

    def __init__(self,
                 offering_id: str,
                 offering_version_id: str,
                 *,
                 item_id: str = None,
                 offering_kind_id: str = None,
                 name: str = None,
                 description: str = None,
                 operations: List[str] = None,
                 inputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 outputs: List['VariableData'] = None,
                 **kwargs) -> None:
        """
        Initialize a ItemMetadata object.

        :param str offering_id: offering Id.
        :param str offering_version_id: Offering version id.
        :param str item_id: (optional) Catalog item Id.
        :param str offering_kind_id: (optional) Offering kind id.
        :param str name: (optional) Catalog item name.
        :param str description: (optional) Catalog item description.
        :param List[str] operations: (optional) List of supported operation.
        :param List[VariableData] inputs: (optional) Input variables metadata.
        :param List[VariableData] settings: (optional) Input environment variables
               metadata.
        :param List[VariableData] outputs: (optional) Output variables metadata.
        :param **kwargs: (optional) Any additional properties.
        """
        self.item_id = item_id
        self.offering_id = offering_id
        self.offering_kind_id = offering_kind_id
        self.offering_version_id = offering_version_id
        self.name = name
        self.description = description
        self.operations = operations
        self.inputs = inputs
        self.settings = settings
        self.outputs = outputs
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ItemMetadata':
        """Initialize a ItemMetadata object from a json dictionary."""
        args = {}
        if 'item_id' in _dict:
            args['item_id'] = _dict.get('item_id')
        if 'offering_id' in _dict:
            args['offering_id'] = _dict.get('offering_id')
        else:
            raise ValueError('Required property \'offering_id\' not present in ItemMetadata JSON')
        if 'offering_kind_id' in _dict:
            args['offering_kind_id'] = _dict.get('offering_kind_id')
        if 'offering_version_id' in _dict:
            args['offering_version_id'] = _dict.get('offering_version_id')
        else:
            raise ValueError('Required property \'offering_version_id\' not present in ItemMetadata JSON')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'operations' in _dict:
            args['operations'] = _dict.get('operations')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ItemMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'item_id') and self.item_id is not None:
            _dict['item_id'] = self.item_id
        if hasattr(self, 'offering_id') and self.offering_id is not None:
            _dict['offering_id'] = self.offering_id
        if hasattr(self, 'offering_kind_id') and self.offering_kind_id is not None:
            _dict['offering_kind_id'] = self.offering_kind_id
        if hasattr(self, 'offering_version_id') and self.offering_version_id is not None:
            _dict['offering_version_id'] = self.offering_version_id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'operations') and self.operations is not None:
            _dict['operations'] = self.operations
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        for _key in [k for k in vars(self).keys() if k not in ItemMetadata._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ItemMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ItemMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ItemMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class OperationsEnum(str, Enum):
        """
        Name of the fulfilment job operations.
        """
        CONFIGURE = 'configure'
        DESTROY = 'destroy'
        DRYRUN = 'dryrun'
        INSTALL = 'install'
        OPERATE = 'operate'
        PREVIEW = 'preview'
        UNINSTALL = 'uninstall'
        UPDATE = 'update'


class ItemSKU():
    """
    Store Keeping Unit for the Item in the Cart order.

    :attr str sku_id: The ID of the underlying SKU object.
    :attr str sku_type: SKU Type - Workspace / Ansible.
    :attr SystemLock sku_sys_lock: (optional) System lock status.
    :attr SKUUserState sku_user_state: (optional) Status of the underlying
          schematics objects used to fullfil CartOrder.
    """

    # The set of defined properties for the class
    _properties = frozenset(['sku_id', 'sku_type', 'sku_sys_lock', 'sku_user_state'])

    def __init__(self,
                 sku_id: str,
                 sku_type: str,
                 *,
                 sku_sys_lock: 'SystemLock' = None,
                 sku_user_state: 'SKUUserState' = None,
                 **kwargs) -> None:
        """
        Initialize a ItemSKU object.

        :param str sku_id: The ID of the underlying SKU object.
        :param str sku_type: SKU Type - Workspace / Ansible.
        :param SystemLock sku_sys_lock: (optional) System lock status.
        :param SKUUserState sku_user_state: (optional) Status of the underlying
               schematics objects used to fullfil CartOrder.
        :param **kwargs: (optional) Any additional properties.
        """
        self.sku_id = sku_id
        self.sku_type = sku_type
        self.sku_sys_lock = sku_sys_lock
        self.sku_user_state = sku_user_state
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ItemSKU':
        """Initialize a ItemSKU object from a json dictionary."""
        args = {}
        if 'sku_id' in _dict:
            args['sku_id'] = _dict.get('sku_id')
        else:
            raise ValueError('Required property \'sku_id\' not present in ItemSKU JSON')
        if 'sku_type' in _dict:
            args['sku_type'] = _dict.get('sku_type')
        else:
            raise ValueError('Required property \'sku_type\' not present in ItemSKU JSON')
        if 'sku_sys_lock' in _dict:
            args['sku_sys_lock'] = SystemLock.from_dict(_dict.get('sku_sys_lock'))
        if 'sku_user_state' in _dict:
            args['sku_user_state'] = SKUUserState.from_dict(_dict.get('sku_user_state'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ItemSKU object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'sku_id') and self.sku_id is not None:
            _dict['sku_id'] = self.sku_id
        if hasattr(self, 'sku_type') and self.sku_type is not None:
            _dict['sku_type'] = self.sku_type
        if hasattr(self, 'sku_sys_lock') and self.sku_sys_lock is not None:
            _dict['sku_sys_lock'] = self.sku_sys_lock.to_dict()
        if hasattr(self, 'sku_user_state') and self.sku_user_state is not None:
            _dict['sku_user_state'] = self.sku_user_state.to_dict()
        for _key in [k for k in vars(self).keys() if k not in ItemSKU._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ItemSKU object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ItemSKU') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ItemSKU') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class Job():
    """
    Complete Job with user inputs and system generated data.

    :attr str command_object: (optional) Name of the Schematics automation resource.
    :attr str command_object_id: (optional) Job command object id (workspace-id,
          action-id).
    :attr str command_name: (optional) Schematics job command name.
    :attr str command_parameter: (optional) Schematics job command parameter
          (playbook-name).
    :attr List[str] command_options: (optional) Command line options for the
          command.
    :attr List[VariableData] inputs: (optional) Job inputs used by Action or
          Workspace.
    :attr List[VariableData] settings: (optional) Environment variables used by the
          Job while performing Action or Workspace.
    :attr List[str] tags: (optional) User defined tags, while running the job.
    :attr str id: (optional) Job ID.
    :attr str name: (optional) Job name, uniquely derived from the related Workspace
          or Action.
    :attr str description: (optional) The description of your job is derived from
          the related action or workspace.  The description can be up to 2048 characters
          long in size.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str resource_group: (optional) Resource-group name derived from the
          related Workspace or Action.
    :attr datetime submitted_at: (optional) Job submission time.
    :attr str submitted_by: (optional) Email address of user who submitted the job.
    :attr datetime start_at: (optional) Job start time.
    :attr datetime end_at: (optional) Job end time.
    :attr str duration: (optional) Duration of job execution; example 40 sec.
    :attr JobStatus status: (optional) Job Status.
    :attr JobData data: (optional) Job data.
    :attr BastionResourceDefinition bastion: (optional) Describes a bastion
          resource.
    :attr JobLogSummary log_summary: (optional) Job log summary record.
    :attr str log_store_url: (optional) Job log store URL.
    :attr str state_store_url: (optional) Job state store URL.
    :attr str results_url: (optional) Job results store URL.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    :attr str job_runner_id: (optional) ID of the Job Runner.
    """

    # The set of defined properties for the class
    _properties = frozenset(['command_object', 'command_object_id', 'command_name', 'command_parameter', 'command_options', 'inputs', 'settings', 'tags', 'id', 'name', 'description', 'location', 'resource_group', 'submitted_at', 'submitted_by', 'start_at', 'end_at', 'duration', 'status', 'data', 'bastion', 'log_summary', 'log_store_url', 'state_store_url', 'results_url', 'updated_at', 'job_runner_id'])

    def __init__(self,
                 *,
                 command_object: str = None,
                 command_object_id: str = None,
                 command_name: str = None,
                 command_parameter: str = None,
                 command_options: List[str] = None,
                 inputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 tags: List[str] = None,
                 id: str = None,
                 name: str = None,
                 description: str = None,
                 location: str = None,
                 resource_group: str = None,
                 submitted_at: datetime = None,
                 submitted_by: str = None,
                 start_at: datetime = None,
                 end_at: datetime = None,
                 duration: str = None,
                 status: 'JobStatus' = None,
                 data: 'JobData' = None,
                 bastion: 'BastionResourceDefinition' = None,
                 log_summary: 'JobLogSummary' = None,
                 log_store_url: str = None,
                 state_store_url: str = None,
                 results_url: str = None,
                 updated_at: datetime = None,
                 job_runner_id: str = None,
                 **kwargs) -> None:
        """
        Initialize a Job object.

        :param str command_object: (optional) Name of the Schematics automation
               resource.
        :param str command_object_id: (optional) Job command object id
               (workspace-id, action-id).
        :param str command_name: (optional) Schematics job command name.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name).
        :param List[str] command_options: (optional) Command line options for the
               command.
        :param List[VariableData] inputs: (optional) Job inputs used by Action or
               Workspace.
        :param List[VariableData] settings: (optional) Environment variables used
               by the Job while performing Action or Workspace.
        :param List[str] tags: (optional) User defined tags, while running the job.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param JobStatus status: (optional) Job Status.
        :param JobData data: (optional) Job data.
        :param BastionResourceDefinition bastion: (optional) Describes a bastion
               resource.
        :param JobLogSummary log_summary: (optional) Job log summary record.
        :param **kwargs: (optional) Any additional properties.
        """
        self.command_object = command_object
        self.command_object_id = command_object_id
        self.command_name = command_name
        self.command_parameter = command_parameter
        self.command_options = command_options
        self.inputs = inputs
        self.settings = settings
        self.tags = tags
        self.id = id
        self.name = name
        self.description = description
        self.location = location
        self.resource_group = resource_group
        self.submitted_at = submitted_at
        self.submitted_by = submitted_by
        self.start_at = start_at
        self.end_at = end_at
        self.duration = duration
        self.status = status
        self.data = data
        self.bastion = bastion
        self.log_summary = log_summary
        self.log_store_url = log_store_url
        self.state_store_url = state_store_url
        self.results_url = results_url
        self.updated_at = updated_at
        self.job_runner_id = job_runner_id
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Job':
        """Initialize a Job object from a json dictionary."""
        args = {}
        if 'command_object' in _dict:
            args['command_object'] = _dict.get('command_object')
        if 'command_object_id' in _dict:
            args['command_object_id'] = _dict.get('command_object_id')
        if 'command_name' in _dict:
            args['command_name'] = _dict.get('command_name')
        if 'command_parameter' in _dict:
            args['command_parameter'] = _dict.get('command_parameter')
        if 'command_options' in _dict:
            args['command_options'] = _dict.get('command_options')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'submitted_at' in _dict:
            args['submitted_at'] = string_to_datetime(_dict.get('submitted_at'))
        if 'submitted_by' in _dict:
            args['submitted_by'] = _dict.get('submitted_by')
        if 'start_at' in _dict:
            args['start_at'] = string_to_datetime(_dict.get('start_at'))
        if 'end_at' in _dict:
            args['end_at'] = string_to_datetime(_dict.get('end_at'))
        if 'duration' in _dict:
            args['duration'] = _dict.get('duration')
        if 'status' in _dict:
            args['status'] = JobStatus.from_dict(_dict.get('status'))
        if 'data' in _dict:
            args['data'] = JobData.from_dict(_dict.get('data'))
        if 'bastion' in _dict:
            args['bastion'] = BastionResourceDefinition.from_dict(_dict.get('bastion'))
        if 'log_summary' in _dict:
            args['log_summary'] = JobLogSummary.from_dict(_dict.get('log_summary'))
        if 'log_store_url' in _dict:
            args['log_store_url'] = _dict.get('log_store_url')
        if 'state_store_url' in _dict:
            args['state_store_url'] = _dict.get('state_store_url')
        if 'results_url' in _dict:
            args['results_url'] = _dict.get('results_url')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'job_runner_id' in _dict:
            args['job_runner_id'] = _dict.get('job_runner_id')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Job object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command_object') and self.command_object is not None:
            _dict['command_object'] = self.command_object
        if hasattr(self, 'command_object_id') and self.command_object_id is not None:
            _dict['command_object_id'] = self.command_object_id
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'command_parameter') and self.command_parameter is not None:
            _dict['command_parameter'] = self.command_parameter
        if hasattr(self, 'command_options') and self.command_options is not None:
            _dict['command_options'] = self.command_options
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'description') and getattr(self, 'description') is not None:
            _dict['description'] = getattr(self, 'description')
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and getattr(self, 'resource_group') is not None:
            _dict['resource_group'] = getattr(self, 'resource_group')
        if hasattr(self, 'submitted_at') and getattr(self, 'submitted_at') is not None:
            _dict['submitted_at'] = datetime_to_string(getattr(self, 'submitted_at'))
        if hasattr(self, 'submitted_by') and getattr(self, 'submitted_by') is not None:
            _dict['submitted_by'] = getattr(self, 'submitted_by')
        if hasattr(self, 'start_at') and getattr(self, 'start_at') is not None:
            _dict['start_at'] = datetime_to_string(getattr(self, 'start_at'))
        if hasattr(self, 'end_at') and getattr(self, 'end_at') is not None:
            _dict['end_at'] = datetime_to_string(getattr(self, 'end_at'))
        if hasattr(self, 'duration') and getattr(self, 'duration') is not None:
            _dict['duration'] = getattr(self, 'duration')
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status.to_dict()
        if hasattr(self, 'data') and self.data is not None:
            _dict['data'] = self.data.to_dict()
        if hasattr(self, 'bastion') and self.bastion is not None:
            _dict['bastion'] = self.bastion.to_dict()
        if hasattr(self, 'log_summary') and self.log_summary is not None:
            _dict['log_summary'] = self.log_summary.to_dict()
        if hasattr(self, 'log_store_url') and getattr(self, 'log_store_url') is not None:
            _dict['log_store_url'] = getattr(self, 'log_store_url')
        if hasattr(self, 'state_store_url') and getattr(self, 'state_store_url') is not None:
            _dict['state_store_url'] = getattr(self, 'state_store_url')
        if hasattr(self, 'results_url') and getattr(self, 'results_url') is not None:
            _dict['results_url'] = getattr(self, 'results_url')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'job_runner_id') and getattr(self, 'job_runner_id') is not None:
            _dict['job_runner_id'] = getattr(self, 'job_runner_id')
        for _key in [k for k in vars(self).keys() if k not in Job._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Job object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Job') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Job') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class CommandObjectEnum(str, Enum):
        """
        Name of the Schematics automation resource.
        """
        WORKSPACE = 'workspace'
        ACTION = 'action'
        SYSTEM = 'system'
        ENVIRONMENT = 'environment'


    class CommandNameEnum(str, Enum):
        """
        Schematics job command name.
        """
        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        CREATE_ENVIRONMENT = 'create_environment'
        PUT_ENVIRONMENT = 'put_environment'
        DELETE_ENVIRONMENT = 'delete_environment'
        ENVIRONMENT_INIT = 'environment_init'
        ENVIRONMENT_INSTALL = 'environment_install'
        ENVIRONMENT_UNINSTALL = 'environment_uninstall'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'


    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class JobData():
    """
    Job data.

    :attr str job_type: Type of Job.
    :attr JobDataWorkspace workspace_job_data: (optional) Workspace Job data.
    :attr JobDataAction action_job_data: (optional) Action Job data.
    :attr JobDataSystem system_job_data: (optional) Controls Job data.
    :attr JobDataFlow flow_job_data: (optional) Flow Job data.
    """

    # The set of defined properties for the class
    _properties = frozenset(['job_type', 'workspace_job_data', 'action_job_data', 'system_job_data', 'flow_job_data'])

    def __init__(self,
                 job_type: str,
                 *,
                 workspace_job_data: 'JobDataWorkspace' = None,
                 action_job_data: 'JobDataAction' = None,
                 system_job_data: 'JobDataSystem' = None,
                 flow_job_data: 'JobDataFlow' = None,
                 **kwargs) -> None:
        """
        Initialize a JobData object.

        :param str job_type: Type of Job.
        :param JobDataWorkspace workspace_job_data: (optional) Workspace Job data.
        :param JobDataAction action_job_data: (optional) Action Job data.
        :param JobDataSystem system_job_data: (optional) Controls Job data.
        :param JobDataFlow flow_job_data: (optional) Flow Job data.
        :param **kwargs: (optional) Any additional properties.
        """
        self.job_type = job_type
        self.workspace_job_data = workspace_job_data
        self.action_job_data = action_job_data
        self.system_job_data = system_job_data
        self.flow_job_data = flow_job_data
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobData':
        """Initialize a JobData object from a json dictionary."""
        args = {}
        if 'job_type' in _dict:
            args['job_type'] = _dict.get('job_type')
        else:
            raise ValueError('Required property \'job_type\' not present in JobData JSON')
        if 'workspace_job_data' in _dict:
            args['workspace_job_data'] = JobDataWorkspace.from_dict(_dict.get('workspace_job_data'))
        if 'action_job_data' in _dict:
            args['action_job_data'] = JobDataAction.from_dict(_dict.get('action_job_data'))
        if 'system_job_data' in _dict:
            args['system_job_data'] = JobDataSystem.from_dict(_dict.get('system_job_data'))
        if 'flow_job_data' in _dict:
            args['flow_job_data'] = JobDataFlow.from_dict(_dict.get('flow_job_data'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job_type') and self.job_type is not None:
            _dict['job_type'] = self.job_type
        if hasattr(self, 'workspace_job_data') and self.workspace_job_data is not None:
            _dict['workspace_job_data'] = self.workspace_job_data.to_dict()
        if hasattr(self, 'action_job_data') and self.action_job_data is not None:
            _dict['action_job_data'] = self.action_job_data.to_dict()
        if hasattr(self, 'system_job_data') and self.system_job_data is not None:
            _dict['system_job_data'] = self.system_job_data.to_dict()
        if hasattr(self, 'flow_job_data') and self.flow_job_data is not None:
            _dict['flow_job_data'] = self.flow_job_data.to_dict()
        for _key in [k for k in vars(self).keys() if k not in JobData._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class JobTypeEnum(str, Enum):
        """
        Type of Job.
        """
        REPO_DOWNLOAD_JOB = 'repo_download_job'
        WORKSPACE_JOB = 'workspace_job'
        ACTION_JOB = 'action_job'
        SYSTEM_JOB = 'system_job'
        FLOW_JOB = 'flow-job'


class JobDataAction():
    """
    Action Job data.

    :attr str action_name: (optional) Flow name.
    :attr List[VariableData] inputs: (optional) Input variables data used by the
          Action Job.
    :attr List[VariableData] outputs: (optional) Output variables data from the
          Action Job.
    :attr List[VariableData] settings: (optional) Environment variables used by all
          the templates in the Action.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    :attr InventoryResourceRecord inventory_record: (optional) Complete inventory
          definition details.
    :attr str materialized_inventory: (optional) Materialized inventory details used
          by the Action Job, in .ini format.
    """

    # The set of defined properties for the class
    _properties = frozenset(['action_name', 'inputs', 'outputs', 'settings', 'updated_at', 'inventory_record', 'materialized_inventory'])

    def __init__(self,
                 *,
                 action_name: str = None,
                 inputs: List['VariableData'] = None,
                 outputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 updated_at: datetime = None,
                 inventory_record: 'InventoryResourceRecord' = None,
                 materialized_inventory: str = None,
                 **kwargs) -> None:
        """
        Initialize a JobDataAction object.

        :param str action_name: (optional) Flow name.
        :param List[VariableData] inputs: (optional) Input variables data used by
               the Action Job.
        :param List[VariableData] outputs: (optional) Output variables data from
               the Action Job.
        :param List[VariableData] settings: (optional) Environment variables used
               by all the templates in the Action.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param InventoryResourceRecord inventory_record: (optional) Complete
               inventory definition details.
        :param str materialized_inventory: (optional) Materialized inventory
               details used by the Action Job, in .ini format.
        :param **kwargs: (optional) Any additional properties.
        """
        self.action_name = action_name
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.updated_at = updated_at
        self.inventory_record = inventory_record
        self.materialized_inventory = materialized_inventory
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataAction':
        """Initialize a JobDataAction object from a json dictionary."""
        args = {}
        if 'action_name' in _dict:
            args['action_name'] = _dict.get('action_name')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'inventory_record' in _dict:
            args['inventory_record'] = InventoryResourceRecord.from_dict(_dict.get('inventory_record'))
        if 'materialized_inventory' in _dict:
            args['materialized_inventory'] = _dict.get('materialized_inventory')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataAction object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_name') and self.action_name is not None:
            _dict['action_name'] = self.action_name
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'inventory_record') and self.inventory_record is not None:
            _dict['inventory_record'] = self.inventory_record.to_dict()
        if hasattr(self, 'materialized_inventory') and self.materialized_inventory is not None:
            _dict['materialized_inventory'] = self.materialized_inventory
        for _key in [k for k in vars(self).keys() if k not in JobDataAction._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataAction object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataAction') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataAction') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobDataCapsule():
    """
    Capsule Job data.

    :attr str capsule_id: (optional) Capsule Id.
    :attr str calsule_name: (optional) Capsule name.
    :attr List[VariableData] inputs: (optional) Input variables data used by the
          Controls Job.
    :attr List[JobResultCapsule] results: (optional) Results from the Capsules Job.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['capsule_id', 'calsule_name', 'inputs', 'results', 'updated_at'])

    def __init__(self,
                 *,
                 capsule_id: str = None,
                 calsule_name: str = None,
                 inputs: List['VariableData'] = None,
                 results: List['JobResultCapsule'] = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobDataCapsule object.

        :param str capsule_id: (optional) Capsule Id.
        :param str calsule_name: (optional) Capsule name.
        :param List[VariableData] inputs: (optional) Input variables data used by
               the Controls Job.
        :param List[JobResultCapsule] results: (optional) Results from the Capsules
               Job.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.capsule_id = capsule_id
        self.calsule_name = calsule_name
        self.inputs = inputs
        self.results = results
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataCapsule':
        """Initialize a JobDataCapsule object from a json dictionary."""
        args = {}
        if 'capsule_id' in _dict:
            args['capsule_id'] = _dict.get('capsule_id')
        if 'calsule_name' in _dict:
            args['calsule_name'] = _dict.get('calsule_name')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'results' in _dict:
            args['results'] = [JobResultCapsule.from_dict(x) for x in _dict.get('results')]
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataCapsule object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'capsule_id') and self.capsule_id is not None:
            _dict['capsule_id'] = self.capsule_id
        if hasattr(self, 'calsule_name') and self.calsule_name is not None:
            _dict['calsule_name'] = self.calsule_name
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'results') and self.results is not None:
            _dict['results'] = [x.to_dict() for x in self.results]
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobDataCapsule._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataCapsule object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataCapsule') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataCapsule') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobDataFlow():
    """
    Flow Job data.

    :attr str flow_id: (optional) Flow ID.
    :attr str flow_name: (optional) Flow Name.
    :attr List[JobDataWorkItem] workitems: (optional) Job data used by each workitem
          Job.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['flow_id', 'flow_name', 'workitems', 'updated_at'])

    def __init__(self,
                 *,
                 flow_id: str = None,
                 flow_name: str = None,
                 workitems: List['JobDataWorkItem'] = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobDataFlow object.

        :param str flow_id: (optional) Flow ID.
        :param str flow_name: (optional) Flow Name.
        :param List[JobDataWorkItem] workitems: (optional) Job data used by each
               workitem Job.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.flow_id = flow_id
        self.flow_name = flow_name
        self.workitems = workitems
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataFlow':
        """Initialize a JobDataFlow object from a json dictionary."""
        args = {}
        if 'flow_id' in _dict:
            args['flow_id'] = _dict.get('flow_id')
        if 'flow_name' in _dict:
            args['flow_name'] = _dict.get('flow_name')
        if 'workitems' in _dict:
            args['workitems'] = [JobDataWorkItem.from_dict(x) for x in _dict.get('workitems')]
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataFlow object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'flow_id') and self.flow_id is not None:
            _dict['flow_id'] = self.flow_id
        if hasattr(self, 'flow_name') and self.flow_name is not None:
            _dict['flow_name'] = self.flow_name
        if hasattr(self, 'workitems') and self.workitems is not None:
            _dict['workitems'] = [x.to_dict() for x in self.workitems]
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobDataFlow._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataFlow object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataFlow') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataFlow') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobDataSystem():
    """
    Controls Job data.

    :attr str key_id: (optional) Key ID for which key event is generated.
    :attr List[str] schematics_resource_id: (optional) List of the schematics
          resource id.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['key_id', 'schematics_resource_id', 'updated_at'])

    def __init__(self,
                 *,
                 key_id: str = None,
                 schematics_resource_id: List[str] = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobDataSystem object.

        :param str key_id: (optional) Key ID for which key event is generated.
        :param List[str] schematics_resource_id: (optional) List of the schematics
               resource id.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.key_id = key_id
        self.schematics_resource_id = schematics_resource_id
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataSystem':
        """Initialize a JobDataSystem object from a json dictionary."""
        args = {}
        if 'key_id' in _dict:
            args['key_id'] = _dict.get('key_id')
        if 'schematics_resource_id' in _dict:
            args['schematics_resource_id'] = _dict.get('schematics_resource_id')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataSystem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'key_id') and self.key_id is not None:
            _dict['key_id'] = self.key_id
        if hasattr(self, 'schematics_resource_id') and self.schematics_resource_id is not None:
            _dict['schematics_resource_id'] = self.schematics_resource_id
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobDataSystem._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataSystem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataSystem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataSystem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobDataTemplate():
    """
    Template Job data.

    :attr str template_id: (optional) Template Id.
    :attr str template_name: (optional) Template name.
    :attr int flow_index: (optional) Index of the template in the Flow.
    :attr List[VariableData] inputs: (optional) Job inputs used by the Templates.
    :attr List[VariableData] outputs: (optional) Job output from the Templates.
    :attr List[VariableData] settings: (optional) Environment variables used by the
          template.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['template_id', 'template_name', 'flow_index', 'inputs', 'outputs', 'settings', 'updated_at'])

    def __init__(self,
                 *,
                 template_id: str = None,
                 template_name: str = None,
                 flow_index: int = None,
                 inputs: List['VariableData'] = None,
                 outputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobDataTemplate object.

        :param str template_id: (optional) Template Id.
        :param str template_name: (optional) Template name.
        :param int flow_index: (optional) Index of the template in the Flow.
        :param List[VariableData] inputs: (optional) Job inputs used by the
               Templates.
        :param List[VariableData] outputs: (optional) Job output from the
               Templates.
        :param List[VariableData] settings: (optional) Environment variables used
               by the template.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.template_id = template_id
        self.template_name = template_name
        self.flow_index = flow_index
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataTemplate':
        """Initialize a JobDataTemplate object from a json dictionary."""
        args = {}
        if 'template_id' in _dict:
            args['template_id'] = _dict.get('template_id')
        if 'template_name' in _dict:
            args['template_name'] = _dict.get('template_name')
        if 'flow_index' in _dict:
            args['flow_index'] = _dict.get('flow_index')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataTemplate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'template_id') and self.template_id is not None:
            _dict['template_id'] = self.template_id
        if hasattr(self, 'template_name') and self.template_name is not None:
            _dict['template_name'] = self.template_name
        if hasattr(self, 'flow_index') and self.flow_index is not None:
            _dict['flow_index'] = self.flow_index
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobDataTemplate._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataTemplate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataTemplate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataTemplate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobDataWorkItem():
    """
    Environment work items.

    :attr str command_object_id: (optional) command object id.
    :attr str command_object_name: (optional) command object name.
    :attr str layers: (optional) layer name.
    :attr str source_type: (optional) Type of source for the Template.
    :attr ExternalSource source: (optional) Source of templates, playbooks, or
          controls.
    :attr List[VariableData] inputs: (optional) Input variables data for the
          workItem used in FlowJob.
    :attr List[VariableData] outputs: (optional) Output variables for the workItem.
    :attr List[VariableData] settings: (optional) Environment variables for the
          workItem.
    :attr JobDataWorkItemLastJob last_job: (optional) Status of the last job
          executed by the workitem.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['command_object_id', 'command_object_name', 'layers', 'source_type', 'source', 'inputs', 'outputs', 'settings', 'last_job', 'updated_at'])

    def __init__(self,
                 *,
                 command_object_id: str = None,
                 command_object_name: str = None,
                 layers: str = None,
                 source_type: str = None,
                 source: 'ExternalSource' = None,
                 inputs: List['VariableData'] = None,
                 outputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 last_job: 'JobDataWorkItemLastJob' = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobDataWorkItem object.

        :param str command_object_id: (optional) command object id.
        :param str command_object_name: (optional) command object name.
        :param str layers: (optional) layer name.
        :param str source_type: (optional) Type of source for the Template.
        :param ExternalSource source: (optional) Source of templates, playbooks, or
               controls.
        :param List[VariableData] inputs: (optional) Input variables data for the
               workItem used in FlowJob.
        :param List[VariableData] outputs: (optional) Output variables for the
               workItem.
        :param List[VariableData] settings: (optional) Environment variables for
               the workItem.
        :param JobDataWorkItemLastJob last_job: (optional) Status of the last job
               executed by the workitem.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.command_object_id = command_object_id
        self.command_object_name = command_object_name
        self.layers = layers
        self.source_type = source_type
        self.source = source
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.last_job = last_job
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataWorkItem':
        """Initialize a JobDataWorkItem object from a json dictionary."""
        args = {}
        if 'command_object_id' in _dict:
            args['command_object_id'] = _dict.get('command_object_id')
        if 'command_object_name' in _dict:
            args['command_object_name'] = _dict.get('command_object_name')
        if 'layers' in _dict:
            args['layers'] = _dict.get('layers')
        if 'source_type' in _dict:
            args['source_type'] = _dict.get('source_type')
        if 'source' in _dict:
            args['source'] = ExternalSource.from_dict(_dict.get('source'))
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'last_job' in _dict:
            args['last_job'] = JobDataWorkItemLastJob.from_dict(_dict.get('last_job'))
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataWorkItem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command_object_id') and self.command_object_id is not None:
            _dict['command_object_id'] = self.command_object_id
        if hasattr(self, 'command_object_name') and self.command_object_name is not None:
            _dict['command_object_name'] = self.command_object_name
        if hasattr(self, 'layers') and self.layers is not None:
            _dict['layers'] = self.layers
        if hasattr(self, 'source_type') and self.source_type is not None:
            _dict['source_type'] = self.source_type
        if hasattr(self, 'source') and self.source is not None:
            _dict['source'] = self.source.to_dict()
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'last_job') and self.last_job is not None:
            _dict['last_job'] = self.last_job.to_dict()
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobDataWorkItem._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataWorkItem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataWorkItem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataWorkItem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SourceTypeEnum(str, Enum):
        """
        Type of source for the Template.
        """
        LOCAL = 'local'
        GIT_HUB = 'git_hub'
        GIT_HUB_ENTERPRISE = 'git_hub_enterprise'
        GIT_LAB = 'git_lab'
        IBM_GIT_LAB = 'ibm_git_lab'
        IBM_CLOUD_CATALOG = 'ibm_cloud_catalog'
        EXTERNAL_SCM = 'external_scm'


class JobDataWorkItemLastJob():
    """
    Status of the last job executed by the workitem.

    :attr str command_object: (optional) Name of the Schematics automation resource.
    :attr str command_object_name: (optional) command object name
          (workspace_name/action_name).
    :attr str command_object_id: (optional) Workitem command object id, maps to
          workspace_id or action_id.
    :attr str command_name: (optional) Schematics job command name.
    :attr str job_id: (optional) Workspace job id.
    :attr str job_status: (optional) Status of Jobs.
    """

    # The set of defined properties for the class
    _properties = frozenset(['command_object', 'command_object_name', 'command_object_id', 'command_name', 'job_id', 'job_status'])

    def __init__(self,
                 *,
                 command_object: str = None,
                 command_object_name: str = None,
                 command_object_id: str = None,
                 command_name: str = None,
                 job_id: str = None,
                 job_status: str = None,
                 **kwargs) -> None:
        """
        Initialize a JobDataWorkItemLastJob object.

        :param str command_object: (optional) Name of the Schematics automation
               resource.
        :param str command_object_name: (optional) command object name
               (workspace_name/action_name).
        :param str command_object_id: (optional) Workitem command object id, maps
               to workspace_id or action_id.
        :param str command_name: (optional) Schematics job command name.
        :param str job_id: (optional) Workspace job id.
        :param str job_status: (optional) Status of Jobs.
        :param **kwargs: (optional) Any additional properties.
        """
        self.command_object = command_object
        self.command_object_name = command_object_name
        self.command_object_id = command_object_id
        self.command_name = command_name
        self.job_id = job_id
        self.job_status = job_status
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataWorkItemLastJob':
        """Initialize a JobDataWorkItemLastJob object from a json dictionary."""
        args = {}
        if 'command_object' in _dict:
            args['command_object'] = _dict.get('command_object')
        if 'command_object_name' in _dict:
            args['command_object_name'] = _dict.get('command_object_name')
        if 'command_object_id' in _dict:
            args['command_object_id'] = _dict.get('command_object_id')
        if 'command_name' in _dict:
            args['command_name'] = _dict.get('command_name')
        if 'job_id' in _dict:
            args['job_id'] = _dict.get('job_id')
        if 'job_status' in _dict:
            args['job_status'] = _dict.get('job_status')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataWorkItemLastJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command_object') and self.command_object is not None:
            _dict['command_object'] = self.command_object
        if hasattr(self, 'command_object_name') and self.command_object_name is not None:
            _dict['command_object_name'] = self.command_object_name
        if hasattr(self, 'command_object_id') and self.command_object_id is not None:
            _dict['command_object_id'] = self.command_object_id
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'job_status') and self.job_status is not None:
            _dict['job_status'] = self.job_status
        for _key in [k for k in vars(self).keys() if k not in JobDataWorkItemLastJob._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataWorkItemLastJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataWorkItemLastJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataWorkItemLastJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class CommandObjectEnum(str, Enum):
        """
        Name of the Schematics automation resource.
        """
        WORKSPACE = 'workspace'
        ACTION = 'action'
        SYSTEM = 'system'
        ENVIRONMENT = 'environment'


    class CommandNameEnum(str, Enum):
        """
        Schematics job command name.
        """
        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        CREATE_ENVIRONMENT = 'create_environment'
        PUT_ENVIRONMENT = 'put_environment'
        DELETE_ENVIRONMENT = 'delete_environment'
        ENVIRONMENT_INIT = 'environment_init'
        ENVIRONMENT_INSTALL = 'environment_install'
        ENVIRONMENT_UNINSTALL = 'environment_uninstall'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'


    class JobStatusEnum(str, Enum):
        """
        Status of Jobs.
        """
        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'


class JobDataWorkspace():
    """
    Workspace Job data.

    :attr str workspace_name: (optional) Workspace name.
    :attr str flow_id: (optional) Flow Id.
    :attr str flow_name: (optional) Flow name.
    :attr List[VariableData] inputs: (optional) Input variables data used by the
          Workspace Job.
    :attr List[VariableData] outputs: (optional) Output variables data from the
          Workspace Job.
    :attr List[VariableData] settings: (optional) Environment variables used by all
          the templates in the Workspace.
    :attr List[JobDataTemplate] template_data: (optional) Input / output data of the
          Template in the Workspace Job.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['workspace_name', 'flow_id', 'flow_name', 'inputs', 'outputs', 'settings', 'template_data', 'updated_at'])

    def __init__(self,
                 *,
                 workspace_name: str = None,
                 flow_id: str = None,
                 flow_name: str = None,
                 inputs: List['VariableData'] = None,
                 outputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 template_data: List['JobDataTemplate'] = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobDataWorkspace object.

        :param str workspace_name: (optional) Workspace name.
        :param str flow_id: (optional) Flow Id.
        :param str flow_name: (optional) Flow name.
        :param List[VariableData] inputs: (optional) Input variables data used by
               the Workspace Job.
        :param List[VariableData] outputs: (optional) Output variables data from
               the Workspace Job.
        :param List[VariableData] settings: (optional) Environment variables used
               by all the templates in the Workspace.
        :param List[JobDataTemplate] template_data: (optional) Input / output data
               of the Template in the Workspace Job.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.workspace_name = workspace_name
        self.flow_id = flow_id
        self.flow_name = flow_name
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.template_data = template_data
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobDataWorkspace':
        """Initialize a JobDataWorkspace object from a json dictionary."""
        args = {}
        if 'workspace_name' in _dict:
            args['workspace_name'] = _dict.get('workspace_name')
        if 'flow_id' in _dict:
            args['flow_id'] = _dict.get('flow_id')
        if 'flow_name' in _dict:
            args['flow_name'] = _dict.get('flow_name')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'template_data' in _dict:
            args['template_data'] = [JobDataTemplate.from_dict(x) for x in _dict.get('template_data')]
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobDataWorkspace object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'workspace_name') and self.workspace_name is not None:
            _dict['workspace_name'] = self.workspace_name
        if hasattr(self, 'flow_id') and self.flow_id is not None:
            _dict['flow_id'] = self.flow_id
        if hasattr(self, 'flow_name') and self.flow_name is not None:
            _dict['flow_name'] = self.flow_name
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'template_data') and self.template_data is not None:
            _dict['template_data'] = [x.to_dict() for x in self.template_data]
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobDataWorkspace._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobDataWorkspace object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobDataWorkspace') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobDataWorkspace') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobFileData():
    """
    Output files from the Job record.

    :attr str job_id: (optional) Job Id.
    :attr str job_name: (optional) Job name, uniquely derived from the related
          Workspace and Action.
    :attr List[JobFileDataSummary] summary: (optional) Summary metadata in the
          output files.
    :attr str file_type: (optional) The type of output file generated by the Job.
    :attr str file_content: (optional) Content of the file, generated by the job.
    :attr datetime updated_at: (optional) Job file updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['job_id', 'job_name', 'summary', 'file_type', 'file_content', 'updated_at'])

    def __init__(self,
                 *,
                 job_id: str = None,
                 job_name: str = None,
                 summary: List['JobFileDataSummary'] = None,
                 file_type: str = None,
                 file_content: str = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobFileData object.

        :param str job_id: (optional) Job Id.
        :param str job_name: (optional) Job name, uniquely derived from the related
               Workspace and Action.
        :param List[JobFileDataSummary] summary: (optional) Summary metadata in the
               output files.
        :param str file_type: (optional) The type of output file generated by the
               Job.
        :param str file_content: (optional) Content of the file, generated by the
               job.
        :param datetime updated_at: (optional) Job file updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.job_id = job_id
        self.job_name = job_name
        self.summary = summary
        self.file_type = file_type
        self.file_content = file_content
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobFileData':
        """Initialize a JobFileData object from a json dictionary."""
        args = {}
        if 'job_id' in _dict:
            args['job_id'] = _dict.get('job_id')
        if 'job_name' in _dict:
            args['job_name'] = _dict.get('job_name')
        if 'summary' in _dict:
            args['summary'] = [JobFileDataSummary.from_dict(x) for x in _dict.get('summary')]
        if 'file_type' in _dict:
            args['file_type'] = _dict.get('file_type')
        if 'file_content' in _dict:
            args['file_content'] = _dict.get('file_content')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobFileData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'job_name') and self.job_name is not None:
            _dict['job_name'] = self.job_name
        if hasattr(self, 'summary') and self.summary is not None:
            _dict['summary'] = [x.to_dict() for x in self.summary]
        if hasattr(self, 'file_type') and self.file_type is not None:
            _dict['file_type'] = self.file_type
        if hasattr(self, 'file_content') and self.file_content is not None:
            _dict['file_content'] = self.file_content
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobFileData._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobFileData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobFileData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobFileData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FileTypeEnum(str, Enum):
        """
        The type of output file generated by the Job.
        """
        STATE_FILE = 'state_file'
        PLAN_JSON = 'plan_json'


class JobFileDataSummary():
    """
    JobFileDataSummary.

    :attr str name: (optional) Summary feature name.
    :attr str type: (optional) Summary feature type.
    :attr str value: (optional) Summary feature value.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'type', 'value'])

    def __init__(self,
                 *,
                 name: str = None,
                 type: str = None,
                 value: str = None,
                 **kwargs) -> None:
        """
        Initialize a JobFileDataSummary object.

        :param str name: (optional) Summary feature name.
        :param str type: (optional) Summary feature type.
        :param str value: (optional) Summary feature value.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.type = type
        self.value = value
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobFileDataSummary':
        """Initialize a JobFileDataSummary object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobFileDataSummary object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        for _key in [k for k in vars(self).keys() if k not in JobFileDataSummary._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobFileDataSummary object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobFileDataSummary') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobFileDataSummary') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Summary feature type.
        """
        NUMBER = 'number'
        STRING = 'string'


class JobList():
    """
    List of Job details.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[JobLite] jobs: (optional) List of job records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'jobs'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 jobs: List['JobLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a JobList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[JobLite] jobs: (optional) List of job records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.jobs = jobs
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobList':
        """Initialize a JobList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in JobList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in JobList JSON')
        if 'jobs' in _dict:
            args['jobs'] = [JobLite.from_dict(x) for x in _dict.get('jobs')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'jobs') and self.jobs is not None:
            _dict['jobs'] = [x.to_dict() for x in self.jobs]
        for _key in [k for k in vars(self).keys() if k not in JobList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobLite():
    """
    Job summary profile with system generated data.

    :attr str id: (optional) Job ID.
    :attr str name: (optional) Job name, uniquely derived from the related Workspace
          or Action.
    :attr str description: (optional) Job description derived from the related
          Workspace or Action.
    :attr str command_object: (optional) Name of the Schematics automation resource.
    :attr str command_object_id: (optional) Job command object id (workspace-id,
          action-id).
    :attr str command_name: (optional) Schematics job command name.
    :attr List[str] tags: (optional) User defined tags, while running the job.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str resource_group: (optional) Resource-group name derived from the
          related Workspace or Action.
    :attr datetime submitted_at: (optional) Job submission time.
    :attr str submitted_by: (optional) Email address of user who submitted the job.
    :attr str duration: (optional) Duration of job execution; example 40 sec.
    :attr datetime start_at: (optional) Job start time.
    :attr datetime end_at: (optional) Job end time.
    :attr JobStatus status: (optional) Job Status.
    :attr JobLogSummary log_summary: (optional) Job log summary record.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    :attr str job_runner_id: (optional) ID of the Job Runner.
    """

    # The set of defined properties for the class
    _properties = frozenset(['id', 'name', 'description', 'command_object', 'command_object_id', 'command_name', 'tags', 'location', 'resource_group', 'submitted_at', 'submitted_by', 'duration', 'start_at', 'end_at', 'status', 'log_summary', 'updated_at', 'job_runner_id'])

    def __init__(self,
                 *,
                 id: str = None,
                 name: str = None,
                 description: str = None,
                 command_object: str = None,
                 command_object_id: str = None,
                 command_name: str = None,
                 tags: List[str] = None,
                 location: str = None,
                 resource_group: str = None,
                 submitted_at: datetime = None,
                 submitted_by: str = None,
                 duration: str = None,
                 start_at: datetime = None,
                 end_at: datetime = None,
                 status: 'JobStatus' = None,
                 log_summary: 'JobLogSummary' = None,
                 updated_at: datetime = None,
                 job_runner_id: str = None,
                 **kwargs) -> None:
        """
        Initialize a JobLite object.

        :param str id: (optional) Job ID.
        :param str name: (optional) Job name, uniquely derived from the related
               Workspace or Action.
        :param str description: (optional) Job description derived from the related
               Workspace or Action.
        :param str command_object: (optional) Name of the Schematics automation
               resource.
        :param str command_object_id: (optional) Job command object id
               (workspace-id, action-id).
        :param str command_name: (optional) Schematics job command name.
        :param List[str] tags: (optional) User defined tags, while running the job.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name derived from the
               related Workspace or Action.
        :param datetime submitted_at: (optional) Job submission time.
        :param str submitted_by: (optional) Email address of user who submitted the
               job.
        :param str duration: (optional) Duration of job execution; example 40 sec.
        :param datetime start_at: (optional) Job start time.
        :param datetime end_at: (optional) Job end time.
        :param JobStatus status: (optional) Job Status.
        :param JobLogSummary log_summary: (optional) Job log summary record.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param str job_runner_id: (optional) ID of the Job Runner.
        :param **kwargs: (optional) Any additional properties.
        """
        self.id = id
        self.name = name
        self.description = description
        self.command_object = command_object
        self.command_object_id = command_object_id
        self.command_name = command_name
        self.tags = tags
        self.location = location
        self.resource_group = resource_group
        self.submitted_at = submitted_at
        self.submitted_by = submitted_by
        self.duration = duration
        self.start_at = start_at
        self.end_at = end_at
        self.status = status
        self.log_summary = log_summary
        self.updated_at = updated_at
        self.job_runner_id = job_runner_id
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLite':
        """Initialize a JobLite object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'command_object' in _dict:
            args['command_object'] = _dict.get('command_object')
        if 'command_object_id' in _dict:
            args['command_object_id'] = _dict.get('command_object_id')
        if 'command_name' in _dict:
            args['command_name'] = _dict.get('command_name')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'submitted_at' in _dict:
            args['submitted_at'] = string_to_datetime(_dict.get('submitted_at'))
        if 'submitted_by' in _dict:
            args['submitted_by'] = _dict.get('submitted_by')
        if 'duration' in _dict:
            args['duration'] = _dict.get('duration')
        if 'start_at' in _dict:
            args['start_at'] = string_to_datetime(_dict.get('start_at'))
        if 'end_at' in _dict:
            args['end_at'] = string_to_datetime(_dict.get('end_at'))
        if 'status' in _dict:
            args['status'] = JobStatus.from_dict(_dict.get('status'))
        if 'log_summary' in _dict:
            args['log_summary'] = JobLogSummary.from_dict(_dict.get('log_summary'))
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'job_runner_id' in _dict:
            args['job_runner_id'] = _dict.get('job_runner_id')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'command_object') and self.command_object is not None:
            _dict['command_object'] = self.command_object
        if hasattr(self, 'command_object_id') and self.command_object_id is not None:
            _dict['command_object_id'] = self.command_object_id
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'submitted_at') and self.submitted_at is not None:
            _dict['submitted_at'] = datetime_to_string(self.submitted_at)
        if hasattr(self, 'submitted_by') and self.submitted_by is not None:
            _dict['submitted_by'] = self.submitted_by
        if hasattr(self, 'duration') and self.duration is not None:
            _dict['duration'] = self.duration
        if hasattr(self, 'start_at') and self.start_at is not None:
            _dict['start_at'] = datetime_to_string(self.start_at)
        if hasattr(self, 'end_at') and self.end_at is not None:
            _dict['end_at'] = datetime_to_string(self.end_at)
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status.to_dict()
        if hasattr(self, 'log_summary') and self.log_summary is not None:
            _dict['log_summary'] = self.log_summary.to_dict()
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'job_runner_id') and self.job_runner_id is not None:
            _dict['job_runner_id'] = self.job_runner_id
        for _key in [k for k in vars(self).keys() if k not in JobLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class CommandObjectEnum(str, Enum):
        """
        Name of the Schematics automation resource.
        """
        WORKSPACE = 'workspace'
        ACTION = 'action'
        SYSTEM = 'system'
        ENVIRONMENT = 'environment'


    class CommandNameEnum(str, Enum):
        """
        Schematics job command name.
        """
        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        CREATE_ENVIRONMENT = 'create_environment'
        PUT_ENVIRONMENT = 'put_environment'
        DELETE_ENVIRONMENT = 'delete_environment'
        ENVIRONMENT_INIT = 'environment_init'
        ENVIRONMENT_INSTALL = 'environment_install'
        ENVIRONMENT_UNINSTALL = 'environment_uninstall'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'


    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class JobLog():
    """
    Job Log details.

    :attr str job_id: (optional) Job Id.
    :attr str job_name: (optional) Job name, uniquely derived from the related
          Workspace, Action or Controls.
    :attr JobLogSummary log_summary: (optional) Job log summary record.
    :attr str format: (optional) Format of the Log text.
    :attr bytes details: (optional) Log text, generated by the Job.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['job_id', 'job_name', 'log_summary', 'format', 'details', 'updated_at'])

    def __init__(self,
                 *,
                 job_id: str = None,
                 job_name: str = None,
                 log_summary: 'JobLogSummary' = None,
                 format: str = None,
                 details: bytes = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobLog object.

        :param str job_id: (optional) Job Id.
        :param str job_name: (optional) Job name, uniquely derived from the related
               Workspace, Action or Controls.
        :param JobLogSummary log_summary: (optional) Job log summary record.
        :param str format: (optional) Format of the Log text.
        :param bytes details: (optional) Log text, generated by the Job.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.job_id = job_id
        self.job_name = job_name
        self.log_summary = log_summary
        self.format = format
        self.details = details
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLog':
        """Initialize a JobLog object from a json dictionary."""
        args = {}
        if 'job_id' in _dict:
            args['job_id'] = _dict.get('job_id')
        if 'job_name' in _dict:
            args['job_name'] = _dict.get('job_name')
        if 'log_summary' in _dict:
            args['log_summary'] = JobLogSummary.from_dict(_dict.get('log_summary'))
        if 'format' in _dict:
            args['format'] = _dict.get('format')
        if 'details' in _dict:
            args['details'] = base64.b64decode(_dict.get('details'))
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLog object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'job_name') and self.job_name is not None:
            _dict['job_name'] = self.job_name
        if hasattr(self, 'log_summary') and self.log_summary is not None:
            _dict['log_summary'] = self.log_summary.to_dict()
        if hasattr(self, 'format') and self.format is not None:
            _dict['format'] = self.format
        if hasattr(self, 'details') and self.details is not None:
            _dict['details'] = str(base64.b64encode(self.details), 'utf-8')
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobLog._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLog object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLog') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLog') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FormatEnum(str, Enum):
        """
        Format of the Log text.
        """
        JSON = 'json'
        HTML = 'html'
        MARKDOWN = 'markdown'
        RTF = 'rtf'


class JobLogSummary():
    """
    Job log summary record.

    :attr str job_id: (optional) Workspace Id.
    :attr str job_type: (optional) Type of Job.
    :attr datetime log_start_at: (optional) Job log start timestamp.
    :attr datetime log_analyzed_till: (optional) Job log update timestamp.
    :attr float elapsed_time: (optional) Job log elapsed time (log_analyzed_till -
          log_start_at).
    :attr List[JobLogSummaryLogErrors] log_errors: (optional) Job log errors.
    :attr JobLogSummaryRepoDownloadJob repo_download_job: (optional) Repo download
          Job log summary.
    :attr JobLogSummaryWorkspaceJob workspace_job: (optional) Workspace Job log
          summary.
    :attr JobLogSummaryFlowJob flow_job: (optional) Flow Job log summary.
    :attr JobLogSummaryActionJob action_job: (optional) Flow Job log summary.
    :attr JobLogSummarySystemJob system_job: (optional) System Job log summary.
    """

    # The set of defined properties for the class
    _properties = frozenset(['job_id', 'job_type', 'log_start_at', 'log_analyzed_till', 'elapsed_time', 'log_errors', 'repo_download_job', 'workspace_job', 'flow_job', 'action_job', 'system_job'])

    def __init__(self,
                 *,
                 job_id: str = None,
                 job_type: str = None,
                 log_start_at: datetime = None,
                 log_analyzed_till: datetime = None,
                 elapsed_time: float = None,
                 log_errors: List['JobLogSummaryLogErrors'] = None,
                 repo_download_job: 'JobLogSummaryRepoDownloadJob' = None,
                 workspace_job: 'JobLogSummaryWorkspaceJob' = None,
                 flow_job: 'JobLogSummaryFlowJob' = None,
                 action_job: 'JobLogSummaryActionJob' = None,
                 system_job: 'JobLogSummarySystemJob' = None,
                 **kwargs) -> None:
        """
        Initialize a JobLogSummary object.

        :param str job_type: (optional) Type of Job.
        :param JobLogSummaryRepoDownloadJob repo_download_job: (optional) Repo
               download Job log summary.
        :param JobLogSummaryWorkspaceJob workspace_job: (optional) Workspace Job
               log summary.
        :param JobLogSummaryFlowJob flow_job: (optional) Flow Job log summary.
        :param JobLogSummaryActionJob action_job: (optional) Flow Job log summary.
        :param JobLogSummarySystemJob system_job: (optional) System Job log
               summary.
        :param **kwargs: (optional) Any additional properties.
        """
        self.job_id = job_id
        self.job_type = job_type
        self.log_start_at = log_start_at
        self.log_analyzed_till = log_analyzed_till
        self.elapsed_time = elapsed_time
        self.log_errors = log_errors
        self.repo_download_job = repo_download_job
        self.workspace_job = workspace_job
        self.flow_job = flow_job
        self.action_job = action_job
        self.system_job = system_job
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummary':
        """Initialize a JobLogSummary object from a json dictionary."""
        args = {}
        if 'job_id' in _dict:
            args['job_id'] = _dict.get('job_id')
        if 'job_type' in _dict:
            args['job_type'] = _dict.get('job_type')
        if 'log_start_at' in _dict:
            args['log_start_at'] = string_to_datetime(_dict.get('log_start_at'))
        if 'log_analyzed_till' in _dict:
            args['log_analyzed_till'] = string_to_datetime(_dict.get('log_analyzed_till'))
        if 'elapsed_time' in _dict:
            args['elapsed_time'] = _dict.get('elapsed_time')
        if 'log_errors' in _dict:
            args['log_errors'] = [JobLogSummaryLogErrors.from_dict(x) for x in _dict.get('log_errors')]
        if 'repo_download_job' in _dict:
            args['repo_download_job'] = JobLogSummaryRepoDownloadJob.from_dict(_dict.get('repo_download_job'))
        if 'workspace_job' in _dict:
            args['workspace_job'] = JobLogSummaryWorkspaceJob.from_dict(_dict.get('workspace_job'))
        if 'flow_job' in _dict:
            args['flow_job'] = JobLogSummaryFlowJob.from_dict(_dict.get('flow_job'))
        if 'action_job' in _dict:
            args['action_job'] = JobLogSummaryActionJob.from_dict(_dict.get('action_job'))
        if 'system_job' in _dict:
            args['system_job'] = JobLogSummarySystemJob.from_dict(_dict.get('system_job'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummary object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job_id') and getattr(self, 'job_id') is not None:
            _dict['job_id'] = getattr(self, 'job_id')
        if hasattr(self, 'job_type') and self.job_type is not None:
            _dict['job_type'] = self.job_type
        if hasattr(self, 'log_start_at') and getattr(self, 'log_start_at') is not None:
            _dict['log_start_at'] = datetime_to_string(getattr(self, 'log_start_at'))
        if hasattr(self, 'log_analyzed_till') and getattr(self, 'log_analyzed_till') is not None:
            _dict['log_analyzed_till'] = datetime_to_string(getattr(self, 'log_analyzed_till'))
        if hasattr(self, 'elapsed_time') and getattr(self, 'elapsed_time') is not None:
            _dict['elapsed_time'] = getattr(self, 'elapsed_time')
        if hasattr(self, 'log_errors') and getattr(self, 'log_errors') is not None:
            _dict['log_errors'] = [x.to_dict() for x in getattr(self, 'log_errors')]
        if hasattr(self, 'repo_download_job') and self.repo_download_job is not None:
            _dict['repo_download_job'] = self.repo_download_job.to_dict()
        if hasattr(self, 'workspace_job') and self.workspace_job is not None:
            _dict['workspace_job'] = self.workspace_job.to_dict()
        if hasattr(self, 'flow_job') and self.flow_job is not None:
            _dict['flow_job'] = self.flow_job.to_dict()
        if hasattr(self, 'action_job') and self.action_job is not None:
            _dict['action_job'] = self.action_job.to_dict()
        if hasattr(self, 'system_job') and self.system_job is not None:
            _dict['system_job'] = self.system_job.to_dict()
        for _key in [k for k in vars(self).keys() if k not in JobLogSummary._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummary object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummary') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummary') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class JobTypeEnum(str, Enum):
        """
        Type of Job.
        """
        REPO_DOWNLOAD_JOB = 'repo_download_job'
        WORKSPACE_JOB = 'workspace_job'
        ACTION_JOB = 'action_job'
        SYSTEM_JOB = 'system_job'
        FLOW_JOB = 'flow_job'


class JobLogSummaryWorkitems():
    """
    Job log summary of the flow workitem.

    :attr str workspace_id: (optional) workspace ID.
    :attr str job_id: (optional) workspace JOB ID.
    :attr float resources_add: (optional) Number of resources add.
    :attr float resources_modify: (optional) Number of resources modify.
    :attr float resources_destroy: (optional) Number of resources destroy.
    :attr str log_url: (optional) Log url for job.
    """

    # The set of defined properties for the class
    _properties = frozenset(['workspace_id', 'job_id', 'resources_add', 'resources_modify', 'resources_destroy', 'log_url'])

    def __init__(self,
                 *,
                 workspace_id: str = None,
                 job_id: str = None,
                 resources_add: float = None,
                 resources_modify: float = None,
                 resources_destroy: float = None,
                 log_url: str = None,
                 **kwargs) -> None:
        """
        Initialize a JobLogSummaryWorkitems object.

        :param str workspace_id: (optional) workspace ID.
        :param str job_id: (optional) workspace JOB ID.
        :param str log_url: (optional) Log url for job.
        :param **kwargs: (optional) Any additional properties.
        """
        self.workspace_id = workspace_id
        self.job_id = job_id
        self.resources_add = resources_add
        self.resources_modify = resources_modify
        self.resources_destroy = resources_destroy
        self.log_url = log_url
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryWorkitems':
        """Initialize a JobLogSummaryWorkitems object from a json dictionary."""
        args = {}
        if 'workspace_id' in _dict:
            args['workspace_id'] = _dict.get('workspace_id')
        if 'job_id' in _dict:
            args['job_id'] = _dict.get('job_id')
        if 'resources_add' in _dict:
            args['resources_add'] = _dict.get('resources_add')
        if 'resources_modify' in _dict:
            args['resources_modify'] = _dict.get('resources_modify')
        if 'resources_destroy' in _dict:
            args['resources_destroy'] = _dict.get('resources_destroy')
        if 'log_url' in _dict:
            args['log_url'] = _dict.get('log_url')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryWorkitems object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'workspace_id') and self.workspace_id is not None:
            _dict['workspace_id'] = self.workspace_id
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'resources_add') and getattr(self, 'resources_add') is not None:
            _dict['resources_add'] = getattr(self, 'resources_add')
        if hasattr(self, 'resources_modify') and getattr(self, 'resources_modify') is not None:
            _dict['resources_modify'] = getattr(self, 'resources_modify')
        if hasattr(self, 'resources_destroy') and getattr(self, 'resources_destroy') is not None:
            _dict['resources_destroy'] = getattr(self, 'resources_destroy')
        if hasattr(self, 'log_url') and self.log_url is not None:
            _dict['log_url'] = self.log_url
        for _key in [k for k in vars(self).keys() if k not in JobLogSummaryWorkitems._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryWorkitems object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryWorkitems') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryWorkitems') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobLogSummaryActionJob():
    """
    Flow Job log summary.

    :attr float target_count: (optional) number of targets or hosts.
    :attr float task_count: (optional) number of tasks in playbook.
    :attr float play_count: (optional) number of plays in playbook.
    :attr JobLogSummaryActionJobRecap recap: (optional) Recap records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['target_count', 'task_count', 'play_count', 'recap'])

    def __init__(self,
                 *,
                 target_count: float = None,
                 task_count: float = None,
                 play_count: float = None,
                 recap: 'JobLogSummaryActionJobRecap' = None,
                 **kwargs) -> None:
        """
        Initialize a JobLogSummaryActionJob object.

        :param JobLogSummaryActionJobRecap recap: (optional) Recap records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.target_count = target_count
        self.task_count = task_count
        self.play_count = play_count
        self.recap = recap
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryActionJob':
        """Initialize a JobLogSummaryActionJob object from a json dictionary."""
        args = {}
        if 'target_count' in _dict:
            args['target_count'] = _dict.get('target_count')
        if 'task_count' in _dict:
            args['task_count'] = _dict.get('task_count')
        if 'play_count' in _dict:
            args['play_count'] = _dict.get('play_count')
        if 'recap' in _dict:
            args['recap'] = JobLogSummaryActionJobRecap.from_dict(_dict.get('recap'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryActionJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'target_count') and getattr(self, 'target_count') is not None:
            _dict['target_count'] = getattr(self, 'target_count')
        if hasattr(self, 'task_count') and getattr(self, 'task_count') is not None:
            _dict['task_count'] = getattr(self, 'task_count')
        if hasattr(self, 'play_count') and getattr(self, 'play_count') is not None:
            _dict['play_count'] = getattr(self, 'play_count')
        if hasattr(self, 'recap') and self.recap is not None:
            _dict['recap'] = self.recap.to_dict()
        for _key in [k for k in vars(self).keys() if k not in JobLogSummaryActionJob._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryActionJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryActionJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryActionJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobLogSummaryActionJobRecap():
    """
    Recap records.

    :attr List[str] target: (optional) List of target or host name.
    :attr float ok: (optional) Number of OK.
    :attr float changed: (optional) Number of changed.
    :attr float failed: (optional) Number of failed.
    :attr float skipped: (optional) Number of skipped.
    :attr float unreachable: (optional) Number of unreachable.
    """

    # The set of defined properties for the class
    _properties = frozenset(['target', 'ok', 'changed', 'failed', 'skipped', 'unreachable'])

    def __init__(self,
                 *,
                 target: List[str] = None,
                 ok: float = None,
                 changed: float = None,
                 failed: float = None,
                 skipped: float = None,
                 unreachable: float = None,
                 **kwargs) -> None:
        """
        Initialize a JobLogSummaryActionJobRecap object.

        :param List[str] target: (optional) List of target or host name.
        :param float ok: (optional) Number of OK.
        :param float changed: (optional) Number of changed.
        :param float failed: (optional) Number of failed.
        :param float skipped: (optional) Number of skipped.
        :param float unreachable: (optional) Number of unreachable.
        :param **kwargs: (optional) Any additional properties.
        """
        self.target = target
        self.ok = ok
        self.changed = changed
        self.failed = failed
        self.skipped = skipped
        self.unreachable = unreachable
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryActionJobRecap':
        """Initialize a JobLogSummaryActionJobRecap object from a json dictionary."""
        args = {}
        if 'target' in _dict:
            args['target'] = _dict.get('target')
        if 'ok' in _dict:
            args['ok'] = _dict.get('ok')
        if 'changed' in _dict:
            args['changed'] = _dict.get('changed')
        if 'failed' in _dict:
            args['failed'] = _dict.get('failed')
        if 'skipped' in _dict:
            args['skipped'] = _dict.get('skipped')
        if 'unreachable' in _dict:
            args['unreachable'] = _dict.get('unreachable')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryActionJobRecap object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'target') and self.target is not None:
            _dict['target'] = self.target
        if hasattr(self, 'ok') and self.ok is not None:
            _dict['ok'] = self.ok
        if hasattr(self, 'changed') and self.changed is not None:
            _dict['changed'] = self.changed
        if hasattr(self, 'failed') and self.failed is not None:
            _dict['failed'] = self.failed
        if hasattr(self, 'skipped') and self.skipped is not None:
            _dict['skipped'] = self.skipped
        if hasattr(self, 'unreachable') and self.unreachable is not None:
            _dict['unreachable'] = self.unreachable
        for _key in [k for k in vars(self).keys() if k not in JobLogSummaryActionJobRecap._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryActionJobRecap object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryActionJobRecap') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryActionJobRecap') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobLogSummaryFlowJob():
    """
    Flow Job log summary.

    :attr float workitems_completed: (optional) Number of workitems completed
          successfully.
    :attr float workitems_pending: (optional) Number of workitems pending in the
          flow.
    :attr float workitems_failed: (optional) Number of workitems failed.
    :attr List[JobLogSummaryWorkitems] workitems: (optional)
    """

    # The set of defined properties for the class
    _properties = frozenset(['workitems_completed', 'workitems_pending', 'workitems_failed', 'workitems'])

    def __init__(self,
                 *,
                 workitems_completed: float = None,
                 workitems_pending: float = None,
                 workitems_failed: float = None,
                 workitems: List['JobLogSummaryWorkitems'] = None,
                 **kwargs) -> None:
        """
        Initialize a JobLogSummaryFlowJob object.

        :param List[JobLogSummaryWorkitems] workitems: (optional)
        :param **kwargs: (optional) Any additional properties.
        """
        self.workitems_completed = workitems_completed
        self.workitems_pending = workitems_pending
        self.workitems_failed = workitems_failed
        self.workitems = workitems
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryFlowJob':
        """Initialize a JobLogSummaryFlowJob object from a json dictionary."""
        args = {}
        if 'workitems_completed' in _dict:
            args['workitems_completed'] = _dict.get('workitems_completed')
        if 'workitems_pending' in _dict:
            args['workitems_pending'] = _dict.get('workitems_pending')
        if 'workitems_failed' in _dict:
            args['workitems_failed'] = _dict.get('workitems_failed')
        if 'workitems' in _dict:
            args['workitems'] = [JobLogSummaryWorkitems.from_dict(x) for x in _dict.get('workitems')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryFlowJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'workitems_completed') and getattr(self, 'workitems_completed') is not None:
            _dict['workitems_completed'] = getattr(self, 'workitems_completed')
        if hasattr(self, 'workitems_pending') and getattr(self, 'workitems_pending') is not None:
            _dict['workitems_pending'] = getattr(self, 'workitems_pending')
        if hasattr(self, 'workitems_failed') and getattr(self, 'workitems_failed') is not None:
            _dict['workitems_failed'] = getattr(self, 'workitems_failed')
        if hasattr(self, 'workitems') and self.workitems is not None:
            _dict['workitems'] = [x.to_dict() for x in self.workitems]
        for _key in [k for k in vars(self).keys() if k not in JobLogSummaryFlowJob._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryFlowJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryFlowJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryFlowJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobLogSummaryLogErrors():
    """
    JobLogSummaryLogErrors.

    :attr str error_code: (optional) Error code in the Log.
    :attr str error_msg: (optional) Summary error message in the log.
    :attr float error_count: (optional) Number of occurrence.
    """

    # The set of defined properties for the class
    _properties = frozenset(['error_code', 'error_msg', 'error_count'])

    def __init__(self,
                 *,
                 error_code: str = None,
                 error_msg: str = None,
                 error_count: float = None,
                 **kwargs) -> None:
        """
        Initialize a JobLogSummaryLogErrors object.

        :param str error_code: (optional) Error code in the Log.
        :param str error_msg: (optional) Summary error message in the log.
        :param float error_count: (optional) Number of occurrence.
        :param **kwargs: (optional) Any additional properties.
        """
        self.error_code = error_code
        self.error_msg = error_msg
        self.error_count = error_count
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryLogErrors':
        """Initialize a JobLogSummaryLogErrors object from a json dictionary."""
        args = {}
        if 'error_code' in _dict:
            args['error_code'] = _dict.get('error_code')
        if 'error_msg' in _dict:
            args['error_msg'] = _dict.get('error_msg')
        if 'error_count' in _dict:
            args['error_count'] = _dict.get('error_count')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryLogErrors object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'error_code') and self.error_code is not None:
            _dict['error_code'] = self.error_code
        if hasattr(self, 'error_msg') and self.error_msg is not None:
            _dict['error_msg'] = self.error_msg
        if hasattr(self, 'error_count') and self.error_count is not None:
            _dict['error_count'] = self.error_count
        for _key in [k for k in vars(self).keys() if k not in JobLogSummaryLogErrors._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryLogErrors object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryLogErrors') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryLogErrors') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobLogSummaryRepoDownloadJob():
    """
    Repo download Job log summary.

    :attr float scanned_file_count: (optional) Number of files scanned.
    :attr float quarantined_file_count: (optional) Number of files quarantined.
    :attr str detected_filetype: (optional) Detected template or data file type.
    :attr str inputs_count: (optional) Number of inputs detected.
    :attr str outputs_count: (optional) Number of outputs detected.
    """

    # The set of defined properties for the class
    _properties = frozenset(['scanned_file_count', 'quarantined_file_count', 'detected_filetype', 'inputs_count', 'outputs_count'])

    def __init__(self,
                 *,
                 scanned_file_count: float = None,
                 quarantined_file_count: float = None,
                 detected_filetype: str = None,
                 inputs_count: str = None,
                 outputs_count: str = None,
                 **kwargs) -> None:
        """
        Initialize a JobLogSummaryRepoDownloadJob object.

        :param **kwargs: (optional) Any additional properties.
        """
        self.scanned_file_count = scanned_file_count
        self.quarantined_file_count = quarantined_file_count
        self.detected_filetype = detected_filetype
        self.inputs_count = inputs_count
        self.outputs_count = outputs_count
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryRepoDownloadJob':
        """Initialize a JobLogSummaryRepoDownloadJob object from a json dictionary."""
        args = {}
        if 'scanned_file_count' in _dict:
            args['scanned_file_count'] = _dict.get('scanned_file_count')
        if 'quarantined_file_count' in _dict:
            args['quarantined_file_count'] = _dict.get('quarantined_file_count')
        if 'detected_filetype' in _dict:
            args['detected_filetype'] = _dict.get('detected_filetype')
        if 'inputs_count' in _dict:
            args['inputs_count'] = _dict.get('inputs_count')
        if 'outputs_count' in _dict:
            args['outputs_count'] = _dict.get('outputs_count')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryRepoDownloadJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'scanned_file_count') and getattr(self, 'scanned_file_count') is not None:
            _dict['scanned_file_count'] = getattr(self, 'scanned_file_count')
        if hasattr(self, 'quarantined_file_count') and getattr(self, 'quarantined_file_count') is not None:
            _dict['quarantined_file_count'] = getattr(self, 'quarantined_file_count')
        if hasattr(self, 'detected_filetype') and getattr(self, 'detected_filetype') is not None:
            _dict['detected_filetype'] = getattr(self, 'detected_filetype')
        if hasattr(self, 'inputs_count') and getattr(self, 'inputs_count') is not None:
            _dict['inputs_count'] = getattr(self, 'inputs_count')
        if hasattr(self, 'outputs_count') and getattr(self, 'outputs_count') is not None:
            _dict['outputs_count'] = getattr(self, 'outputs_count')
        for _key in [k for k in vars(self).keys() if k not in JobLogSummaryRepoDownloadJob._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryRepoDownloadJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryRepoDownloadJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryRepoDownloadJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobLogSummarySystemJob():
    """
    System Job log summary.

    :attr float target_count: (optional) number of targets or hosts.
    :attr float success: (optional) Number of passed.
    :attr float failed: (optional) Number of failed.
    """

    # The set of defined properties for the class
    _properties = frozenset(['target_count', 'success', 'failed'])

    def __init__(self,
                 *,
                 target_count: float = None,
                 success: float = None,
                 failed: float = None,
                 **kwargs) -> None:
        """
        Initialize a JobLogSummarySystemJob object.

        :param float success: (optional) Number of passed.
        :param float failed: (optional) Number of failed.
        :param **kwargs: (optional) Any additional properties.
        """
        self.target_count = target_count
        self.success = success
        self.failed = failed
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummarySystemJob':
        """Initialize a JobLogSummarySystemJob object from a json dictionary."""
        args = {}
        if 'target_count' in _dict:
            args['target_count'] = _dict.get('target_count')
        if 'success' in _dict:
            args['success'] = _dict.get('success')
        if 'failed' in _dict:
            args['failed'] = _dict.get('failed')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummarySystemJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'target_count') and getattr(self, 'target_count') is not None:
            _dict['target_count'] = getattr(self, 'target_count')
        if hasattr(self, 'success') and self.success is not None:
            _dict['success'] = self.success
        if hasattr(self, 'failed') and self.failed is not None:
            _dict['failed'] = self.failed
        for _key in [k for k in vars(self).keys() if k not in JobLogSummarySystemJob._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummarySystemJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummarySystemJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummarySystemJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobLogSummaryWorkspaceJob():
    """
    Workspace Job log summary.

    :attr float resources_add: (optional) Number of resources add.
    :attr float resources_modify: (optional) Number of resources modify.
    :attr float resources_destroy: (optional) Number of resources destroy.
    """

    # The set of defined properties for the class
    _properties = frozenset(['resources_add', 'resources_modify', 'resources_destroy'])

    def __init__(self,
                 *,
                 resources_add: float = None,
                 resources_modify: float = None,
                 resources_destroy: float = None,
                 **kwargs) -> None:
        """
        Initialize a JobLogSummaryWorkspaceJob object.

        :param **kwargs: (optional) Any additional properties.
        """
        self.resources_add = resources_add
        self.resources_modify = resources_modify
        self.resources_destroy = resources_destroy
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobLogSummaryWorkspaceJob':
        """Initialize a JobLogSummaryWorkspaceJob object from a json dictionary."""
        args = {}
        if 'resources_add' in _dict:
            args['resources_add'] = _dict.get('resources_add')
        if 'resources_modify' in _dict:
            args['resources_modify'] = _dict.get('resources_modify')
        if 'resources_destroy' in _dict:
            args['resources_destroy'] = _dict.get('resources_destroy')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobLogSummaryWorkspaceJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'resources_add') and getattr(self, 'resources_add') is not None:
            _dict['resources_add'] = getattr(self, 'resources_add')
        if hasattr(self, 'resources_modify') and getattr(self, 'resources_modify') is not None:
            _dict['resources_modify'] = getattr(self, 'resources_modify')
        if hasattr(self, 'resources_destroy') and getattr(self, 'resources_destroy') is not None:
            _dict['resources_destroy'] = getattr(self, 'resources_destroy')
        for _key in [k for k in vars(self).keys() if k not in JobLogSummaryWorkspaceJob._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobLogSummaryWorkspaceJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobLogSummaryWorkspaceJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobLogSummaryWorkspaceJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobResultCapsule():
    """
    Capsule Job Results.

    :attr str job_id: (optional) Job Id.
    :attr str job_name: (optional) Job name, uniquely derived from the related
          Workspace, Action or Controls.
    :attr str policy: (optional) Policy name.
    :attr int severity: (optional) Severity.
    :attr str job_state: (optional) Job state.
    :attr List[str] failures: (optional) Job failures.
    :attr List[str] passed: (optional) Job passed.
    :attr List[CapsuleResultEvidences] evidences: (optional) Capsule evidences.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['job_id', 'job_name', 'policy', 'severity', 'job_state', 'failures', 'passed', 'evidences', 'updated_at'])

    def __init__(self,
                 *,
                 job_id: str = None,
                 job_name: str = None,
                 policy: str = None,
                 severity: int = None,
                 job_state: str = None,
                 failures: List[str] = None,
                 passed: List[str] = None,
                 evidences: List['CapsuleResultEvidences'] = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobResultCapsule object.

        :param str job_id: (optional) Job Id.
        :param str job_name: (optional) Job name, uniquely derived from the related
               Workspace, Action or Controls.
        :param str policy: (optional) Policy name.
        :param int severity: (optional) Severity.
        :param str job_state: (optional) Job state.
        :param List[str] failures: (optional) Job failures.
        :param List[str] passed: (optional) Job passed.
        :param List[CapsuleResultEvidences] evidences: (optional) Capsule
               evidences.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.job_id = job_id
        self.job_name = job_name
        self.policy = policy
        self.severity = severity
        self.job_state = job_state
        self.failures = failures
        self.passed = passed
        self.evidences = evidences
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobResultCapsule':
        """Initialize a JobResultCapsule object from a json dictionary."""
        args = {}
        if 'job_id' in _dict:
            args['job_id'] = _dict.get('job_id')
        if 'job_name' in _dict:
            args['job_name'] = _dict.get('job_name')
        if 'policy' in _dict:
            args['policy'] = _dict.get('policy')
        if 'severity' in _dict:
            args['severity'] = _dict.get('severity')
        if 'job_state' in _dict:
            args['job_state'] = _dict.get('job_state')
        if 'failures' in _dict:
            args['failures'] = _dict.get('failures')
        if 'passed' in _dict:
            args['passed'] = _dict.get('passed')
        if 'evidences' in _dict:
            args['evidences'] = [CapsuleResultEvidences.from_dict(x) for x in _dict.get('evidences')]
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobResultCapsule object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'job_name') and self.job_name is not None:
            _dict['job_name'] = self.job_name
        if hasattr(self, 'policy') and self.policy is not None:
            _dict['policy'] = self.policy
        if hasattr(self, 'severity') and self.severity is not None:
            _dict['severity'] = self.severity
        if hasattr(self, 'job_state') and self.job_state is not None:
            _dict['job_state'] = self.job_state
        if hasattr(self, 'failures') and self.failures is not None:
            _dict['failures'] = self.failures
        if hasattr(self, 'passed') and self.passed is not None:
            _dict['passed'] = self.passed
        if hasattr(self, 'evidences') and self.evidences is not None:
            _dict['evidences'] = [x.to_dict() for x in self.evidences]
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobResultCapsule._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobResultCapsule object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobResultCapsule') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobResultCapsule') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class JobStateEnum(str, Enum):
        """
        Job state.
        """
        SUCCESS = 'success'
        FAILED = 'failed'
        TERMINATED = 'terminated'


class JobStatus():
    """
    Job Status.

    :attr float position_in_queue: (optional) Position of job in pending queue.
    :attr float total_in_queue: (optional) Total no. of jobs in pending queue.
    :attr JobStatusWorkspace workspace_job_status: (optional) Workspace Job Status.
    :attr JobStatusAction action_job_status: (optional) Action Job Status.
    :attr JobStatusSystem system_job_status: (optional) System Job Status.
    :attr JobStatusFlow flow_job_status: (optional) Environment Flow JOB Status.
    """

    # The set of defined properties for the class
    _properties = frozenset(['position_in_queue', 'total_in_queue', 'workspace_job_status', 'action_job_status', 'system_job_status', 'flow_job_status'])

    def __init__(self,
                 *,
                 position_in_queue: float = None,
                 total_in_queue: float = None,
                 workspace_job_status: 'JobStatusWorkspace' = None,
                 action_job_status: 'JobStatusAction' = None,
                 system_job_status: 'JobStatusSystem' = None,
                 flow_job_status: 'JobStatusFlow' = None,
                 **kwargs) -> None:
        """
        Initialize a JobStatus object.

        :param float position_in_queue: (optional) Position of job in pending
               queue.
        :param float total_in_queue: (optional) Total no. of jobs in pending queue.
        :param JobStatusWorkspace workspace_job_status: (optional) Workspace Job
               Status.
        :param JobStatusAction action_job_status: (optional) Action Job Status.
        :param JobStatusSystem system_job_status: (optional) System Job Status.
        :param JobStatusFlow flow_job_status: (optional) Environment Flow JOB
               Status.
        :param **kwargs: (optional) Any additional properties.
        """
        self.position_in_queue = position_in_queue
        self.total_in_queue = total_in_queue
        self.workspace_job_status = workspace_job_status
        self.action_job_status = action_job_status
        self.system_job_status = system_job_status
        self.flow_job_status = flow_job_status
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatus':
        """Initialize a JobStatus object from a json dictionary."""
        args = {}
        if 'position_in_queue' in _dict:
            args['position_in_queue'] = _dict.get('position_in_queue')
        if 'total_in_queue' in _dict:
            args['total_in_queue'] = _dict.get('total_in_queue')
        if 'workspace_job_status' in _dict:
            args['workspace_job_status'] = JobStatusWorkspace.from_dict(_dict.get('workspace_job_status'))
        if 'action_job_status' in _dict:
            args['action_job_status'] = JobStatusAction.from_dict(_dict.get('action_job_status'))
        if 'system_job_status' in _dict:
            args['system_job_status'] = JobStatusSystem.from_dict(_dict.get('system_job_status'))
        if 'flow_job_status' in _dict:
            args['flow_job_status'] = JobStatusFlow.from_dict(_dict.get('flow_job_status'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatus object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'position_in_queue') and self.position_in_queue is not None:
            _dict['position_in_queue'] = self.position_in_queue
        if hasattr(self, 'total_in_queue') and self.total_in_queue is not None:
            _dict['total_in_queue'] = self.total_in_queue
        if hasattr(self, 'workspace_job_status') and self.workspace_job_status is not None:
            _dict['workspace_job_status'] = self.workspace_job_status.to_dict()
        if hasattr(self, 'action_job_status') and self.action_job_status is not None:
            _dict['action_job_status'] = self.action_job_status.to_dict()
        if hasattr(self, 'system_job_status') and self.system_job_status is not None:
            _dict['system_job_status'] = self.system_job_status.to_dict()
        if hasattr(self, 'flow_job_status') and self.flow_job_status is not None:
            _dict['flow_job_status'] = self.flow_job_status.to_dict()
        for _key in [k for k in vars(self).keys() if k not in JobStatus._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatus object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatus') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatus') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class JobStatusAction():
    """
    Action Job Status.

    :attr str action_name: (optional) Action name.
    :attr str status_code: (optional) Status of Jobs.
    :attr str status_message: (optional) Action Job status message - to be displayed
          along with the action_status_code.
    :attr str bastion_status_code: (optional) Status of Resources.
    :attr str bastion_status_message: (optional) Bastion status message - to be
          displayed along with the bastion_status_code;.
    :attr str targets_status_code: (optional) Status of Resources.
    :attr str targets_status_message: (optional) Aggregated status message for all
          target resources,  to be displayed along with the targets_status_code;.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['action_name', 'status_code', 'status_message', 'bastion_status_code', 'bastion_status_message', 'targets_status_code', 'targets_status_message', 'updated_at'])

    def __init__(self,
                 *,
                 action_name: str = None,
                 status_code: str = None,
                 status_message: str = None,
                 bastion_status_code: str = None,
                 bastion_status_message: str = None,
                 targets_status_code: str = None,
                 targets_status_message: str = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobStatusAction object.

        :param str action_name: (optional) Action name.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) Action Job status message - to be
               displayed along with the action_status_code.
        :param str bastion_status_code: (optional) Status of Resources.
        :param str bastion_status_message: (optional) Bastion status message - to
               be displayed along with the bastion_status_code;.
        :param str targets_status_code: (optional) Status of Resources.
        :param str targets_status_message: (optional) Aggregated status message for
               all target resources,  to be displayed along with the targets_status_code;.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.action_name = action_name
        self.status_code = status_code
        self.status_message = status_message
        self.bastion_status_code = bastion_status_code
        self.bastion_status_message = bastion_status_message
        self.targets_status_code = targets_status_code
        self.targets_status_message = targets_status_message
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusAction':
        """Initialize a JobStatusAction object from a json dictionary."""
        args = {}
        if 'action_name' in _dict:
            args['action_name'] = _dict.get('action_name')
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        if 'bastion_status_code' in _dict:
            args['bastion_status_code'] = _dict.get('bastion_status_code')
        if 'bastion_status_message' in _dict:
            args['bastion_status_message'] = _dict.get('bastion_status_message')
        if 'targets_status_code' in _dict:
            args['targets_status_code'] = _dict.get('targets_status_code')
        if 'targets_status_message' in _dict:
            args['targets_status_message'] = _dict.get('targets_status_message')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusAction object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'action_name') and self.action_name is not None:
            _dict['action_name'] = self.action_name
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'bastion_status_code') and self.bastion_status_code is not None:
            _dict['bastion_status_code'] = self.bastion_status_code
        if hasattr(self, 'bastion_status_message') and self.bastion_status_message is not None:
            _dict['bastion_status_message'] = self.bastion_status_message
        if hasattr(self, 'targets_status_code') and self.targets_status_code is not None:
            _dict['targets_status_code'] = self.targets_status_code
        if hasattr(self, 'targets_status_message') and self.targets_status_message is not None:
            _dict['targets_status_message'] = self.targets_status_message
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobStatusAction._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusAction object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusAction') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusAction') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """
        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'


    class BastionStatusCodeEnum(str, Enum):
        """
        Status of Resources.
        """
        NONE = 'none'
        READY = 'ready'
        PROCESSING = 'processing'
        ERROR = 'error'


    class TargetsStatusCodeEnum(str, Enum):
        """
        Status of Resources.
        """
        NONE = 'none'
        READY = 'ready'
        PROCESSING = 'processing'
        ERROR = 'error'


class JobStatusFlow():
    """
    Environment Flow JOB Status.

    :attr str flow_id: (optional) flow id.
    :attr str flow_name: (optional) flow name.
    :attr str status_code: (optional) Status of Jobs.
    :attr str status_message: (optional) Flow Job status message - to be displayed
          along with the status_code;.
    :attr List[JobStatusWorkitem] workitems: (optional) Environment's individual
          workItem status details;.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['flow_id', 'flow_name', 'status_code', 'status_message', 'workitems', 'updated_at'])

    def __init__(self,
                 *,
                 flow_id: str = None,
                 flow_name: str = None,
                 status_code: str = None,
                 status_message: str = None,
                 workitems: List['JobStatusWorkitem'] = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobStatusFlow object.

        :param str flow_id: (optional) flow id.
        :param str flow_name: (optional) flow name.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) Flow Job status message - to be
               displayed along with the status_code;.
        :param List[JobStatusWorkitem] workitems: (optional) Environment's
               individual workItem status details;.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.flow_id = flow_id
        self.flow_name = flow_name
        self.status_code = status_code
        self.status_message = status_message
        self.workitems = workitems
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusFlow':
        """Initialize a JobStatusFlow object from a json dictionary."""
        args = {}
        if 'flow_id' in _dict:
            args['flow_id'] = _dict.get('flow_id')
        if 'flow_name' in _dict:
            args['flow_name'] = _dict.get('flow_name')
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        if 'workitems' in _dict:
            args['workitems'] = [JobStatusWorkitem.from_dict(x) for x in _dict.get('workitems')]
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusFlow object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'flow_id') and self.flow_id is not None:
            _dict['flow_id'] = self.flow_id
        if hasattr(self, 'flow_name') and self.flow_name is not None:
            _dict['flow_name'] = self.flow_name
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'workitems') and self.workitems is not None:
            _dict['workitems'] = [x.to_dict() for x in self.workitems]
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobStatusFlow._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusFlow object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusFlow') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusFlow') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """
        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'


class JobStatusSchematicsResources():
    """
    schematics Resources Job Status.

    :attr str status_code: (optional) Status of Jobs.
    :attr str status_message: (optional) system job status message.
    :attr str schematics_resource_id: (optional) id for each resource which is
          targeted as a part of system job.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['status_code', 'status_message', 'schematics_resource_id', 'updated_at'])

    def __init__(self,
                 *,
                 status_code: str = None,
                 status_message: str = None,
                 schematics_resource_id: str = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobStatusSchematicsResources object.

        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) system job status message.
        :param str schematics_resource_id: (optional) id for each resource which is
               targeted as a part of system job.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.status_code = status_code
        self.status_message = status_message
        self.schematics_resource_id = schematics_resource_id
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusSchematicsResources':
        """Initialize a JobStatusSchematicsResources object from a json dictionary."""
        args = {}
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        if 'schematics_resource_id' in _dict:
            args['schematics_resource_id'] = _dict.get('schematics_resource_id')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusSchematicsResources object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'schematics_resource_id') and self.schematics_resource_id is not None:
            _dict['schematics_resource_id'] = self.schematics_resource_id
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobStatusSchematicsResources._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusSchematicsResources object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusSchematicsResources') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusSchematicsResources') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """
        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'


class JobStatusSystem():
    """
    System Job Status.

    :attr str system_status_message: (optional) System job message.
    :attr str system_status_code: (optional) Status of Jobs.
    :attr List[JobStatusSchematicsResources] schematics_resource_status: (optional)
          job staus for each schematics resource.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['system_status_message', 'system_status_code', 'schematics_resource_status', 'updated_at'])

    def __init__(self,
                 *,
                 system_status_message: str = None,
                 system_status_code: str = None,
                 schematics_resource_status: List['JobStatusSchematicsResources'] = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobStatusSystem object.

        :param str system_status_message: (optional) System job message.
        :param str system_status_code: (optional) Status of Jobs.
        :param List[JobStatusSchematicsResources] schematics_resource_status:
               (optional) job staus for each schematics resource.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.system_status_message = system_status_message
        self.system_status_code = system_status_code
        self.schematics_resource_status = schematics_resource_status
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusSystem':
        """Initialize a JobStatusSystem object from a json dictionary."""
        args = {}
        if 'system_status_message' in _dict:
            args['system_status_message'] = _dict.get('system_status_message')
        if 'system_status_code' in _dict:
            args['system_status_code'] = _dict.get('system_status_code')
        if 'schematics_resource_status' in _dict:
            args['schematics_resource_status'] = [JobStatusSchematicsResources.from_dict(x) for x in _dict.get('schematics_resource_status')]
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusSystem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'system_status_message') and self.system_status_message is not None:
            _dict['system_status_message'] = self.system_status_message
        if hasattr(self, 'system_status_code') and self.system_status_code is not None:
            _dict['system_status_code'] = self.system_status_code
        if hasattr(self, 'schematics_resource_status') and self.schematics_resource_status is not None:
            _dict['schematics_resource_status'] = [x.to_dict() for x in self.schematics_resource_status]
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobStatusSystem._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusSystem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusSystem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusSystem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SystemStatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """
        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'


class JobStatusTemplate():
    """
    Template Job Status.

    :attr str template_id: (optional) Template Id.
    :attr str template_name: (optional) Template name.
    :attr int flow_index: (optional) Index of the template in the Flow.
    :attr str status_code: (optional) Status of Jobs.
    :attr str status_message: (optional) Template job status message (eg.
          VPCt1_Apply_Pending, for a 'VPCt1' Template).
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['template_id', 'template_name', 'flow_index', 'status_code', 'status_message', 'updated_at'])

    def __init__(self,
                 *,
                 template_id: str = None,
                 template_name: str = None,
                 flow_index: int = None,
                 status_code: str = None,
                 status_message: str = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobStatusTemplate object.

        :param str template_id: (optional) Template Id.
        :param str template_name: (optional) Template name.
        :param int flow_index: (optional) Index of the template in the Flow.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) Template job status message (eg.
               VPCt1_Apply_Pending, for a 'VPCt1' Template).
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.template_id = template_id
        self.template_name = template_name
        self.flow_index = flow_index
        self.status_code = status_code
        self.status_message = status_message
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusTemplate':
        """Initialize a JobStatusTemplate object from a json dictionary."""
        args = {}
        if 'template_id' in _dict:
            args['template_id'] = _dict.get('template_id')
        if 'template_name' in _dict:
            args['template_name'] = _dict.get('template_name')
        if 'flow_index' in _dict:
            args['flow_index'] = _dict.get('flow_index')
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusTemplate object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'template_id') and self.template_id is not None:
            _dict['template_id'] = self.template_id
        if hasattr(self, 'template_name') and self.template_name is not None:
            _dict['template_name'] = self.template_name
        if hasattr(self, 'flow_index') and self.flow_index is not None:
            _dict['flow_index'] = self.flow_index
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobStatusTemplate._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusTemplate object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusTemplate') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusTemplate') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """
        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'


class JobStatusWorkitem():
    """
    Individual workitem status info.

    :attr str workspace_id: (optional) Workspace id.
    :attr str workspace_name: (optional) workspace name.
    :attr str job_id: (optional) workspace job id.
    :attr str status_code: (optional) Status of Jobs.
    :attr str status_message: (optional) workitem job status message;.
    :attr datetime updated_at: (optional) workitem job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['workspace_id', 'workspace_name', 'job_id', 'status_code', 'status_message', 'updated_at'])

    def __init__(self,
                 *,
                 workspace_id: str = None,
                 workspace_name: str = None,
                 job_id: str = None,
                 status_code: str = None,
                 status_message: str = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobStatusWorkitem object.

        :param str workspace_id: (optional) Workspace id.
        :param str workspace_name: (optional) workspace name.
        :param str job_id: (optional) workspace job id.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) workitem job status message;.
        :param datetime updated_at: (optional) workitem job status updation
               timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.workspace_id = workspace_id
        self.workspace_name = workspace_name
        self.job_id = job_id
        self.status_code = status_code
        self.status_message = status_message
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusWorkitem':
        """Initialize a JobStatusWorkitem object from a json dictionary."""
        args = {}
        if 'workspace_id' in _dict:
            args['workspace_id'] = _dict.get('workspace_id')
        if 'workspace_name' in _dict:
            args['workspace_name'] = _dict.get('workspace_name')
        if 'job_id' in _dict:
            args['job_id'] = _dict.get('job_id')
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusWorkitem object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'workspace_id') and self.workspace_id is not None:
            _dict['workspace_id'] = self.workspace_id
        if hasattr(self, 'workspace_name') and self.workspace_name is not None:
            _dict['workspace_name'] = self.workspace_name
        if hasattr(self, 'job_id') and self.job_id is not None:
            _dict['job_id'] = self.job_id
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobStatusWorkitem._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusWorkitem object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusWorkitem') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusWorkitem') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """
        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'


class JobStatusWorkspace():
    """
    Workspace Job Status.

    :attr str workspace_name: (optional) Workspace name.
    :attr str status_code: (optional) Status of Jobs.
    :attr str status_message: (optional) Workspace job status message (eg.
          App1_Setup_Pending, for a 'Setup' flow in the 'App1' Workspace).
    :attr JobStatusFlow flow_status: (optional) Environment Flow JOB Status.
    :attr List[JobStatusTemplate] template_status: (optional) Workspace Flow
          Template job status.
    :attr datetime updated_at: (optional) Job status updation timestamp.
    :attr List[CommandsInfo] commands: (optional) List of terraform commands
          executed and their status.
    """

    # The set of defined properties for the class
    _properties = frozenset(['workspace_name', 'status_code', 'status_message', 'flow_status', 'template_status', 'updated_at', 'commands'])

    def __init__(self,
                 *,
                 workspace_name: str = None,
                 status_code: str = None,
                 status_message: str = None,
                 flow_status: 'JobStatusFlow' = None,
                 template_status: List['JobStatusTemplate'] = None,
                 updated_at: datetime = None,
                 commands: List['CommandsInfo'] = None,
                 **kwargs) -> None:
        """
        Initialize a JobStatusWorkspace object.

        :param str workspace_name: (optional) Workspace name.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) Workspace job status message (eg.
               App1_Setup_Pending, for a 'Setup' flow in the 'App1' Workspace).
        :param JobStatusFlow flow_status: (optional) Environment Flow JOB Status.
        :param List[JobStatusTemplate] template_status: (optional) Workspace Flow
               Template job status.
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.workspace_name = workspace_name
        self.status_code = status_code
        self.status_message = status_message
        self.flow_status = flow_status
        self.template_status = template_status
        self.updated_at = updated_at
        self.commands = commands
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusWorkspace':
        """Initialize a JobStatusWorkspace object from a json dictionary."""
        args = {}
        if 'workspace_name' in _dict:
            args['workspace_name'] = _dict.get('workspace_name')
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        if 'flow_status' in _dict:
            args['flow_status'] = JobStatusFlow.from_dict(_dict.get('flow_status'))
        if 'template_status' in _dict:
            args['template_status'] = [JobStatusTemplate.from_dict(x) for x in _dict.get('template_status')]
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'commands' in _dict:
            args['commands'] = [CommandsInfo.from_dict(x) for x in _dict.get('commands')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusWorkspace object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'workspace_name') and self.workspace_name is not None:
            _dict['workspace_name'] = self.workspace_name
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'flow_status') and self.flow_status is not None:
            _dict['flow_status'] = self.flow_status.to_dict()
        if hasattr(self, 'template_status') and self.template_status is not None:
            _dict['template_status'] = [x.to_dict() for x in self.template_status]
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'commands') and getattr(self, 'commands') is not None:
            _dict['commands'] = [x.to_dict() for x in getattr(self, 'commands')]
        for _key in [k for k in vars(self).keys() if k not in JobStatusWorkspace._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusWorkspace object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusWorkspace') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusWorkspace') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """
        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'


class JobStatusWorkspaceTemplateFlow():
    """
    Flow Job Status.

    :attr str flow_id: (optional) Flow Id.
    :attr str flow_name: (optional) Flow name.
    :attr str status_code: (optional) Status of Jobs.
    :attr str status_message: (optional) Workspace Flow job status message (eg.
          Setup_Apply_Pending, for a 'Setup' Flow).
    :attr datetime updated_at: (optional) Job status updation timestamp.
    """

    # The set of defined properties for the class
    _properties = frozenset(['flow_id', 'flow_name', 'status_code', 'status_message', 'updated_at'])

    def __init__(self,
                 *,
                 flow_id: str = None,
                 flow_name: str = None,
                 status_code: str = None,
                 status_message: str = None,
                 updated_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a JobStatusWorkspaceTemplateFlow object.

        :param str flow_id: (optional) Flow Id.
        :param str flow_name: (optional) Flow name.
        :param str status_code: (optional) Status of Jobs.
        :param str status_message: (optional) Workspace Flow job status message
               (eg. Setup_Apply_Pending, for a 'Setup' Flow).
        :param datetime updated_at: (optional) Job status updation timestamp.
        :param **kwargs: (optional) Any additional properties.
        """
        self.flow_id = flow_id
        self.flow_name = flow_name
        self.status_code = status_code
        self.status_message = status_message
        self.updated_at = updated_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'JobStatusWorkspaceTemplateFlow':
        """Initialize a JobStatusWorkspaceTemplateFlow object from a json dictionary."""
        args = {}
        if 'flow_id' in _dict:
            args['flow_id'] = _dict.get('flow_id')
        if 'flow_name' in _dict:
            args['flow_name'] = _dict.get('flow_name')
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a JobStatusWorkspaceTemplateFlow object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'flow_id') and self.flow_id is not None:
            _dict['flow_id'] = self.flow_id
        if hasattr(self, 'flow_name') and self.flow_name is not None:
            _dict['flow_name'] = self.flow_name
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        for _key in [k for k in vars(self).keys() if k not in JobStatusWorkspaceTemplateFlow._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this JobStatusWorkspaceTemplateFlow object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'JobStatusWorkspaceTemplateFlow') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'JobStatusWorkspaceTemplateFlow') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of Jobs.
        """
        JOB_PENDING = 'job_pending'
        JOB_IN_PROGRESS = 'job_in_progress'
        JOB_FINISHED = 'job_finished'
        JOB_FAILED = 'job_failed'
        JOB_CANCELLED = 'job_cancelled'


class KMSDiscovery():
    """
    Discover kms instances in the account based on location.

    :attr int total_count: (optional) The total number of records.
    :attr int limit: The number of records returned.
    :attr int offset: The skipped number of records.
    :attr List[KMSInstances] kms_instances: (optional) The list of kms instances.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'kms_instances'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 kms_instances: List['KMSInstances'] = None,
                 **kwargs) -> None:
        """
        Initialize a KMSDiscovery object.

        :param int limit: The number of records returned.
        :param int offset: The skipped number of records.
        :param int total_count: (optional) The total number of records.
        :param List[KMSInstances] kms_instances: (optional) The list of kms
               instances.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.kms_instances = kms_instances
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSDiscovery':
        """Initialize a KMSDiscovery object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in KMSDiscovery JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in KMSDiscovery JSON')
        if 'kms_instances' in _dict:
            args['kms_instances'] = [KMSInstances.from_dict(x) for x in _dict.get('kms_instances')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSDiscovery object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'kms_instances') and self.kms_instances is not None:
            _dict['kms_instances'] = [x.to_dict() for x in self.kms_instances]
        for _key in [k for k in vars(self).keys() if k not in KMSDiscovery._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSDiscovery object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSDiscovery') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSDiscovery') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class KMSInstances():
    """
    User defined kms instances.

    :attr str location: (optional) The location to integrate kms instance. For
          example, location can be `US` and `EU`.
    :attr str encryption_scheme: (optional) The encryption scheme values.
          **Allowable values** [`byok`,`kyok`].
    :attr str resource_group: (optional) The kms instance resource group to
          integrate.
    :attr str kms_crn: (optional) The primary kms CRN information.
    :attr str kms_name: (optional) The kms instance name.
    :attr str kms_private_endpoint: (optional) The kms instance private endpoints.
    :attr str kms_public_endpoint: (optional) The kms instance public endpoints.
    :attr List[KMSInstancesKeys] keys: (optional) Detailed list of keys.
    """

    # The set of defined properties for the class
    _properties = frozenset(['location', 'encryption_scheme', 'resource_group', 'kms_crn', 'kms_name', 'kms_private_endpoint', 'kms_public_endpoint', 'keys'])

    def __init__(self,
                 *,
                 location: str = None,
                 encryption_scheme: str = None,
                 resource_group: str = None,
                 kms_crn: str = None,
                 kms_name: str = None,
                 kms_private_endpoint: str = None,
                 kms_public_endpoint: str = None,
                 keys: List['KMSInstancesKeys'] = None,
                 **kwargs) -> None:
        """
        Initialize a KMSInstances object.

        :param str location: (optional) The location to integrate kms instance. For
               example, location can be `US` and `EU`.
        :param str encryption_scheme: (optional) The encryption scheme values.
               **Allowable values** [`byok`,`kyok`].
        :param str resource_group: (optional) The kms instance resource group to
               integrate.
        :param str kms_crn: (optional) The primary kms CRN information.
        :param str kms_name: (optional) The kms instance name.
        :param str kms_private_endpoint: (optional) The kms instance private
               endpoints.
        :param str kms_public_endpoint: (optional) The kms instance public
               endpoints.
        :param List[KMSInstancesKeys] keys: (optional) Detailed list of keys.
        :param **kwargs: (optional) Any additional properties.
        """
        self.location = location
        self.encryption_scheme = encryption_scheme
        self.resource_group = resource_group
        self.kms_crn = kms_crn
        self.kms_name = kms_name
        self.kms_private_endpoint = kms_private_endpoint
        self.kms_public_endpoint = kms_public_endpoint
        self.keys = keys
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSInstances':
        """Initialize a KMSInstances object from a json dictionary."""
        args = {}
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'encryption_scheme' in _dict:
            args['encryption_scheme'] = _dict.get('encryption_scheme')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'kms_crn' in _dict:
            args['kms_crn'] = _dict.get('kms_crn')
        if 'kms_name' in _dict:
            args['kms_name'] = _dict.get('kms_name')
        if 'kms_private_endpoint' in _dict:
            args['kms_private_endpoint'] = _dict.get('kms_private_endpoint')
        if 'kms_public_endpoint' in _dict:
            args['kms_public_endpoint'] = _dict.get('kms_public_endpoint')
        if 'keys' in _dict:
            args['keys'] = [KMSInstancesKeys.from_dict(x) for x in _dict.get('keys')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSInstances object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'encryption_scheme') and self.encryption_scheme is not None:
            _dict['encryption_scheme'] = self.encryption_scheme
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'kms_crn') and self.kms_crn is not None:
            _dict['kms_crn'] = self.kms_crn
        if hasattr(self, 'kms_name') and self.kms_name is not None:
            _dict['kms_name'] = self.kms_name
        if hasattr(self, 'kms_private_endpoint') and self.kms_private_endpoint is not None:
            _dict['kms_private_endpoint'] = self.kms_private_endpoint
        if hasattr(self, 'kms_public_endpoint') and self.kms_public_endpoint is not None:
            _dict['kms_public_endpoint'] = self.kms_public_endpoint
        if hasattr(self, 'keys') and self.keys is not None:
            _dict['keys'] = [x.to_dict() for x in self.keys]
        for _key in [k for k in vars(self).keys() if k not in KMSInstances._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSInstances object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSInstances') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSInstances') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class KMSInstancesKeys():
    """
    KMSInstancesKeys.

    :attr str name: (optional) The name of the root key.
    :attr str crn: (optional) The kms CRN of the root key.
    :attr str error: (optional) The error message details.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'crn', 'error'])

    def __init__(self,
                 *,
                 name: str = None,
                 crn: str = None,
                 error: str = None,
                 **kwargs) -> None:
        """
        Initialize a KMSInstancesKeys object.

        :param str name: (optional) The name of the root key.
        :param str crn: (optional) The kms CRN of the root key.
        :param str error: (optional) The error message details.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.crn = crn
        self.error = error
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSInstancesKeys':
        """Initialize a KMSInstancesKeys object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'error' in _dict:
            args['error'] = _dict.get('error')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSInstancesKeys object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'error') and self.error is not None:
            _dict['error'] = self.error
        for _key in [k for k in vars(self).keys() if k not in KMSInstancesKeys._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSInstancesKeys object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSInstancesKeys') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSInstancesKeys') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class KMSSettings():
    """
    User defined kms settings information.

    :attr str location: (optional) The location to integrate kms instance. For
          example, location can be `US` and `EU`.
    :attr str encryption_scheme: (optional) The encryption scheme values.
          **Allowable values** [`byok`,`kyok`].
    :attr str resource_group: (optional) The kms instance resource group to
          integrate.
    :attr KMSSettingsPrimaryCrk primary_crk: (optional) The primary kms instance
          details.
    :attr KMSSettingsSecondaryCrk secondary_crk: (optional) The secondary kms
          instance details.
    """

    # The set of defined properties for the class
    _properties = frozenset(['location', 'encryption_scheme', 'resource_group', 'primary_crk', 'secondary_crk'])

    def __init__(self,
                 *,
                 location: str = None,
                 encryption_scheme: str = None,
                 resource_group: str = None,
                 primary_crk: 'KMSSettingsPrimaryCrk' = None,
                 secondary_crk: 'KMSSettingsSecondaryCrk' = None,
                 **kwargs) -> None:
        """
        Initialize a KMSSettings object.

        :param str location: (optional) The location to integrate kms instance. For
               example, location can be `US` and `EU`.
        :param str encryption_scheme: (optional) The encryption scheme values.
               **Allowable values** [`byok`,`kyok`].
        :param str resource_group: (optional) The kms instance resource group to
               integrate.
        :param KMSSettingsPrimaryCrk primary_crk: (optional) The primary kms
               instance details.
        :param KMSSettingsSecondaryCrk secondary_crk: (optional) The secondary kms
               instance details.
        :param **kwargs: (optional) Any additional properties.
        """
        self.location = location
        self.encryption_scheme = encryption_scheme
        self.resource_group = resource_group
        self.primary_crk = primary_crk
        self.secondary_crk = secondary_crk
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSSettings':
        """Initialize a KMSSettings object from a json dictionary."""
        args = {}
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'encryption_scheme' in _dict:
            args['encryption_scheme'] = _dict.get('encryption_scheme')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'primary_crk' in _dict:
            args['primary_crk'] = KMSSettingsPrimaryCrk.from_dict(_dict.get('primary_crk'))
        if 'secondary_crk' in _dict:
            args['secondary_crk'] = KMSSettingsSecondaryCrk.from_dict(_dict.get('secondary_crk'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSSettings object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'encryption_scheme') and self.encryption_scheme is not None:
            _dict['encryption_scheme'] = self.encryption_scheme
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'primary_crk') and self.primary_crk is not None:
            _dict['primary_crk'] = self.primary_crk.to_dict()
        if hasattr(self, 'secondary_crk') and self.secondary_crk is not None:
            _dict['secondary_crk'] = self.secondary_crk.to_dict()
        for _key in [k for k in vars(self).keys() if k not in KMSSettings._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSSettings object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSSettings') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSSettings') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class KMSSettingsPrimaryCrk():
    """
    The primary kms instance details.

    :attr str kms_name: (optional) The primary kms instance name.
    :attr str kms_private_endpoint: (optional) The primary kms instance private
          endpoint.
    :attr str key_crn: (optional) The CRN of the primary root key.
    """

    # The set of defined properties for the class
    _properties = frozenset(['kms_name', 'kms_private_endpoint', 'key_crn'])

    def __init__(self,
                 *,
                 kms_name: str = None,
                 kms_private_endpoint: str = None,
                 key_crn: str = None,
                 **kwargs) -> None:
        """
        Initialize a KMSSettingsPrimaryCrk object.

        :param str kms_name: (optional) The primary kms instance name.
        :param str kms_private_endpoint: (optional) The primary kms instance
               private endpoint.
        :param str key_crn: (optional) The CRN of the primary root key.
        :param **kwargs: (optional) Any additional properties.
        """
        self.kms_name = kms_name
        self.kms_private_endpoint = kms_private_endpoint
        self.key_crn = key_crn
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSSettingsPrimaryCrk':
        """Initialize a KMSSettingsPrimaryCrk object from a json dictionary."""
        args = {}
        if 'kms_name' in _dict:
            args['kms_name'] = _dict.get('kms_name')
        if 'kms_private_endpoint' in _dict:
            args['kms_private_endpoint'] = _dict.get('kms_private_endpoint')
        if 'key_crn' in _dict:
            args['key_crn'] = _dict.get('key_crn')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSSettingsPrimaryCrk object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'kms_name') and self.kms_name is not None:
            _dict['kms_name'] = self.kms_name
        if hasattr(self, 'kms_private_endpoint') and self.kms_private_endpoint is not None:
            _dict['kms_private_endpoint'] = self.kms_private_endpoint
        if hasattr(self, 'key_crn') and self.key_crn is not None:
            _dict['key_crn'] = self.key_crn
        for _key in [k for k in vars(self).keys() if k not in KMSSettingsPrimaryCrk._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSSettingsPrimaryCrk object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSSettingsPrimaryCrk') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSSettingsPrimaryCrk') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class KMSSettingsSecondaryCrk():
    """
    The secondary kms instance details.

    :attr str kms_name: (optional) The secondary kms instance name.
    :attr str kms_private_endpoint: (optional) The secondary kms instance private
          endpoint.
    :attr str key_crn: (optional) The CRN of the secondary key.
    """

    # The set of defined properties for the class
    _properties = frozenset(['kms_name', 'kms_private_endpoint', 'key_crn'])

    def __init__(self,
                 *,
                 kms_name: str = None,
                 kms_private_endpoint: str = None,
                 key_crn: str = None,
                 **kwargs) -> None:
        """
        Initialize a KMSSettingsSecondaryCrk object.

        :param str kms_name: (optional) The secondary kms instance name.
        :param str kms_private_endpoint: (optional) The secondary kms instance
               private endpoint.
        :param str key_crn: (optional) The CRN of the secondary key.
        :param **kwargs: (optional) Any additional properties.
        """
        self.kms_name = kms_name
        self.kms_private_endpoint = kms_private_endpoint
        self.key_crn = key_crn
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'KMSSettingsSecondaryCrk':
        """Initialize a KMSSettingsSecondaryCrk object from a json dictionary."""
        args = {}
        if 'kms_name' in _dict:
            args['kms_name'] = _dict.get('kms_name')
        if 'kms_private_endpoint' in _dict:
            args['kms_private_endpoint'] = _dict.get('kms_private_endpoint')
        if 'key_crn' in _dict:
            args['key_crn'] = _dict.get('key_crn')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a KMSSettingsSecondaryCrk object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'kms_name') and self.kms_name is not None:
            _dict['kms_name'] = self.kms_name
        if hasattr(self, 'kms_private_endpoint') and self.kms_private_endpoint is not None:
            _dict['kms_private_endpoint'] = self.kms_private_endpoint
        if hasattr(self, 'key_crn') and self.key_crn is not None:
            _dict['key_crn'] = self.key_crn
        for _key in [k for k in vars(self).keys() if k not in KMSSettingsSecondaryCrk._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this KMSSettingsSecondaryCrk object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'KMSSettingsSecondaryCrk') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'KMSSettingsSecondaryCrk') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class OrderItemConfiguration():
    """
    Catalog item configuration in the Cart order.

    :attr str name: (optional) Catalog item name.
    :attr str description: (optional) Catalog item description.
    :attr List[VariableData] inputs: (optional) Input configuration for the order.
    :attr List[VariableData] settings: (optional) Input environment variables used
          by order.
    :attr List[VariableData] outputs: (optional) Output configuration of the order.
    :attr TargetRequest target: (optional) Target cluster details to perform POC
          operation.
    :attr str operation: (optional) Name of the fulfilment job operations.
    :attr List[ServiceVariableData] service_data: (optional) Additional service
          input data (for extensibility).
    :attr str catalog_id: Catalog Id.
    :attr str offering_id: offering Id.
    :attr str owning_account: (optional) Account ID where catalog is created.
    :attr str owning_account_crn: (optional) CRN of account where catalog is
          created.
    :attr str offering_kind_id: (optional) Offering kind id.
    :attr str offering_target_kind: (optional) Offering Target Kind.
    :attr str offering_version_id: (optional) Offering version id.
    :attr str offering_kind: (optional) Offering kind.
    :attr str offering_fulfilment_kind: (optional) Offering fulfilment kind.
    :attr str offering_version: (optional) Offering version.
    :attr str offering_provisioner_url: (optional) Repo URL where the provisioner
          can be found.
    :attr str offering_provisioner_ssh: (optional) SHA value of Repo URL.
    :attr str offering_provisioner_working_directory: (optional) Root folder name in
          .tgz file.
    :attr ItemSKU item_sku: (optional) Store Keeping Unit for the Item in the Cart
          order.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'inputs', 'settings', 'outputs', 'target', 'operation', 'service_data', 'catalog_id', 'offering_id', 'owning_account', 'owning_account_crn', 'offering_kind_id', 'offering_target_kind', 'offering_version_id', 'offering_kind', 'offering_fulfilment_kind', 'offering_version', 'offering_provisioner_url', 'offering_provisioner_ssh', 'offering_provisioner_working_directory', 'item_sku'])

    def __init__(self,
                 catalog_id: str,
                 offering_id: str,
                 *,
                 name: str = None,
                 description: str = None,
                 inputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 outputs: List['VariableData'] = None,
                 target: 'TargetRequest' = None,
                 operation: str = None,
                 service_data: List['ServiceVariableData'] = None,
                 owning_account: str = None,
                 owning_account_crn: str = None,
                 offering_kind_id: str = None,
                 offering_target_kind: str = None,
                 offering_version_id: str = None,
                 offering_kind: str = None,
                 offering_fulfilment_kind: str = None,
                 offering_version: str = None,
                 offering_provisioner_url: str = None,
                 offering_provisioner_ssh: str = None,
                 offering_provisioner_working_directory: str = None,
                 item_sku: 'ItemSKU' = None,
                 **kwargs) -> None:
        """
        Initialize a OrderItemConfiguration object.

        :param str catalog_id: Catalog Id.
        :param str offering_id: offering Id.
        :param str name: (optional) Catalog item name.
        :param str description: (optional) Catalog item description.
        :param List[VariableData] inputs: (optional) Input configuration for the
               order.
        :param List[VariableData] settings: (optional) Input environment variables
               used by order.
        :param List[VariableData] outputs: (optional) Output configuration of the
               order.
        :param TargetRequest target: (optional) Target cluster details to perform
               POC operation.
        :param str operation: (optional) Name of the fulfilment job operations.
        :param List[ServiceVariableData] service_data: (optional) Additional
               service input data (for extensibility).
        :param str owning_account: (optional) Account ID where catalog is created.
        :param str owning_account_crn: (optional) CRN of account where catalog is
               created.
        :param str offering_kind_id: (optional) Offering kind id.
        :param str offering_target_kind: (optional) Offering Target Kind.
        :param str offering_version_id: (optional) Offering version id.
        :param str offering_kind: (optional) Offering kind.
        :param str offering_fulfilment_kind: (optional) Offering fulfilment kind.
        :param str offering_version: (optional) Offering version.
        :param str offering_provisioner_url: (optional) Repo URL where the
               provisioner can be found.
        :param str offering_provisioner_ssh: (optional) SHA value of Repo URL.
        :param str offering_provisioner_working_directory: (optional) Root folder
               name in .tgz file.
        :param ItemSKU item_sku: (optional) Store Keeping Unit for the Item in the
               Cart order.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.inputs = inputs
        self.settings = settings
        self.outputs = outputs
        self.target = target
        self.operation = operation
        self.service_data = service_data
        self.catalog_id = catalog_id
        self.offering_id = offering_id
        self.owning_account = owning_account
        self.owning_account_crn = owning_account_crn
        self.offering_kind_id = offering_kind_id
        self.offering_target_kind = offering_target_kind
        self.offering_version_id = offering_version_id
        self.offering_kind = offering_kind
        self.offering_fulfilment_kind = offering_fulfilment_kind
        self.offering_version = offering_version
        self.offering_provisioner_url = offering_provisioner_url
        self.offering_provisioner_ssh = offering_provisioner_ssh
        self.offering_provisioner_working_directory = offering_provisioner_working_directory
        self.item_sku = item_sku
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'OrderItemConfiguration':
        """Initialize a OrderItemConfiguration object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        if 'target' in _dict:
            args['target'] = TargetRequest.from_dict(_dict.get('target'))
        if 'operation' in _dict:
            args['operation'] = _dict.get('operation')
        if 'service_data' in _dict:
            args['service_data'] = [ServiceVariableData.from_dict(x) for x in _dict.get('service_data')]
        if 'catalog_id' in _dict:
            args['catalog_id'] = _dict.get('catalog_id')
        else:
            raise ValueError('Required property \'catalog_id\' not present in OrderItemConfiguration JSON')
        if 'offering_id' in _dict:
            args['offering_id'] = _dict.get('offering_id')
        else:
            raise ValueError('Required property \'offering_id\' not present in OrderItemConfiguration JSON')
        if 'owning_account' in _dict:
            args['owning_account'] = _dict.get('owning_account')
        if 'owning_account_crn' in _dict:
            args['owning_account_crn'] = _dict.get('owning_account_crn')
        if 'offering_kind_id' in _dict:
            args['offering_kind_id'] = _dict.get('offering_kind_id')
        if 'offering_target_kind' in _dict:
            args['offering_target_kind'] = _dict.get('offering_target_kind')
        if 'offering_version_id' in _dict:
            args['offering_version_id'] = _dict.get('offering_version_id')
        if 'offering_kind' in _dict:
            args['offering_kind'] = _dict.get('offering_kind')
        if 'offering_fulfilment_kind' in _dict:
            args['offering_fulfilment_kind'] = _dict.get('offering_fulfilment_kind')
        if 'offering_version' in _dict:
            args['offering_version'] = _dict.get('offering_version')
        if 'offering_provisioner_url' in _dict:
            args['offering_provisioner_url'] = _dict.get('offering_provisioner_url')
        if 'offering_provisioner_ssh' in _dict:
            args['offering_provisioner_ssh'] = _dict.get('offering_provisioner_ssh')
        if 'offering_provisioner_working_directory' in _dict:
            args['offering_provisioner_working_directory'] = _dict.get('offering_provisioner_working_directory')
        if 'item_sku' in _dict:
            args['item_sku'] = ItemSKU.from_dict(_dict.get('item_sku'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a OrderItemConfiguration object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        if hasattr(self, 'target') and self.target is not None:
            _dict['target'] = self.target.to_dict()
        if hasattr(self, 'operation') and self.operation is not None:
            _dict['operation'] = self.operation
        if hasattr(self, 'service_data') and self.service_data is not None:
            _dict['service_data'] = [x.to_dict() for x in self.service_data]
        if hasattr(self, 'catalog_id') and self.catalog_id is not None:
            _dict['catalog_id'] = self.catalog_id
        if hasattr(self, 'offering_id') and self.offering_id is not None:
            _dict['offering_id'] = self.offering_id
        if hasattr(self, 'owning_account') and self.owning_account is not None:
            _dict['owning_account'] = self.owning_account
        if hasattr(self, 'owning_account_crn') and self.owning_account_crn is not None:
            _dict['owning_account_crn'] = self.owning_account_crn
        if hasattr(self, 'offering_kind_id') and self.offering_kind_id is not None:
            _dict['offering_kind_id'] = self.offering_kind_id
        if hasattr(self, 'offering_target_kind') and self.offering_target_kind is not None:
            _dict['offering_target_kind'] = self.offering_target_kind
        if hasattr(self, 'offering_version_id') and self.offering_version_id is not None:
            _dict['offering_version_id'] = self.offering_version_id
        if hasattr(self, 'offering_kind') and self.offering_kind is not None:
            _dict['offering_kind'] = self.offering_kind
        if hasattr(self, 'offering_fulfilment_kind') and self.offering_fulfilment_kind is not None:
            _dict['offering_fulfilment_kind'] = self.offering_fulfilment_kind
        if hasattr(self, 'offering_version') and self.offering_version is not None:
            _dict['offering_version'] = self.offering_version
        if hasattr(self, 'offering_provisioner_url') and self.offering_provisioner_url is not None:
            _dict['offering_provisioner_url'] = self.offering_provisioner_url
        if hasattr(self, 'offering_provisioner_ssh') and self.offering_provisioner_ssh is not None:
            _dict['offering_provisioner_ssh'] = self.offering_provisioner_ssh
        if hasattr(self, 'offering_provisioner_working_directory') and self.offering_provisioner_working_directory is not None:
            _dict['offering_provisioner_working_directory'] = self.offering_provisioner_working_directory
        if hasattr(self, 'item_sku') and self.item_sku is not None:
            _dict['item_sku'] = self.item_sku.to_dict()
        for _key in [k for k in vars(self).keys() if k not in OrderItemConfiguration._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this OrderItemConfiguration object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'OrderItemConfiguration') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'OrderItemConfiguration') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class OperationEnum(str, Enum):
        """
        Name of the fulfilment job operations.
        """
        CONFIGURE = 'configure'
        DESTROY = 'destroy'
        DRYRUN = 'dryrun'
        INSTALL = 'install'
        OPERATE = 'operate'
        PREVIEW = 'preview'
        UNINSTALL = 'uninstall'
        UPDATE = 'update'


class OutputVariableDataList():
    """
    List of Output variable data record response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[VariableData] outputs: (optional) List of output variables and
          values.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'outputs'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 outputs: List['VariableData'] = None,
                 **kwargs) -> None:
        """
        Initialize a OutputVariableDataList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[VariableData] outputs: (optional) List of output variables and
               values.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.outputs = outputs
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'OutputVariableDataList':
        """Initialize a OutputVariableDataList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in OutputVariableDataList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in OutputVariableDataList JSON')
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a OutputVariableDataList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        for _key in [k for k in vars(self).keys() if k not in OutputVariableDataList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this OutputVariableDataList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'OutputVariableDataList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'OutputVariableDataList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class PreviewData():
    """
    Preview of the data from the external datastore.

    :attr str type: (optional) Type of the data; keys only or key-values.
    :attr str connection: (optional) Name of the connection used to fetch the data.
    :attr List[VariableData] data: (optional)
    :attr str version: (optional) Version of the data fetched from the external
          store.
    :attr str message: (optional) Error or warning message while fetching data from
          the external store.
    :attr datetime viewed_at: (optional) Preview the data at timestamp.
    :attr str viewed_by: (optional) Email address of user who previewed the data.
    """

    # The set of defined properties for the class
    _properties = frozenset(['type', 'connection', 'data', 'version', 'message', 'viewed_at', 'viewed_by'])

    def __init__(self,
                 *,
                 type: str = None,
                 connection: str = None,
                 data: List['VariableData'] = None,
                 version: str = None,
                 message: str = None,
                 viewed_at: datetime = None,
                 viewed_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a PreviewData object.

        :param str connection: (optional) Name of the connection used to fetch the
               data.
        :param List[VariableData] data: (optional)
        :param str version: (optional) Version of the data fetched from the
               external store.
        :param **kwargs: (optional) Any additional properties.
        """
        self.type = type
        self.connection = connection
        self.data = data
        self.version = version
        self.message = message
        self.viewed_at = viewed_at
        self.viewed_by = viewed_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PreviewData':
        """Initialize a PreviewData object from a json dictionary."""
        args = {}
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'connection' in _dict:
            args['connection'] = _dict.get('connection')
        if 'data' in _dict:
            args['data'] = [VariableData.from_dict(x) for x in _dict.get('data')]
        if 'version' in _dict:
            args['version'] = _dict.get('version')
        if 'message' in _dict:
            args['message'] = _dict.get('message')
        if 'viewed_at' in _dict:
            args['viewed_at'] = string_to_datetime(_dict.get('viewed_at'))
        if 'viewed_by' in _dict:
            args['viewed_by'] = _dict.get('viewed_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PreviewData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and getattr(self, 'type') is not None:
            _dict['type'] = getattr(self, 'type')
        if hasattr(self, 'connection') and self.connection is not None:
            _dict['connection'] = self.connection
        if hasattr(self, 'data') and self.data is not None:
            _dict['data'] = [x.to_dict() for x in self.data]
        if hasattr(self, 'version') and self.version is not None:
            _dict['version'] = self.version
        if hasattr(self, 'message') and getattr(self, 'message') is not None:
            _dict['message'] = getattr(self, 'message')
        if hasattr(self, 'viewed_at') and getattr(self, 'viewed_at') is not None:
            _dict['viewed_at'] = datetime_to_string(getattr(self, 'viewed_at'))
        if hasattr(self, 'viewed_by') and getattr(self, 'viewed_by') is not None:
            _dict['viewed_by'] = getattr(self, 'viewed_by')
        for _key in [k for k in vars(self).keys() if k not in PreviewData._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PreviewData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PreviewData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PreviewData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Type of the data; keys only or key-values.
        """
        ALL = 'all'
        KEYS = 'keys'


class PrivateCluster():
    """
    Complete Private cluster details provided by user and system generated.

    :attr str cluster_id: (optional) Id of the remote K8s Cluster to run the
          Schematics Jobs.
    :attr str kube_config: (optional) Kube Config to connect to the Cluster.
    :attr List[str] tags: (optional) SchematicsJobCluster definition tags.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr str registered_by: (optional) Name of the user who registered the remote
          K8s cluster.
    :attr datetime registered_at: (optional) Timestamp of SchematicsJobCluster
          registration.
    :attr datetime updated_at: (optional) SchematicsJobCluster updation time.
    :attr str updated_by: (optional) Name of user who updated the
          SchematicsJobCluster definitio.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr str cluster_health: (optional) Health of the remote Cluster.
    :attr datetime last_health_checked_at: (optional) Timestamp of the last health
          check.
    """

    # The set of defined properties for the class
    _properties = frozenset(['cluster_id', 'kube_config', 'tags', 'user_state', 'registered_by', 'registered_at', 'updated_at', 'updated_by', 'sys_lock', 'cluster_health', 'last_health_checked_at'])

    def __init__(self,
                 *,
                 cluster_id: str = None,
                 kube_config: str = None,
                 tags: List[str] = None,
                 user_state: 'UserState' = None,
                 registered_by: str = None,
                 registered_at: datetime = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 sys_lock: 'SystemLock' = None,
                 cluster_health: str = None,
                 last_health_checked_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a PrivateCluster object.

        :param str cluster_id: (optional) Id of the remote K8s Cluster to run the
               Schematics Jobs.
        :param str kube_config: (optional) Kube Config to connect to the Cluster.
        :param List[str] tags: (optional) SchematicsJobCluster definition tags.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param str registered_by: (optional) Name of the user who registered the
               remote K8s cluster.
        :param datetime registered_at: (optional) Timestamp of SchematicsJobCluster
               registration.
        :param datetime updated_at: (optional) SchematicsJobCluster updation time.
        :param str updated_by: (optional) Name of user who updated the
               SchematicsJobCluster definitio.
        :param SystemLock sys_lock: (optional) System lock status.
        :param str cluster_health: (optional) Health of the remote Cluster.
        :param datetime last_health_checked_at: (optional) Timestamp of the last
               health check.
        :param **kwargs: (optional) Any additional properties.
        """
        self.cluster_id = cluster_id
        self.kube_config = kube_config
        self.tags = tags
        self.user_state = user_state
        self.registered_by = registered_by
        self.registered_at = registered_at
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.sys_lock = sys_lock
        self.cluster_health = cluster_health
        self.last_health_checked_at = last_health_checked_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateCluster':
        """Initialize a PrivateCluster object from a json dictionary."""
        args = {}
        if 'cluster_id' in _dict:
            args['cluster_id'] = _dict.get('cluster_id')
        if 'kube_config' in _dict:
            args['kube_config'] = _dict.get('kube_config')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'registered_by' in _dict:
            args['registered_by'] = _dict.get('registered_by')
        if 'registered_at' in _dict:
            args['registered_at'] = string_to_datetime(_dict.get('registered_at'))
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'cluster_health' in _dict:
            args['cluster_health'] = _dict.get('cluster_health')
        if 'last_health_checked_at' in _dict:
            args['last_health_checked_at'] = string_to_datetime(_dict.get('last_health_checked_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateCluster object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'cluster_id') and self.cluster_id is not None:
            _dict['cluster_id'] = self.cluster_id
        if hasattr(self, 'kube_config') and self.kube_config is not None:
            _dict['kube_config'] = self.kube_config
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'registered_by') and self.registered_by is not None:
            _dict['registered_by'] = self.registered_by
        if hasattr(self, 'registered_at') and self.registered_at is not None:
            _dict['registered_at'] = datetime_to_string(self.registered_at)
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'updated_by') and self.updated_by is not None:
            _dict['updated_by'] = self.updated_by
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'cluster_health') and self.cluster_health is not None:
            _dict['cluster_health'] = self.cluster_health
        if hasattr(self, 'last_health_checked_at') and self.last_health_checked_at is not None:
            _dict['last_health_checked_at'] = datetime_to_string(self.last_health_checked_at)
        for _key in [k for k in vars(self).keys() if k not in PrivateCluster._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateCluster object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateCluster') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateCluster') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ClusterHealthEnum(str, Enum):
        """
        Health of the remote Cluster.
        """
        ACTIVE = 'active'
        INACTIVE = 'inactive'


class PrivateClusterList():
    """
    Private Cluster details response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[PrivateCluster] clusters: (optional) List of private clusters.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'clusters'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 clusters: List['PrivateCluster'] = None,
                 **kwargs) -> None:
        """
        Initialize a PrivateClusterList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[PrivateCluster] clusters: (optional) List of private clusters.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.clusters = clusters
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'PrivateClusterList':
        """Initialize a PrivateClusterList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in PrivateClusterList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in PrivateClusterList JSON')
        if 'clusters' in _dict:
            args['clusters'] = [PrivateCluster.from_dict(x) for x in _dict.get('clusters')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a PrivateClusterList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'clusters') and self.clusters is not None:
            _dict['clusters'] = [x.to_dict() for x in self.clusters]
        for _key in [k for k in vars(self).keys() if k not in PrivateClusterList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this PrivateClusterList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'PrivateClusterList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'PrivateClusterList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ResourceQuery():
    """
    Describe resource query.

    :attr str query_type: (optional) Type of the query(workspaces).
    :attr List[ResourceQueryParam] query_condition: (optional)
    :attr List[str] query_select: (optional) List of query selection parameters.
    """

    # The set of defined properties for the class
    _properties = frozenset(['query_type', 'query_condition', 'query_select'])

    def __init__(self,
                 *,
                 query_type: str = None,
                 query_condition: List['ResourceQueryParam'] = None,
                 query_select: List[str] = None,
                 **kwargs) -> None:
        """
        Initialize a ResourceQuery object.

        :param str query_type: (optional) Type of the query(workspaces).
        :param List[ResourceQueryParam] query_condition: (optional)
        :param List[str] query_select: (optional) List of query selection
               parameters.
        :param **kwargs: (optional) Any additional properties.
        """
        self.query_type = query_type
        self.query_condition = query_condition
        self.query_select = query_select
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQuery':
        """Initialize a ResourceQuery object from a json dictionary."""
        args = {}
        if 'query_type' in _dict:
            args['query_type'] = _dict.get('query_type')
        if 'query_condition' in _dict:
            args['query_condition'] = [ResourceQueryParam.from_dict(x) for x in _dict.get('query_condition')]
        if 'query_select' in _dict:
            args['query_select'] = _dict.get('query_select')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQuery object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'query_type') and self.query_type is not None:
            _dict['query_type'] = self.query_type
        if hasattr(self, 'query_condition') and self.query_condition is not None:
            _dict['query_condition'] = [x.to_dict() for x in self.query_condition]
        if hasattr(self, 'query_select') and self.query_select is not None:
            _dict['query_select'] = self.query_select
        for _key in [k for k in vars(self).keys() if k not in ResourceQuery._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQuery object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQuery') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQuery') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class QueryTypeEnum(str, Enum):
        """
        Type of the query(workspaces).
        """
        WORKSPACES = 'workspaces'


class ResourceQueryDefinition():
    """
    Describe resource query definition.

    :attr str type: (optional) Resource type (cluster, vsi, icd, vpc).
    :attr str name: (optional) Resource query name.
    :attr List[ResourceQuery] queries: (optional)
    """

    # The set of defined properties for the class
    _properties = frozenset(['type', 'name', 'queries'])

    def __init__(self,
                 *,
                 type: str = None,
                 name: str = None,
                 queries: List['ResourceQuery'] = None,
                 **kwargs) -> None:
        """
        Initialize a ResourceQueryDefinition object.

        :param str type: (optional) Resource type (cluster, vsi, icd, vpc).
        :param str name: (optional) Resource query name.
        :param List[ResourceQuery] queries: (optional)
        :param **kwargs: (optional) Any additional properties.
        """
        self.type = type
        self.name = name
        self.queries = queries
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryDefinition':
        """Initialize a ResourceQueryDefinition object from a json dictionary."""
        args = {}
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'queries' in _dict:
            args['queries'] = [ResourceQuery.from_dict(x) for x in _dict.get('queries')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryDefinition object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'queries') and self.queries is not None:
            _dict['queries'] = [x.to_dict() for x in self.queries]
        for _key in [k for k in vars(self).keys() if k not in ResourceQueryDefinition._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryDefinition object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryDefinition') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryDefinition') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Resource type (cluster, vsi, icd, vpc).
        """
        VSI = 'vsi'


class ResourceQueryParam():
    """
    Describe resource query param.

    :attr str name: (optional) Name of the resource query param.
    :attr str value: (optional) Value of the resource query param.
    :attr str description: (optional) Description of resource query param variable.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'value', 'description'])

    def __init__(self,
                 *,
                 name: str = None,
                 value: str = None,
                 description: str = None,
                 **kwargs) -> None:
        """
        Initialize a ResourceQueryParam object.

        :param str name: (optional) Name of the resource query param.
        :param str value: (optional) Value of the resource query param.
        :param str description: (optional) Description of resource query param
               variable.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.value = value
        self.description = description
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryParam':
        """Initialize a ResourceQueryParam object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryParam object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        for _key in [k for k in vars(self).keys() if k not in ResourceQueryParam._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryParam object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryParam') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryParam') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ResourceQueryRecord():
    """
    Describe resource query record.

    :attr str type: (optional) Resource type (cluster, vsi, icd, vpc).
    :attr str name: (optional) Resource query name.
    :attr str id: (optional) Resource Query id.
    :attr datetime created_at: (optional) Resource query creation time.
    :attr str created_by: (optional) Email address of user who created the Resource
          query.
    :attr datetime updated_at: (optional) Resource query updation time.
    :attr str updated_by: (optional) Email address of user who updated the Resource
          query.
    :attr List[ResourceQuery] queries: (optional)
    """

    # The set of defined properties for the class
    _properties = frozenset(['type', 'name', 'id', 'created_at', 'created_by', 'updated_at', 'updated_by', 'queries'])

    def __init__(self,
                 *,
                 type: str = None,
                 name: str = None,
                 id: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 queries: List['ResourceQuery'] = None,
                 **kwargs) -> None:
        """
        Initialize a ResourceQueryRecord object.

        :param str type: (optional) Resource type (cluster, vsi, icd, vpc).
        :param str name: (optional) Resource query name.
        :param List[ResourceQuery] queries: (optional)
        :param **kwargs: (optional) Any additional properties.
        """
        self.type = type
        self.name = name
        self.id = id
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.queries = queries
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryRecord':
        """Initialize a ResourceQueryRecord object from a json dictionary."""
        args = {}
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'queries' in _dict:
            args['queries'] = [ResourceQuery.from_dict(x) for x in _dict.get('queries')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryRecord object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'queries') and self.queries is not None:
            _dict['queries'] = [x.to_dict() for x in self.queries]
        for _key in [k for k in vars(self).keys() if k not in ResourceQueryRecord._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryRecord object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryRecord') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryRecord') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Resource type (cluster, vsi, icd, vpc).
        """
        VSI = 'vsi'


class ResourceQueryRecordList():
    """
    List of Resource query records.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[ResourceQueryRecord] resource_queries: (optional) List of resource
          query records. (Deprecated ResourceQueries. Instead, use resource_queries.).
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'resource_queries'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 resource_queries: List['ResourceQueryRecord'] = None,
                 **kwargs) -> None:
        """
        Initialize a ResourceQueryRecordList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[ResourceQueryRecord] resource_queries: (optional) List of
               resource query records. (Deprecated ResourceQueries. Instead, use
               resource_queries.).
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.resource_queries = resource_queries
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryRecordList':
        """Initialize a ResourceQueryRecordList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in ResourceQueryRecordList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in ResourceQueryRecordList JSON')
        if 'resource_queries' in _dict:
            args['resource_queries'] = [ResourceQueryRecord.from_dict(x) for x in _dict.get('resource_queries')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryRecordList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'resource_queries') and self.resource_queries is not None:
            _dict['resource_queries'] = [x.to_dict() for x in self.resource_queries]
        for _key in [k for k in vars(self).keys() if k not in ResourceQueryRecordList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryRecordList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryRecordList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryRecordList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ResourceQueryResponseRecord():
    """
    Describe resource query.

    :attr List[ResourceQueryResponseRecordResponse] response: (optional)
    """

    # The set of defined properties for the class
    _properties = frozenset(['response'])

    def __init__(self,
                 *,
                 response: List['ResourceQueryResponseRecordResponse'] = None,
                 **kwargs) -> None:
        """
        Initialize a ResourceQueryResponseRecord object.

        :param List[ResourceQueryResponseRecordResponse] response: (optional)
        :param **kwargs: (optional) Any additional properties.
        """
        self.response = response
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryResponseRecord':
        """Initialize a ResourceQueryResponseRecord object from a json dictionary."""
        args = {}
        if 'response' in _dict:
            args['response'] = [ResourceQueryResponseRecordResponse.from_dict(x) for x in _dict.get('response')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryResponseRecord object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'response') and self.response is not None:
            _dict['response'] = [x.to_dict() for x in self.response]
        for _key in [k for k in vars(self).keys() if k not in ResourceQueryResponseRecord._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryResponseRecord object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryResponseRecord') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryResponseRecord') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ResourceQueryResponseRecordQueryOutput():
    """
    List of query output values.

    :attr str name: (optional) Name of the output param.
    :attr str value: (optional) value of the output param.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'value'])

    def __init__(self,
                 *,
                 name: str = None,
                 value: str = None,
                 **kwargs) -> None:
        """
        Initialize a ResourceQueryResponseRecordQueryOutput object.

        :param str name: (optional) Name of the output param.
        :param str value: (optional) value of the output param.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.value = value
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryResponseRecordQueryOutput':
        """Initialize a ResourceQueryResponseRecordQueryOutput object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryResponseRecordQueryOutput object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        for _key in [k for k in vars(self).keys() if k not in ResourceQueryResponseRecordQueryOutput._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryResponseRecordQueryOutput object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryResponseRecordQueryOutput') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryResponseRecordQueryOutput') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ResourceQueryResponseRecordResponse():
    """
    ResourceQueryResponseRecordResponse.

    :attr str query_type: (optional) Type of the query(workspaces).
    :attr List[ResourceQueryParam] query_condition: (optional)
    :attr List[str] query_select: (optional) List of query selection parameters.
    :attr List[ResourceQueryResponseRecordQueryOutput] query_output: (optional)
    """

    # The set of defined properties for the class
    _properties = frozenset(['query_type', 'query_condition', 'query_select', 'query_output'])

    def __init__(self,
                 *,
                 query_type: str = None,
                 query_condition: List['ResourceQueryParam'] = None,
                 query_select: List[str] = None,
                 query_output: List['ResourceQueryResponseRecordQueryOutput'] = None,
                 **kwargs) -> None:
        """
        Initialize a ResourceQueryResponseRecordResponse object.

        :param str query_type: (optional) Type of the query(workspaces).
        :param List[ResourceQueryParam] query_condition: (optional)
        :param List[str] query_select: (optional) List of query selection
               parameters.
        :param List[ResourceQueryResponseRecordQueryOutput] query_output:
               (optional)
        :param **kwargs: (optional) Any additional properties.
        """
        self.query_type = query_type
        self.query_condition = query_condition
        self.query_select = query_select
        self.query_output = query_output
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ResourceQueryResponseRecordResponse':
        """Initialize a ResourceQueryResponseRecordResponse object from a json dictionary."""
        args = {}
        if 'query_type' in _dict:
            args['query_type'] = _dict.get('query_type')
        if 'query_condition' in _dict:
            args['query_condition'] = [ResourceQueryParam.from_dict(x) for x in _dict.get('query_condition')]
        if 'query_select' in _dict:
            args['query_select'] = _dict.get('query_select')
        if 'query_output' in _dict:
            args['query_output'] = [ResourceQueryResponseRecordQueryOutput.from_dict(x) for x in _dict.get('query_output')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ResourceQueryResponseRecordResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'query_type') and self.query_type is not None:
            _dict['query_type'] = self.query_type
        if hasattr(self, 'query_condition') and self.query_condition is not None:
            _dict['query_condition'] = [x.to_dict() for x in self.query_condition]
        if hasattr(self, 'query_select') and self.query_select is not None:
            _dict['query_select'] = self.query_select
        if hasattr(self, 'query_output') and self.query_output is not None:
            _dict['query_output'] = [x.to_dict() for x in self.query_output]
        for _key in [k for k in vars(self).keys() if k not in ResourceQueryResponseRecordResponse._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ResourceQueryResponseRecordResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ResourceQueryResponseRecordResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ResourceQueryResponseRecordResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class QueryTypeEnum(str, Enum):
        """
        Type of the query(workspaces).
        """
        WORKSPACES = 'workspaces'


class SKUUserState():
    """
    Status of the underlying schematics objects used to fullfil CartOrder.

    :attr str state: (optional) State of the object.
    :attr str set_by: (optional) Name of the User who set the state of the Object.
    :attr datetime set_at: (optional) When the User who set the state of the Object.
    """

    # The set of defined properties for the class
    _properties = frozenset(['state', 'set_by', 'set_at'])

    def __init__(self,
                 *,
                 state: str = None,
                 set_by: str = None,
                 set_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a SKUUserState object.

        :param str state: (optional) State of the object.
        :param str set_by: (optional) Name of the User who set the state of the
               Object.
        :param datetime set_at: (optional) When the User who set the state of the
               Object.
        :param **kwargs: (optional) Any additional properties.
        """
        self.state = state
        self.set_by = set_by
        self.set_at = set_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SKUUserState':
        """Initialize a SKUUserState object from a json dictionary."""
        args = {}
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'set_by' in _dict:
            args['set_by'] = _dict.get('set_by')
        if 'set_at' in _dict:
            args['set_at'] = string_to_datetime(_dict.get('set_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SKUUserState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state
        if hasattr(self, 'set_by') and self.set_by is not None:
            _dict['set_by'] = self.set_by
        if hasattr(self, 'set_at') and self.set_at is not None:
            _dict['set_at'] = datetime_to_string(self.set_at)
        for _key in [k for k in vars(self).keys() if k not in SKUUserState._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SKUUserState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SKUUserState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SKUUserState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SchematicsAccessRule():
    """
    Schematics access rule details.

    :attr str effect: (optional) Outcome of the access rule evaluation.
    :attr str command_name: (optional) Schematics job command name.
    :attr str command_parameter: (optional) Schematics job command parameter
          (playbook-name, capsule-name or flow-name).
    :attr str principal: (optional) Name of the user who is trying to perform the
          command.
    :attr str origin: (optional) Origin of the schematics action event.
    """

    # The set of defined properties for the class
    _properties = frozenset(['effect', 'command_name', 'command_parameter', 'principal', 'origin'])

    def __init__(self,
                 *,
                 effect: str = None,
                 command_name: str = None,
                 command_parameter: str = None,
                 principal: str = None,
                 origin: str = None,
                 **kwargs) -> None:
        """
        Initialize a SchematicsAccessRule object.

        :param str effect: (optional) Outcome of the access rule evaluation.
        :param str command_name: (optional) Schematics job command name.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name, capsule-name or flow-name).
        :param str principal: (optional) Name of the user who is trying to perform
               the command.
        :param str origin: (optional) Origin of the schematics action event.
        :param **kwargs: (optional) Any additional properties.
        """
        self.effect = effect
        self.command_name = command_name
        self.command_parameter = command_parameter
        self.principal = principal
        self.origin = origin
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SchematicsAccessRule':
        """Initialize a SchematicsAccessRule object from a json dictionary."""
        args = {}
        if 'effect' in _dict:
            args['effect'] = _dict.get('effect')
        if 'command_name' in _dict:
            args['command_name'] = _dict.get('command_name')
        if 'command_parameter' in _dict:
            args['command_parameter'] = _dict.get('command_parameter')
        if 'principal' in _dict:
            args['principal'] = _dict.get('principal')
        if 'origin' in _dict:
            args['origin'] = _dict.get('origin')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SchematicsAccessRule object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'effect') and self.effect is not None:
            _dict['effect'] = self.effect
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'command_parameter') and self.command_parameter is not None:
            _dict['command_parameter'] = self.command_parameter
        if hasattr(self, 'principal') and self.principal is not None:
            _dict['principal'] = self.principal
        if hasattr(self, 'origin') and self.origin is not None:
            _dict['origin'] = self.origin
        for _key in [k for k in vars(self).keys() if k not in SchematicsAccessRule._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SchematicsAccessRule object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SchematicsAccessRule') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SchematicsAccessRule') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class EffectEnum(str, Enum):
        """
        Outcome of the access rule evaluation.
        """
        ALLOW = 'allow'
        DENY = 'deny'


    class CommandNameEnum(str, Enum):
        """
        Schematics job command name.
        """
        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        CREATE_ENVIRONMENT = 'create_environment'
        PUT_ENVIRONMENT = 'put_environment'
        DELETE_ENVIRONMENT = 'delete_environment'
        ENVIRONMENT_INIT = 'environment_init'
        ENVIRONMENT_INSTALL = 'environment_install'
        ENVIRONMENT_UNINSTALL = 'environment_uninstall'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'


    class OriginEnum(str, Enum):
        """
        Origin of the schematics action event.
        """
        WORKSPACES = 'workspaces'
        ACTIONS = 'actions'
        DATASETS = 'datasets'
        CONTROLS = 'controls'
        SETTINGS = 'settings'


class SchematicsAccessRuleList():
    """
    List of Schematics access rule details.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[SchematicsAccessRule] access_rules: (optional) List of access-rules.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'access_rules'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 access_rules: List['SchematicsAccessRule'] = None,
                 **kwargs) -> None:
        """
        Initialize a SchematicsAccessRuleList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[SchematicsAccessRule] access_rules: (optional) List of
               access-rules.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.access_rules = access_rules
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SchematicsAccessRuleList':
        """Initialize a SchematicsAccessRuleList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in SchematicsAccessRuleList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in SchematicsAccessRuleList JSON')
        if 'access_rules' in _dict:
            args['access_rules'] = [SchematicsAccessRule.from_dict(x) for x in _dict.get('access_rules')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SchematicsAccessRuleList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'access_rules') and self.access_rules is not None:
            _dict['access_rules'] = [x.to_dict() for x in self.access_rules]
        for _key in [k for k in vars(self).keys() if k not in SchematicsAccessRuleList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SchematicsAccessRuleList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SchematicsAccessRuleList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SchematicsAccessRuleList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SchematicsInfo():
    """
    Details about IBM Cloud Schematics service supported template types and versions, and
    the supported locations.

    :attr str schematics_version: (optional) Schematics version.
    :attr str schematics_build: (optional) Schematics build number.
    :attr List[str] supported_locations: (optional) Supported locations for IBM
          Cloud Schematics.
    :attr dict supported_templates: (optional) Support template-types in IBM Cloud
          Schematics.
    :attr dict supported_runtimes: (optional) Supported runtime components for each
          template-types in Schematics.
    """

    # The set of defined properties for the class
    _properties = frozenset(['schematics_version', 'schematics_build', 'supported_locations', 'supported_templates', 'supported_runtimes'])

    def __init__(self,
                 *,
                 schematics_version: str = None,
                 schematics_build: str = None,
                 supported_locations: List[str] = None,
                 supported_templates: dict = None,
                 supported_runtimes: dict = None,
                 **kwargs) -> None:
        """
        Initialize a SchematicsInfo object.

        :param str schematics_version: (optional) Schematics version.
        :param str schematics_build: (optional) Schematics build number.
        :param List[str] supported_locations: (optional) Supported locations for
               IBM Cloud Schematics.
        :param dict supported_templates: (optional) Support template-types in IBM
               Cloud Schematics.
        :param dict supported_runtimes: (optional) Supported runtime components for
               each template-types in Schematics.
        :param **kwargs: (optional) Any additional properties.
        """
        self.schematics_version = schematics_version
        self.schematics_build = schematics_build
        self.supported_locations = supported_locations
        self.supported_templates = supported_templates
        self.supported_runtimes = supported_runtimes
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SchematicsInfo':
        """Initialize a SchematicsInfo object from a json dictionary."""
        args = {}
        if 'schematics_version' in _dict:
            args['schematics_version'] = _dict.get('schematics_version')
        if 'schematics_build' in _dict:
            args['schematics_build'] = _dict.get('schematics_build')
        if 'supported_locations' in _dict:
            args['supported_locations'] = _dict.get('supported_locations')
        if 'supported_templates' in _dict:
            args['supported_templates'] = _dict.get('supported_templates')
        if 'supported_runtimes' in _dict:
            args['supported_runtimes'] = _dict.get('supported_runtimes')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SchematicsInfo object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'schematics_version') and self.schematics_version is not None:
            _dict['schematics_version'] = self.schematics_version
        if hasattr(self, 'schematics_build') and self.schematics_build is not None:
            _dict['schematics_build'] = self.schematics_build
        if hasattr(self, 'supported_locations') and self.supported_locations is not None:
            _dict['supported_locations'] = self.supported_locations
        if hasattr(self, 'supported_templates') and self.supported_templates is not None:
            _dict['supported_templates'] = self.supported_templates
        if hasattr(self, 'supported_runtimes') and self.supported_runtimes is not None:
            _dict['supported_runtimes'] = self.supported_runtimes
        for _key in [k for k in vars(self).keys() if k not in SchematicsInfo._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SchematicsInfo object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SchematicsInfo') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SchematicsInfo') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SupportedLocationsEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


    class SupportedTemplatesEnum(str, Enum):
        """
        Support template-types in IBM Cloud Schematics.
        """
        TERRAFORM_V0_11 = 'terraform_v0_11'
        TERRAFORM_V0_12 = 'terraform_v0_12'
        HELM_V2_15 = 'helm_v2_15'
        HELM_V2_16 = 'helm_v2_16'
        ANSIBLE_V2_2 = 'ansible_v2_2'
        ANSIBLE_V2_3 = 'ansible_v2_3'
        IBM_CLOUD_PAK_V3_1 = 'ibm_cloud_pak_v3_1'


class SchematicsLocationsList():
    """
    The list of locations details.

    :attr List[SchematicsLocationsLite] locations: (optional) The list of locations.
    """

    # The set of defined properties for the class
    _properties = frozenset(['locations'])

    def __init__(self,
                 *,
                 locations: List['SchematicsLocationsLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a SchematicsLocationsList object.

        :param List[SchematicsLocationsLite] locations: (optional) The list of
               locations.
        :param **kwargs: (optional) Any additional properties.
        """
        self.locations = locations
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SchematicsLocationsList':
        """Initialize a SchematicsLocationsList object from a json dictionary."""
        args = {}
        if 'locations' in _dict:
            args['locations'] = [SchematicsLocationsLite.from_dict(x) for x in _dict.get('locations')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SchematicsLocationsList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'locations') and self.locations is not None:
            _dict['locations'] = [x.to_dict() for x in self.locations]
        for _key in [k for k in vars(self).keys() if k not in SchematicsLocationsList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SchematicsLocationsList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SchematicsLocationsList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SchematicsLocationsList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SchematicsLocationsLite():
    """
    An individual location details.

    :attr str region: (optional) The Geographical region code having the data
          centres of the IBM Cloud Schematics service.
    :attr str metro: (optional) The Geographical city locations having the data
          centres of the IBM Cloud Schematics service.
    :attr str geography_code: (optional) The Geographical continent locations code
          having the data centres of the IBM Cloud Schematics service.
    :attr str geography: (optional) The Geographical continent locations having the
          data centres of the IBM Cloud Schematics service.
    :attr str country: (optional) The Country locations having the data centres of
          the IBM Cloud Schematics service.
    :attr str kind: (optional) The kind of location.
    :attr List[str] paired_region: (optional) The list of paired regions used by the
          Schematics.
    :attr bool restricted: (optional) The restricted region.
    :attr str display_name: (optional) Display name for the region.
    :attr str schematics_regional_public_endpoint: (optional) Schematics public
          endpoint for the region.
    :attr str schematics_regional_private_endpoint: (optional) Schematics private
          endpoint for the region.
    """

    # The set of defined properties for the class
    _properties = frozenset(['region', 'metro', 'geography_code', 'geography', 'country', 'kind', 'paired_region', 'restricted', 'display_name', 'schematics_regional_public_endpoint', 'schematics_regional_private_endpoint'])

    def __init__(self,
                 *,
                 region: str = None,
                 metro: str = None,
                 geography_code: str = None,
                 geography: str = None,
                 country: str = None,
                 kind: str = None,
                 paired_region: List[str] = None,
                 restricted: bool = None,
                 display_name: str = None,
                 schematics_regional_public_endpoint: str = None,
                 schematics_regional_private_endpoint: str = None,
                 **kwargs) -> None:
        """
        Initialize a SchematicsLocationsLite object.

        :param str region: (optional) The Geographical region code having the data
               centres of the IBM Cloud Schematics service.
        :param str metro: (optional) The Geographical city locations having the
               data centres of the IBM Cloud Schematics service.
        :param str geography_code: (optional) The Geographical continent locations
               code having the data centres of the IBM Cloud Schematics service.
        :param str geography: (optional) The Geographical continent locations
               having the data centres of the IBM Cloud Schematics service.
        :param str country: (optional) The Country locations having the data
               centres of the IBM Cloud Schematics service.
        :param str kind: (optional) The kind of location.
        :param List[str] paired_region: (optional) The list of paired regions used
               by the Schematics.
        :param bool restricted: (optional) The restricted region.
        :param str display_name: (optional) Display name for the region.
        :param str schematics_regional_public_endpoint: (optional) Schematics
               public endpoint for the region.
        :param str schematics_regional_private_endpoint: (optional) Schematics
               private endpoint for the region.
        :param **kwargs: (optional) Any additional properties.
        """
        self.region = region
        self.metro = metro
        self.geography_code = geography_code
        self.geography = geography
        self.country = country
        self.kind = kind
        self.paired_region = paired_region
        self.restricted = restricted
        self.display_name = display_name
        self.schematics_regional_public_endpoint = schematics_regional_public_endpoint
        self.schematics_regional_private_endpoint = schematics_regional_private_endpoint
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SchematicsLocationsLite':
        """Initialize a SchematicsLocationsLite object from a json dictionary."""
        args = {}
        if 'region' in _dict:
            args['region'] = _dict.get('region')
        if 'metro' in _dict:
            args['metro'] = _dict.get('metro')
        if 'geography_code' in _dict:
            args['geography_code'] = _dict.get('geography_code')
        if 'geography' in _dict:
            args['geography'] = _dict.get('geography')
        if 'country' in _dict:
            args['country'] = _dict.get('country')
        if 'kind' in _dict:
            args['kind'] = _dict.get('kind')
        if 'paired_region' in _dict:
            args['paired_region'] = _dict.get('paired_region')
        if 'restricted' in _dict:
            args['restricted'] = _dict.get('restricted')
        if 'display_name' in _dict:
            args['display_name'] = _dict.get('display_name')
        if 'schematics_regional_public_endpoint' in _dict:
            args['schematics_regional_public_endpoint'] = _dict.get('schematics_regional_public_endpoint')
        if 'schematics_regional_private_endpoint' in _dict:
            args['schematics_regional_private_endpoint'] = _dict.get('schematics_regional_private_endpoint')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SchematicsLocationsLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'region') and self.region is not None:
            _dict['region'] = self.region
        if hasattr(self, 'metro') and self.metro is not None:
            _dict['metro'] = self.metro
        if hasattr(self, 'geography_code') and self.geography_code is not None:
            _dict['geography_code'] = self.geography_code
        if hasattr(self, 'geography') and self.geography is not None:
            _dict['geography'] = self.geography
        if hasattr(self, 'country') and self.country is not None:
            _dict['country'] = self.country
        if hasattr(self, 'kind') and self.kind is not None:
            _dict['kind'] = self.kind
        if hasattr(self, 'paired_region') and self.paired_region is not None:
            _dict['paired_region'] = self.paired_region
        if hasattr(self, 'restricted') and self.restricted is not None:
            _dict['restricted'] = self.restricted
        if hasattr(self, 'display_name') and self.display_name is not None:
            _dict['display_name'] = self.display_name
        if hasattr(self, 'schematics_regional_public_endpoint') and self.schematics_regional_public_endpoint is not None:
            _dict['schematics_regional_public_endpoint'] = self.schematics_regional_public_endpoint
        if hasattr(self, 'schematics_regional_private_endpoint') and self.schematics_regional_private_endpoint is not None:
            _dict['schematics_regional_private_endpoint'] = self.schematics_regional_private_endpoint
        for _key in [k for k in vars(self).keys() if k not in SchematicsLocationsLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SchematicsLocationsLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SchematicsLocationsLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SchematicsLocationsLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SchematicsRuntimeInfo():
    """
    Runtime components for each template-types in Schematics.

    :attr str runtime_image: (optional) Runtime image name.
    :attr dict runtime_properties: (optional) Properties of the Runtime image.
    """

    # The set of defined properties for the class
    _properties = frozenset(['runtime_image', 'runtime_properties'])

    def __init__(self,
                 *,
                 runtime_image: str = None,
                 runtime_properties: dict = None,
                 **kwargs) -> None:
        """
        Initialize a SchematicsRuntimeInfo object.

        :param str runtime_image: (optional) Runtime image name.
        :param dict runtime_properties: (optional) Properties of the Runtime image.
        :param **kwargs: (optional) Any additional properties.
        """
        self.runtime_image = runtime_image
        self.runtime_properties = runtime_properties
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SchematicsRuntimeInfo':
        """Initialize a SchematicsRuntimeInfo object from a json dictionary."""
        args = {}
        if 'runtime_image' in _dict:
            args['runtime_image'] = _dict.get('runtime_image')
        if 'runtime_properties' in _dict:
            args['runtime_properties'] = _dict.get('runtime_properties')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SchematicsRuntimeInfo object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'runtime_image') and self.runtime_image is not None:
            _dict['runtime_image'] = self.runtime_image
        if hasattr(self, 'runtime_properties') and self.runtime_properties is not None:
            _dict['runtime_properties'] = self.runtime_properties
        for _key in [k for k in vars(self).keys() if k not in SchematicsRuntimeInfo._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SchematicsRuntimeInfo object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SchematicsRuntimeInfo') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SchematicsRuntimeInfo') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ServiceMappingRule():
    """
    Rule to map input param_name to output_param.

    :attr str type: (optional) Type of mapping.
    :attr str input_param_name: (optional) Input parameter name which acts as source
          for mapping.
    :attr str output_param_name: (optional) Output parameter name which acts as
          destination for mapping.
    """

    # The set of defined properties for the class
    _properties = frozenset(['type', 'input_param_name', 'output_param_name'])

    def __init__(self,
                 *,
                 type: str = None,
                 input_param_name: str = None,
                 output_param_name: str = None,
                 **kwargs) -> None:
        """
        Initialize a ServiceMappingRule object.

        :param str type: (optional) Type of mapping.
        :param str input_param_name: (optional) Input parameter name which acts as
               source for mapping.
        :param str output_param_name: (optional) Output parameter name which acts
               as destination for mapping.
        :param **kwargs: (optional) Any additional properties.
        """
        self.type = type
        self.input_param_name = input_param_name
        self.output_param_name = output_param_name
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceMappingRule':
        """Initialize a ServiceMappingRule object from a json dictionary."""
        args = {}
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'input_param_name' in _dict:
            args['input_param_name'] = _dict.get('input_param_name')
        if 'output_param_name' in _dict:
            args['output_param_name'] = _dict.get('output_param_name')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceMappingRule object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'input_param_name') and self.input_param_name is not None:
            _dict['input_param_name'] = self.input_param_name
        if hasattr(self, 'output_param_name') and self.output_param_name is not None:
            _dict['output_param_name'] = self.output_param_name
        for _key in [k for k in vars(self).keys() if k not in ServiceMappingRule._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceMappingRule object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceMappingRule') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceMappingRule') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ServiceVariableData():
    """
    User editable service variable data & system generated reference to value.

    :attr str name: (optional) Name of the variable.
    :attr str value: (optional) Value for the variable or reference to the value.
    :attr VariableMetadata metadata: (optional) An user editable metadata for the
          variables.
    :attr List[ServiceMappingRule] mapping: (optional) Service Mapping Rule.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'value', 'metadata', 'mapping'])

    def __init__(self,
                 *,
                 name: str = None,
                 value: str = None,
                 metadata: 'VariableMetadata' = None,
                 mapping: List['ServiceMappingRule'] = None,
                 **kwargs) -> None:
        """
        Initialize a ServiceVariableData object.

        :param str name: (optional) Name of the variable.
        :param str value: (optional) Value for the variable or reference to the
               value.
        :param VariableMetadata metadata: (optional) An user editable metadata for
               the variables.
        :param List[ServiceMappingRule] mapping: (optional) Service Mapping Rule.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.value = value
        self.metadata = metadata
        self.mapping = mapping
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ServiceVariableData':
        """Initialize a ServiceVariableData object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        if 'metadata' in _dict:
            args['metadata'] = VariableMetadata.from_dict(_dict.get('metadata'))
        if 'mapping' in _dict:
            args['mapping'] = [ServiceMappingRule.from_dict(x) for x in _dict.get('mapping')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ServiceVariableData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        if hasattr(self, 'metadata') and self.metadata is not None:
            _dict['metadata'] = self.metadata.to_dict()
        if hasattr(self, 'mapping') and self.mapping is not None:
            _dict['mapping'] = [x.to_dict() for x in self.mapping]
        for _key in [k for k in vars(self).keys() if k not in ServiceVariableData._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ServiceVariableData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ServiceVariableData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ServiceVariableData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class SystemLock():
    """
    System lock status.

    :attr bool sys_locked: (optional) Is the automation locked by a Schematic job ?.
    :attr str sys_locked_by: (optional) Name of the User who performed the job, that
          lead to the locking of the automation.
    :attr datetime sys_locked_at: (optional) When the User performed the job that
          lead to locking of the automation ?.
    """

    # The set of defined properties for the class
    _properties = frozenset(['sys_locked', 'sys_locked_by', 'sys_locked_at'])

    def __init__(self,
                 *,
                 sys_locked: bool = None,
                 sys_locked_by: str = None,
                 sys_locked_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a SystemLock object.

        :param bool sys_locked: (optional) Is the automation locked by a Schematic
               job ?.
        :param str sys_locked_by: (optional) Name of the User who performed the
               job, that lead to the locking of the automation.
        :param datetime sys_locked_at: (optional) When the User performed the job
               that lead to locking of the automation ?.
        :param **kwargs: (optional) Any additional properties.
        """
        self.sys_locked = sys_locked
        self.sys_locked_by = sys_locked_by
        self.sys_locked_at = sys_locked_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'SystemLock':
        """Initialize a SystemLock object from a json dictionary."""
        args = {}
        if 'sys_locked' in _dict:
            args['sys_locked'] = _dict.get('sys_locked')
        if 'sys_locked_by' in _dict:
            args['sys_locked_by'] = _dict.get('sys_locked_by')
        if 'sys_locked_at' in _dict:
            args['sys_locked_at'] = string_to_datetime(_dict.get('sys_locked_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a SystemLock object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'sys_locked') and self.sys_locked is not None:
            _dict['sys_locked'] = self.sys_locked
        if hasattr(self, 'sys_locked_by') and self.sys_locked_by is not None:
            _dict['sys_locked_by'] = self.sys_locked_by
        if hasattr(self, 'sys_locked_at') and self.sys_locked_at is not None:
            _dict['sys_locked_at'] = datetime_to_string(self.sys_locked_at)
        for _key in [k for k in vars(self).keys() if k not in SystemLock._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this SystemLock object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'SystemLock') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'SystemLock') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TargetRequest():
    """
    Target cluster details to perform POC operation.

    :attr str cluster_id: (optional) Cluster Id.
    :attr str cluster_name: (optional) Cluster name.
    :attr object entitlement_key: (optional) Entitlement key.
    :attr str namespace: (optional) K8s namespace.
    :attr str region: (optional) Cluster region.
    :attr str resource_group_id: (optional) Resource group id.
    """

    # The set of defined properties for the class
    _properties = frozenset(['cluster_id', 'cluster_name', 'entitlement_key', 'namespace', 'region', 'resource_group_id'])

    def __init__(self,
                 *,
                 cluster_id: str = None,
                 cluster_name: str = None,
                 entitlement_key: object = None,
                 namespace: str = None,
                 region: str = None,
                 resource_group_id: str = None,
                 **kwargs) -> None:
        """
        Initialize a TargetRequest object.

        :param str cluster_id: (optional) Cluster Id.
        :param str cluster_name: (optional) Cluster name.
        :param object entitlement_key: (optional) Entitlement key.
        :param str namespace: (optional) K8s namespace.
        :param str region: (optional) Cluster region.
        :param str resource_group_id: (optional) Resource group id.
        :param **kwargs: (optional) Any additional properties.
        """
        self.cluster_id = cluster_id
        self.cluster_name = cluster_name
        self.entitlement_key = entitlement_key
        self.namespace = namespace
        self.region = region
        self.resource_group_id = resource_group_id
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TargetRequest':
        """Initialize a TargetRequest object from a json dictionary."""
        args = {}
        if 'cluster_id' in _dict:
            args['cluster_id'] = _dict.get('cluster_id')
        if 'cluster_name' in _dict:
            args['cluster_name'] = _dict.get('cluster_name')
        if 'entitlement_key' in _dict:
            args['entitlement_key'] = _dict.get('entitlement_key')
        if 'namespace' in _dict:
            args['namespace'] = _dict.get('namespace')
        if 'region' in _dict:
            args['region'] = _dict.get('region')
        if 'resource_group_id' in _dict:
            args['resource_group_id'] = _dict.get('resource_group_id')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TargetRequest object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'cluster_id') and self.cluster_id is not None:
            _dict['cluster_id'] = self.cluster_id
        if hasattr(self, 'cluster_name') and self.cluster_name is not None:
            _dict['cluster_name'] = self.cluster_name
        if hasattr(self, 'entitlement_key') and self.entitlement_key is not None:
            _dict['entitlement_key'] = self.entitlement_key
        if hasattr(self, 'namespace') and self.namespace is not None:
            _dict['namespace'] = self.namespace
        if hasattr(self, 'region') and self.region is not None:
            _dict['region'] = self.region
        if hasattr(self, 'resource_group_id') and self.resource_group_id is not None:
            _dict['resource_group_id'] = self.resource_group_id
        for _key in [k for k in vars(self).keys() if k not in TargetRequest._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TargetRequest object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TargetRequest') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TargetRequest') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class Template():
    """
    Complete Template definition with user inputs and system generated data.

    :attr str name: (optional) Name of the template. Should be unique within a
          workspace.
    :attr str description: (optional) Template description.
    :attr str type: (optional) Template type.  Ex: terraform_v0.11, terraform_v0.12,
          ansible.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr str source_type: (optional) Type of source for the Template.
    :attr ExternalSource source: (optional) Source of templates, playbooks, or
          controls.
    :attr str source_readme_url: (optional) URL of the README file, for the source.
    :attr List[VariableData] inputs: (optional) Input variables for the Template.
    :attr List[VariableData] outputs: (optional) Output variables from the Template.
    :attr List[VariableData] settings: (optional) Environment variables used by the
          template.
    :attr str inventory: (optional) Target inventory record ID used by the template
          to deploy the resources.
    :attr str id: (optional) template ID generated by the system.
    :attr datetime source_created_at: (optional) Template Source creation time.
    :attr str source_created_by: (optional) Email address of user who created the
          Template Source.
    :attr datetime source_updated_at: (optional) Template Source updation time.
    :attr str source_updated_by: (optional) Email address of user who updated the
          Template Source.
    :attr datetime created_at: (optional) Template creation time.
    :attr str created_by: (optional) Email address of user who created the template.
    :attr datetime updated_at: (optional) Template updation time.
    :attr str updated_by: (optional) Email address of user who updated the template.
    :attr JobStatusTemplate status: (optional) Template Job Status.
    :attr SystemLock sys_lock: (optional) System lock status.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'type', 'user_state', 'source_type', 'source', 'source_readme_url', 'inputs', 'outputs', 'settings', 'inventory', 'id', 'source_created_at', 'source_created_by', 'source_updated_at', 'source_updated_by', 'created_at', 'created_by', 'updated_at', 'updated_by', 'status', 'sys_lock'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 type: str = None,
                 user_state: 'UserState' = None,
                 source_type: str = None,
                 source: 'ExternalSource' = None,
                 source_readme_url: str = None,
                 inputs: List['VariableData'] = None,
                 outputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 inventory: str = None,
                 id: str = None,
                 source_created_at: datetime = None,
                 source_created_by: str = None,
                 source_updated_at: datetime = None,
                 source_updated_by: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 status: 'JobStatusTemplate' = None,
                 sys_lock: 'SystemLock' = None,
                 **kwargs) -> None:
        """
        Initialize a Template object.

        :param str name: (optional) Name of the template. Should be unique within a
               workspace.
        :param str description: (optional) Template description.
        :param str type: (optional) Template type.  Ex: terraform_v0.11,
               terraform_v0.12, ansible.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param str source_type: (optional) Type of source for the Template.
        :param ExternalSource source: (optional) Source of templates, playbooks, or
               controls.
        :param str source_readme_url: (optional) URL of the README file, for the
               source.
        :param List[VariableData] inputs: (optional) Input variables for the
               Template.
        :param List[VariableData] outputs: (optional) Output variables from the
               Template.
        :param List[VariableData] settings: (optional) Environment variables used
               by the template.
        :param str inventory: (optional) Target inventory record ID used by the
               template to deploy the resources.
        :param JobStatusTemplate status: (optional) Template Job Status.
        :param SystemLock sys_lock: (optional) System lock status.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.type = type
        self.user_state = user_state
        self.source_type = source_type
        self.source = source
        self.source_readme_url = source_readme_url
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.inventory = inventory
        self.id = id
        self.source_created_at = source_created_at
        self.source_created_by = source_created_by
        self.source_updated_at = source_updated_at
        self.source_updated_by = source_updated_by
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.status = status
        self.sys_lock = sys_lock
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Template':
        """Initialize a Template object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'source_type' in _dict:
            args['source_type'] = _dict.get('source_type')
        if 'source' in _dict:
            args['source'] = ExternalSource.from_dict(_dict.get('source'))
        if 'source_readme_url' in _dict:
            args['source_readme_url'] = _dict.get('source_readme_url')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'inventory' in _dict:
            args['inventory'] = _dict.get('inventory')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'source_created_at' in _dict:
            args['source_created_at'] = string_to_datetime(_dict.get('source_created_at'))
        if 'source_created_by' in _dict:
            args['source_created_by'] = _dict.get('source_created_by')
        if 'source_updated_at' in _dict:
            args['source_updated_at'] = string_to_datetime(_dict.get('source_updated_at'))
        if 'source_updated_by' in _dict:
            args['source_updated_by'] = _dict.get('source_updated_by')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'status' in _dict:
            args['status'] = JobStatusTemplate.from_dict(_dict.get('status'))
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Template object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'source_type') and self.source_type is not None:
            _dict['source_type'] = self.source_type
        if hasattr(self, 'source') and self.source is not None:
            _dict['source'] = self.source.to_dict()
        if hasattr(self, 'source_readme_url') and self.source_readme_url is not None:
            _dict['source_readme_url'] = self.source_readme_url
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'inventory') and self.inventory is not None:
            _dict['inventory'] = self.inventory
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'source_created_at') and getattr(self, 'source_created_at') is not None:
            _dict['source_created_at'] = datetime_to_string(getattr(self, 'source_created_at'))
        if hasattr(self, 'source_created_by') and getattr(self, 'source_created_by') is not None:
            _dict['source_created_by'] = getattr(self, 'source_created_by')
        if hasattr(self, 'source_updated_at') and getattr(self, 'source_updated_at') is not None:
            _dict['source_updated_at'] = datetime_to_string(getattr(self, 'source_updated_at'))
        if hasattr(self, 'source_updated_by') and getattr(self, 'source_updated_by') is not None:
            _dict['source_updated_by'] = getattr(self, 'source_updated_by')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status.to_dict()
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        for _key in [k for k in vars(self).keys() if k not in Template._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Template object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Template') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Template') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SourceTypeEnum(str, Enum):
        """
        Type of source for the Template.
        """
        LOCAL = 'local'
        GIT_HUB = 'git_hub'
        GIT_HUB_ENTERPRISE = 'git_hub_enterprise'
        GIT_LAB = 'git_lab'
        IBM_GIT_LAB = 'ibm_git_lab'
        IBM_CLOUD_CATALOG = 'ibm_cloud_catalog'
        EXTERNAL_SCM = 'external_scm'


class TemplateCommand():
    """
    Name of the template-specific command.

    :attr str command: (optional) Schematics job command name.
    :attr List[str] command_options: (optional) Options supported by the Template
          Command - it will be used as command line options for Terraform, Helm, Operator
          engine Eg -parallelism=n  -var-file=myvarfile.
    """

    # The set of defined properties for the class
    _properties = frozenset(['command', 'command_options'])

    def __init__(self,
                 *,
                 command: str = None,
                 command_options: List[str] = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateCommand object.

        :param str command: (optional) Schematics job command name.
        :param List[str] command_options: (optional) Options supported by the
               Template Command - it will be used as command line options for Terraform,
               Helm, Operator engine Eg -parallelism=n  -var-file=myvarfile.
        :param **kwargs: (optional) Any additional properties.
        """
        self.command = command
        self.command_options = command_options
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateCommand':
        """Initialize a TemplateCommand object from a json dictionary."""
        args = {}
        if 'command' in _dict:
            args['command'] = _dict.get('command')
        if 'command_options' in _dict:
            args['command_options'] = _dict.get('command_options')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateCommand object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command') and self.command is not None:
            _dict['command'] = self.command
        if hasattr(self, 'command_options') and self.command_options is not None:
            _dict['command_options'] = self.command_options
        for _key in [k for k in vars(self).keys() if k not in TemplateCommand._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateCommand object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateCommand') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateCommand') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class CommandEnum(str, Enum):
        """
        Schematics job command name.
        """
        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        CREATE_ENVIRONMENT = 'create_environment'
        PUT_ENVIRONMENT = 'put_environment'
        DELETE_ENVIRONMENT = 'delete_environment'
        ENVIRONMENT_INIT = 'environment_init'
        ENVIRONMENT_INSTALL = 'environment_install'
        ENVIRONMENT_UNINSTALL = 'environment_uninstall'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'


class TemplateFlow():
    """
    Complete Flow details with user inputs and system generated data.

    :attr str name: (optional) Name of the Flow.
    :attr str version: (optional) Version of the flow definition. Only value 'V1' is
          accepted.
    :attr str type: (optional) Type of flow.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr TemplateFlowDefinition definition: (optional) Flow definition.
    :attr str id: (optional) Id of the Flow.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr datetime created_at: (optional) Flow creation time.
    :attr str created_by: (optional) Email address of user who created the flow.
    :attr datetime updated_at: (optional) Flow updation time.
    :attr str updated_by: (optional) Email address of user who updated the flow.
    :attr JobStatusWorkspaceTemplateFlow status: (optional) Flow Job Status.
    :attr TemplateFlowValidationSummary validation_summary: (optional) Validation
          summary.
    :attr List[TemplateFlowValidationLogs] validation_logs: (optional) Validation
          details.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'version', 'type', 'user_state', 'definition', 'id', 'sys_lock', 'created_at', 'created_by', 'updated_at', 'updated_by', 'status', 'validation_summary', 'validation_logs'])

    def __init__(self,
                 *,
                 name: str = None,
                 version: str = None,
                 type: str = None,
                 user_state: 'UserState' = None,
                 definition: 'TemplateFlowDefinition' = None,
                 id: str = None,
                 sys_lock: 'SystemLock' = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 status: 'JobStatusWorkspaceTemplateFlow' = None,
                 validation_summary: 'TemplateFlowValidationSummary' = None,
                 validation_logs: List['TemplateFlowValidationLogs'] = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateFlow object.

        :param str name: (optional) Name of the Flow.
        :param str version: (optional) Version of the flow definition. Only value
               'V1' is accepted.
        :param str type: (optional) Type of flow.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param TemplateFlowDefinition definition: (optional) Flow definition.
        :param SystemLock sys_lock: (optional) System lock status.
        :param JobStatusWorkspaceTemplateFlow status: (optional) Flow Job Status.
        :param TemplateFlowValidationSummary validation_summary: (optional)
               Validation summary.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.version = version
        self.type = type
        self.user_state = user_state
        self.definition = definition
        self.id = id
        self.sys_lock = sys_lock
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.status = status
        self.validation_summary = validation_summary
        self.validation_logs = validation_logs
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateFlow':
        """Initialize a TemplateFlow object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'version' in _dict:
            args['version'] = _dict.get('version')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'definition' in _dict:
            args['definition'] = TemplateFlowDefinition.from_dict(_dict.get('definition'))
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'status' in _dict:
            args['status'] = JobStatusWorkspaceTemplateFlow.from_dict(_dict.get('status'))
        if 'validation_summary' in _dict:
            args['validation_summary'] = TemplateFlowValidationSummary.from_dict(_dict.get('validation_summary'))
        if 'validation_logs' in _dict:
            args['validation_logs'] = [TemplateFlowValidationLogs.from_dict(x) for x in _dict.get('validation_logs')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateFlow object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'version') and self.version is not None:
            _dict['version'] = self.version
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'definition') and self.definition is not None:
            _dict['definition'] = self.definition.to_dict()
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status.to_dict()
        if hasattr(self, 'validation_summary') and self.validation_summary is not None:
            _dict['validation_summary'] = self.validation_summary.to_dict()
        if hasattr(self, 'validation_logs') and getattr(self, 'validation_logs') is not None:
            _dict['validation_logs'] = [x.to_dict() for x in getattr(self, 'validation_logs')]
        for _key in [k for k in vars(self).keys() if k not in TemplateFlow._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateFlow object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateFlow') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateFlow') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Type of flow.
        """
        SIMPLE_FLOW = 'simple_flow'
        NODE_RED_FLOW = 'node_red_flow'


class TemplateFlowDataValidationStatus():
    """
    Flow data-flow validation status.

    :attr str log_level: (optional) Validation status of the template variable.
    :attr str var_name: (optional) Input variable name.
    :attr str var_status: (optional) Validation log message related to the template
          variable.
    """

    # The set of defined properties for the class
    _properties = frozenset(['log_level', 'var_name', 'var_status'])

    def __init__(self,
                 *,
                 log_level: str = None,
                 var_name: str = None,
                 var_status: str = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateFlowDataValidationStatus object.

        :param str log_level: (optional) Validation status of the template
               variable.
        :param str var_name: (optional) Input variable name.
        :param str var_status: (optional) Validation log message related to the
               template variable.
        :param **kwargs: (optional) Any additional properties.
        """
        self.log_level = log_level
        self.var_name = var_name
        self.var_status = var_status
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateFlowDataValidationStatus':
        """Initialize a TemplateFlowDataValidationStatus object from a json dictionary."""
        args = {}
        if 'log_level' in _dict:
            args['log_level'] = _dict.get('log_level')
        if 'var_name' in _dict:
            args['var_name'] = _dict.get('var_name')
        if 'var_status' in _dict:
            args['var_status'] = _dict.get('var_status')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateFlowDataValidationStatus object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'log_level') and self.log_level is not None:
            _dict['log_level'] = self.log_level
        if hasattr(self, 'var_name') and self.var_name is not None:
            _dict['var_name'] = self.var_name
        if hasattr(self, 'var_status') and self.var_status is not None:
            _dict['var_status'] = self.var_status
        for _key in [k for k in vars(self).keys() if k not in TemplateFlowDataValidationStatus._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateFlowDataValidationStatus object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateFlowDataValidationStatus') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateFlowDataValidationStatus') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LogLevelEnum(str, Enum):
        """
        Validation status of the template variable.
        """
        INFO = 'info'
        WARNING = 'warning'
        ERROR = 'error'


class TemplateFlowDefinition():
    """
    Flow definition.

    :attr str flow_type: (optional) Type of flow definition.
    :attr str id: (optional) Flow definition id.
    :attr List[TemplateFlowDefinitionSimpleFlow] simple_flow: (optional) Simple
          inbuilt flow defined using a list of template operations.
    :attr bytes custom_flow: (optional) flow definition string used by an external
          engine (eg. NodeRed).
    """

    # The set of defined properties for the class
    _properties = frozenset(['flow_type', 'id', 'simple_flow', 'custom_flow'])

    def __init__(self,
                 *,
                 flow_type: str = None,
                 id: str = None,
                 simple_flow: List['TemplateFlowDefinitionSimpleFlow'] = None,
                 custom_flow: bytes = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateFlowDefinition object.

        :param str flow_type: (optional) Type of flow definition.
        :param str id: (optional) Flow definition id.
        :param List[TemplateFlowDefinitionSimpleFlow] simple_flow: (optional)
               Simple inbuilt flow defined using a list of template operations.
        :param bytes custom_flow: (optional) flow definition string used by an
               external engine (eg. NodeRed).
        :param **kwargs: (optional) Any additional properties.
        """
        self.flow_type = flow_type
        self.id = id
        self.simple_flow = simple_flow
        self.custom_flow = custom_flow
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateFlowDefinition':
        """Initialize a TemplateFlowDefinition object from a json dictionary."""
        args = {}
        if 'flow_type' in _dict:
            args['flow_type'] = _dict.get('flow_type')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'simple_flow' in _dict:
            args['simple_flow'] = [TemplateFlowDefinitionSimpleFlow.from_dict(x) for x in _dict.get('simple_flow')]
        if 'custom_flow' in _dict:
            args['custom_flow'] = base64.b64decode(_dict.get('custom_flow'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateFlowDefinition object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'flow_type') and self.flow_type is not None:
            _dict['flow_type'] = self.flow_type
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'simple_flow') and self.simple_flow is not None:
            _dict['simple_flow'] = [x.to_dict() for x in self.simple_flow]
        if hasattr(self, 'custom_flow') and self.custom_flow is not None:
            _dict['custom_flow'] = str(base64.b64encode(self.custom_flow), 'utf-8')
        for _key in [k for k in vars(self).keys() if k not in TemplateFlowDefinition._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateFlowDefinition object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateFlowDefinition') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateFlowDefinition') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class FlowTypeEnum(str, Enum):
        """
        Type of flow definition.
        """
        SIMPLE = 'simple'
        CUSTOM = 'custom'


class TemplateFlowDefinitionSimpleFlow():
    """
    TemplateFlowDefinitionSimpleFlow.

    :attr int index: (optional) Line number of the template-operation.
    :attr str control: (optional) Control action in the flow.
    :attr TemplateFlowDefinitionTemplateOperation template_operation: (optional)
          Template operation in the flow.
    """

    # The set of defined properties for the class
    _properties = frozenset(['index', 'control', 'template_operation'])

    def __init__(self,
                 *,
                 index: int = None,
                 control: str = None,
                 template_operation: 'TemplateFlowDefinitionTemplateOperation' = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateFlowDefinitionSimpleFlow object.

        :param int index: (optional) Line number of the template-operation.
        :param str control: (optional) Control action in the flow.
        :param TemplateFlowDefinitionTemplateOperation template_operation:
               (optional) Template operation in the flow.
        :param **kwargs: (optional) Any additional properties.
        """
        self.index = index
        self.control = control
        self.template_operation = template_operation
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateFlowDefinitionSimpleFlow':
        """Initialize a TemplateFlowDefinitionSimpleFlow object from a json dictionary."""
        args = {}
        if 'index' in _dict:
            args['index'] = _dict.get('index')
        if 'control' in _dict:
            args['control'] = _dict.get('control')
        if 'template_operation' in _dict:
            args['template_operation'] = TemplateFlowDefinitionTemplateOperation.from_dict(_dict.get('template_operation'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateFlowDefinitionSimpleFlow object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'index') and self.index is not None:
            _dict['index'] = self.index
        if hasattr(self, 'control') and self.control is not None:
            _dict['control'] = self.control
        if hasattr(self, 'template_operation') and self.template_operation is not None:
            _dict['template_operation'] = self.template_operation.to_dict()
        for _key in [k for k in vars(self).keys() if k not in TemplateFlowDefinitionSimpleFlow._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateFlowDefinitionSimpleFlow object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateFlowDefinitionSimpleFlow') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateFlowDefinitionSimpleFlow') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class ControlEnum(str, Enum):
        """
        Control action in the flow.
        """
        DO = 'do'
        REPEAT_UNTIL = 'repeat_until'
        WAIT_UNTIL = 'wait_until'
        BRANCH_IF = 'branch_if'
        SWITCH = 'switch'


class TemplateFlowDefinitionTemplateOperation():
    """
    Template operation in the flow.

    :attr str pre_condition: (optional) Condition expression that will be evaluated
          before performing the template command; if false, this template action is
          skipped to the next.
    :attr str template_id: (optional) Id of the Template picked for performing the
          workspace command.
    :attr TemplateCommand override_command: (optional) Name of the template-specific
          command.
    :attr str post_condition: (optional) Condition expression that will be evaluated
          after performing the template command; if false, the workspace command  will be
          reported as Failed, and error event is triggered".
    :attr str on_error: (optional) On encountering error in the workspace command -
          ignore (and continue to next step), or break (to stop execution), or retry (the
          template action, for a configurable retry count).
    """

    # The set of defined properties for the class
    _properties = frozenset(['pre_condition', 'template_id', 'override_command', 'post_condition', 'on_error'])

    def __init__(self,
                 *,
                 pre_condition: str = None,
                 template_id: str = None,
                 override_command: 'TemplateCommand' = None,
                 post_condition: str = None,
                 on_error: str = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateFlowDefinitionTemplateOperation object.

        :param str pre_condition: (optional) Condition expression that will be
               evaluated before performing the template command; if false, this template
               action is skipped to the next.
        :param str template_id: (optional) Id of the Template picked for performing
               the workspace command.
        :param TemplateCommand override_command: (optional) Name of the
               template-specific command.
        :param str post_condition: (optional) Condition expression that will be
               evaluated after performing the template command; if false, the workspace
               command  will be reported as Failed, and error event is triggered".
        :param str on_error: (optional) On encountering error in the workspace
               command - ignore (and continue to next step), or break (to stop execution),
               or retry (the template action, for a configurable retry count).
        :param **kwargs: (optional) Any additional properties.
        """
        self.pre_condition = pre_condition
        self.template_id = template_id
        self.override_command = override_command
        self.post_condition = post_condition
        self.on_error = on_error
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateFlowDefinitionTemplateOperation':
        """Initialize a TemplateFlowDefinitionTemplateOperation object from a json dictionary."""
        args = {}
        if 'pre_condition' in _dict:
            args['pre_condition'] = _dict.get('pre_condition')
        if 'template_id' in _dict:
            args['template_id'] = _dict.get('template_id')
        if 'override_command' in _dict:
            args['override_command'] = TemplateCommand.from_dict(_dict.get('override_command'))
        if 'post_condition' in _dict:
            args['post_condition'] = _dict.get('post_condition')
        if 'on_error' in _dict:
            args['on_error'] = _dict.get('on_error')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateFlowDefinitionTemplateOperation object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'pre_condition') and self.pre_condition is not None:
            _dict['pre_condition'] = self.pre_condition
        if hasattr(self, 'template_id') and self.template_id is not None:
            _dict['template_id'] = self.template_id
        if hasattr(self, 'override_command') and self.override_command is not None:
            _dict['override_command'] = self.override_command.to_dict()
        if hasattr(self, 'post_condition') and self.post_condition is not None:
            _dict['post_condition'] = self.post_condition
        if hasattr(self, 'on_error') and self.on_error is not None:
            _dict['on_error'] = self.on_error
        for _key in [k for k in vars(self).keys() if k not in TemplateFlowDefinitionTemplateOperation._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateFlowDefinitionTemplateOperation object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateFlowDefinitionTemplateOperation') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateFlowDefinitionTemplateOperation') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TemplateFlowList():
    """
    List of Flow definitions response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[TemplateFlowLite] flows: (optional) List of flow records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'flows'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 flows: List['TemplateFlowLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateFlowList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[TemplateFlowLite] flows: (optional) List of flow records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.flows = flows
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateFlowList':
        """Initialize a TemplateFlowList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in TemplateFlowList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in TemplateFlowList JSON')
        if 'flows' in _dict:
            args['flows'] = [TemplateFlowLite.from_dict(x) for x in _dict.get('flows')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateFlowList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'flows') and self.flows is not None:
            _dict['flows'] = [x.to_dict() for x in self.flows]
        for _key in [k for k in vars(self).keys() if k not in TemplateFlowList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateFlowList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateFlowList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateFlowList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TemplateFlowLite():
    """
    Flow summary profile with system generated data.

    :attr str id: (optional) Id of the Flow.
    :attr str name: (optional) Name of the Flow.
    :attr str version: (optional) Version of the flow definition. Only value 'V1' is
          accepted.
    :attr str type: (optional) Type of flow.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr JobStatusWorkspaceTemplateFlow status: (optional) Flow Job Status.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr datetime created_at: (optional) Flow creation time.
    :attr str created_by: (optional) Email address of user who created the flow.
    :attr datetime updated_at: (optional) TemplateFlow updation time.
    :attr str updated_by: (optional) Email address of user who updated the flow.
    """

    # The set of defined properties for the class
    _properties = frozenset(['id', 'name', 'version', 'type', 'user_state', 'status', 'sys_lock', 'created_at', 'created_by', 'updated_at', 'updated_by'])

    def __init__(self,
                 *,
                 id: str = None,
                 name: str = None,
                 version: str = None,
                 type: str = None,
                 user_state: 'UserState' = None,
                 status: 'JobStatusWorkspaceTemplateFlow' = None,
                 sys_lock: 'SystemLock' = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateFlowLite object.

        :param str id: (optional) Id of the Flow.
        :param str name: (optional) Name of the Flow.
        :param str version: (optional) Version of the flow definition. Only value
               'V1' is accepted.
        :param str type: (optional) Type of flow.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param JobStatusWorkspaceTemplateFlow status: (optional) Flow Job Status.
        :param SystemLock sys_lock: (optional) System lock status.
        :param datetime created_at: (optional) Flow creation time.
        :param str created_by: (optional) Email address of user who created the
               flow.
        :param datetime updated_at: (optional) TemplateFlow updation time.
        :param str updated_by: (optional) Email address of user who updated the
               flow.
        :param **kwargs: (optional) Any additional properties.
        """
        self.id = id
        self.name = name
        self.version = version
        self.type = type
        self.user_state = user_state
        self.status = status
        self.sys_lock = sys_lock
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateFlowLite':
        """Initialize a TemplateFlowLite object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'version' in _dict:
            args['version'] = _dict.get('version')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'status' in _dict:
            args['status'] = JobStatusWorkspaceTemplateFlow.from_dict(_dict.get('status'))
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateFlowLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'version') and self.version is not None:
            _dict['version'] = self.version
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status.to_dict()
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'updated_by') and self.updated_by is not None:
            _dict['updated_by'] = self.updated_by
        for _key in [k for k in vars(self).keys() if k not in TemplateFlowLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateFlowLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateFlowLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateFlowLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Type of flow.
        """
        SIMPLE_FLOW = 'simple_flow'
        NODE_RED_FLOW = 'node_red_flow'


class TemplateFlowValidationLogs():
    """
    TemplateFlowValidationLogs.

    :attr int flow_index: (optional) Line number of the flow-item.
    :attr List[TemplateFlowDataValidationStatus] inputs_status: (optional)
          Validation status of input data for the flow-item.
    :attr List[TemplateFlowDataValidationStatus] outputs_status: (optional)
          Validation status of output data for the flow-item.
    """

    # The set of defined properties for the class
    _properties = frozenset(['flow_index', 'inputs_status', 'outputs_status'])

    def __init__(self,
                 *,
                 flow_index: int = None,
                 inputs_status: List['TemplateFlowDataValidationStatus'] = None,
                 outputs_status: List['TemplateFlowDataValidationStatus'] = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateFlowValidationLogs object.

        :param int flow_index: (optional) Line number of the flow-item.
        :param List[TemplateFlowDataValidationStatus] inputs_status: (optional)
               Validation status of input data for the flow-item.
        :param List[TemplateFlowDataValidationStatus] outputs_status: (optional)
               Validation status of output data for the flow-item.
        :param **kwargs: (optional) Any additional properties.
        """
        self.flow_index = flow_index
        self.inputs_status = inputs_status
        self.outputs_status = outputs_status
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateFlowValidationLogs':
        """Initialize a TemplateFlowValidationLogs object from a json dictionary."""
        args = {}
        if 'flow_index' in _dict:
            args['flow_index'] = _dict.get('flow_index')
        if 'inputs_status' in _dict:
            args['inputs_status'] = [TemplateFlowDataValidationStatus.from_dict(x) for x in _dict.get('inputs_status')]
        if 'outputs_status' in _dict:
            args['outputs_status'] = [TemplateFlowDataValidationStatus.from_dict(x) for x in _dict.get('outputs_status')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateFlowValidationLogs object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'flow_index') and self.flow_index is not None:
            _dict['flow_index'] = self.flow_index
        if hasattr(self, 'inputs_status') and self.inputs_status is not None:
            _dict['inputs_status'] = [x.to_dict() for x in self.inputs_status]
        if hasattr(self, 'outputs_status') and self.outputs_status is not None:
            _dict['outputs_status'] = [x.to_dict() for x in self.outputs_status]
        for _key in [k for k in vars(self).keys() if k not in TemplateFlowValidationLogs._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateFlowValidationLogs object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateFlowValidationLogs') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateFlowValidationLogs') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TemplateFlowValidationSummary():
    """
    Validation summary.

    :attr float warning_count: (optional) Number of warnings in the flow.
    :attr float error_count: (optional) Number of errors in the flow.
    """

    # The set of defined properties for the class
    _properties = frozenset(['warning_count', 'error_count'])

    def __init__(self,
                 *,
                 warning_count: float = None,
                 error_count: float = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateFlowValidationSummary object.

        :param float warning_count: (optional) Number of warnings in the flow.
        :param float error_count: (optional) Number of errors in the flow.
        :param **kwargs: (optional) Any additional properties.
        """
        self.warning_count = warning_count
        self.error_count = error_count
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateFlowValidationSummary':
        """Initialize a TemplateFlowValidationSummary object from a json dictionary."""
        args = {}
        if 'warning_count' in _dict:
            args['warning_count'] = _dict.get('warning_count')
        if 'error_count' in _dict:
            args['error_count'] = _dict.get('error_count')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateFlowValidationSummary object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'warning_count') and self.warning_count is not None:
            _dict['warning_count'] = self.warning_count
        if hasattr(self, 'error_count') and self.error_count is not None:
            _dict['error_count'] = self.error_count
        for _key in [k for k in vars(self).keys() if k not in TemplateFlowValidationSummary._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateFlowValidationSummary object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateFlowValidationSummary') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateFlowValidationSummary') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TemplateList():
    """
    List of Templates in a Workspace.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[TemplateLite] templates: (optional) List of template records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'templates'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 templates: List['TemplateLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.templates = templates
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateList':
        """Initialize a TemplateList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in TemplateList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in TemplateList JSON')
        if 'templates' in _dict:
            args['templates'] = [TemplateLite.from_dict(x) for x in _dict.get('templates')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and getattr(self, 'total_count') is not None:
            _dict['total_count'] = getattr(self, 'total_count')
        if hasattr(self, 'limit') and getattr(self, 'limit') is not None:
            _dict['limit'] = getattr(self, 'limit')
        if hasattr(self, 'offset') and getattr(self, 'offset') is not None:
            _dict['offset'] = getattr(self, 'offset')
        if hasattr(self, 'templates') and getattr(self, 'templates') is not None:
            _dict['templates'] = [x.to_dict() for x in getattr(self, 'templates')]
        for _key in [k for k in vars(self).keys() if k not in TemplateList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TemplateListRequest():
    """
    List of user-defined Template definitions.

    :attr List[Template] templates: (optional) List of Template definitions.
    """

    # The set of defined properties for the class
    _properties = frozenset(['templates'])

    def __init__(self,
                 *,
                 templates: List['Template'] = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateListRequest object.

        :param List[Template] templates: (optional) List of Template definitions.
        :param **kwargs: (optional) Any additional properties.
        """
        self.templates = templates
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateListRequest':
        """Initialize a TemplateListRequest object from a json dictionary."""
        args = {}
        if 'templates' in _dict:
            args['templates'] = [Template.from_dict(x) for x in _dict.get('templates')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateListRequest object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'templates') and self.templates is not None:
            _dict['templates'] = [x.to_dict() for x in self.templates]
        for _key in [k for k in vars(self).keys() if k not in TemplateListRequest._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateListRequest object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateListRequest') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateListRequest') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TemplateLite():
    """
    Template summary profile with user inputs and system generated data.

    :attr str id: (optional) Template ID generated by the system.
    :attr str name: (optional) Name of the template. Should be unique within a
          workspace.
    :attr str description: (optional) Template description.
    :attr str type: (optional) Template type.  Ex: terraform_v0.11, terraform_v0.12,
          ansible.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr str source_type: (optional) Type of source for the Template.
    :attr JobStatusTemplate status: (optional) Template Job Status.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr datetime created_at: (optional) Template creation time.
    :attr str created_by: (optional) Email address of user who created the template.
    :attr datetime updated_at: (optional) Template updation time.
    :attr str updated_by: (optional) Email address of user who updated the template.
    """

    # The set of defined properties for the class
    _properties = frozenset(['id', 'name', 'description', 'type', 'user_state', 'source_type', 'status', 'sys_lock', 'created_at', 'created_by', 'updated_at', 'updated_by'])

    def __init__(self,
                 *,
                 id: str = None,
                 name: str = None,
                 description: str = None,
                 type: str = None,
                 user_state: 'UserState' = None,
                 source_type: str = None,
                 status: 'JobStatusTemplate' = None,
                 sys_lock: 'SystemLock' = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateLite object.

        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param str source_type: (optional) Type of source for the Template.
        :param JobStatusTemplate status: (optional) Template Job Status.
        :param SystemLock sys_lock: (optional) System lock status.
        :param datetime created_at: (optional) Template creation time.
        :param str created_by: (optional) Email address of user who created the
               template.
        :param datetime updated_at: (optional) Template updation time.
        :param str updated_by: (optional) Email address of user who updated the
               template.
        :param **kwargs: (optional) Any additional properties.
        """
        self.id = id
        self.name = name
        self.description = description
        self.type = type
        self.user_state = user_state
        self.source_type = source_type
        self.status = status
        self.sys_lock = sys_lock
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateLite':
        """Initialize a TemplateLite object from a json dictionary."""
        args = {}
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'source_type' in _dict:
            args['source_type'] = _dict.get('source_type')
        if 'status' in _dict:
            args['status'] = JobStatusTemplate.from_dict(_dict.get('status'))
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'name') and getattr(self, 'name') is not None:
            _dict['name'] = getattr(self, 'name')
        if hasattr(self, 'description') and getattr(self, 'description') is not None:
            _dict['description'] = getattr(self, 'description')
        if hasattr(self, 'type') and getattr(self, 'type') is not None:
            _dict['type'] = getattr(self, 'type')
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'source_type') and self.source_type is not None:
            _dict['source_type'] = self.source_type
        if hasattr(self, 'status') and self.status is not None:
            _dict['status'] = self.status.to_dict()
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'updated_by') and self.updated_by is not None:
            _dict['updated_by'] = self.updated_by
        for _key in [k for k in vars(self).keys() if k not in TemplateLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class SourceTypeEnum(str, Enum):
        """
        Type of source for the Template.
        """
        LOCAL = 'local'
        GIT_HUB = 'git_hub'
        GIT_HUB_ENTERPRISE = 'git_hub_enterprise'
        GIT_LAB = 'git_lab'
        IBM_GIT_LAB = 'ibm_git_lab'
        IBM_CLOUD_CATALOG = 'ibm_cloud_catalog'
        EXTERNAL_SCM = 'external_scm'


class TemplateRepoTarUploadResponse():
    """
    TemplateRepoTarUploadResponse -.

    :attr str file_value: (optional) Tar file value.
    :attr bool has_received_file: (optional) Has received tar file?.
    :attr str id: (optional) Template ID.
    """

    # The set of defined properties for the class
    _properties = frozenset(['file_value', 'has_received_file', 'id'])

    def __init__(self,
                 *,
                 file_value: str = None,
                 has_received_file: bool = None,
                 id: str = None,
                 **kwargs) -> None:
        """
        Initialize a TemplateRepoTarUploadResponse object.

        :param str file_value: (optional) Tar file value.
        :param bool has_received_file: (optional) Has received tar file?.
        :param str id: (optional) Template ID.
        :param **kwargs: (optional) Any additional properties.
        """
        self.file_value = file_value
        self.has_received_file = has_received_file
        self.id = id
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TemplateRepoTarUploadResponse':
        """Initialize a TemplateRepoTarUploadResponse object from a json dictionary."""
        args = {}
        if 'file_value' in _dict:
            args['file_value'] = _dict.get('file_value')
        if 'has_received_file' in _dict:
            args['has_received_file'] = _dict.get('has_received_file')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TemplateRepoTarUploadResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'file_value') and self.file_value is not None:
            _dict['file_value'] = self.file_value
        if hasattr(self, 'has_received_file') and self.has_received_file is not None:
            _dict['has_received_file'] = self.has_received_file
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        for _key in [k for k in vars(self).keys() if k not in TemplateRepoTarUploadResponse._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TemplateRepoTarUploadResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TemplateRepoTarUploadResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TemplateRepoTarUploadResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class Trigger():
    """
    Complete Trigger details provided by user and system generated.

    :attr str name: (optional) Name of the trigger.
    :attr str type: (optional) Type of the trigger.
    :attr str description: (optional) Trigger description.
    :attr str resource_group: (optional) Resource-group id for the Trigger.
    :attr bytes service_id: (optional) The id of service ID to be associated with
          this Trigger.
    :attr bytes apikey: (optional) API Key for the Service ID.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr List[str] tags: (optional) Schematics trigger tags.
    :attr List[TriggerJob] job_triggers: (optional) List of Job Triggers.
    :attr List[TriggerScheduled] scheduled_triggers: (optional) List of Scheduled
          Triggers.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr str trigger_id: (optional) Id of the Schematics trigger.
    :attr str registered_by: (optional) Name of the user who registered the
          Schematics trigger.
    :attr datetime registered_at: (optional) Timestamp of Schematics trigger
          registration.
    :attr datetime updated_at: (optional) Schematics trigger updation time.
    :attr str updated_by: (optional) Name of user who updated the Schematics trigger
          definition.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr datetime last_health_checked_at: (optional) Timestamp of the last health
          check.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'type', 'description', 'resource_group', 'service_id', 'apikey', 'location', 'tags', 'job_triggers', 'scheduled_triggers', 'user_state', 'trigger_id', 'registered_by', 'registered_at', 'updated_at', 'updated_by', 'sys_lock', 'last_health_checked_at'])

    def __init__(self,
                 *,
                 name: str = None,
                 type: str = None,
                 description: str = None,
                 resource_group: str = None,
                 service_id: bytes = None,
                 apikey: bytes = None,
                 location: str = None,
                 tags: List[str] = None,
                 job_triggers: List['TriggerJob'] = None,
                 scheduled_triggers: List['TriggerScheduled'] = None,
                 user_state: 'UserState' = None,
                 trigger_id: str = None,
                 registered_by: str = None,
                 registered_at: datetime = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 sys_lock: 'SystemLock' = None,
                 last_health_checked_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a Trigger object.

        :param str name: (optional) Name of the trigger.
        :param str type: (optional) Type of the trigger.
        :param str description: (optional) Trigger description.
        :param str resource_group: (optional) Resource-group id for the Trigger.
        :param bytes service_id: (optional) The id of service ID to be associated
               with this Trigger.
        :param bytes apikey: (optional) API Key for the Service ID.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param List[str] tags: (optional) Schematics trigger tags.
        :param List[TriggerJob] job_triggers: (optional) List of Job Triggers.
        :param List[TriggerScheduled] scheduled_triggers: (optional) List of
               Scheduled Triggers.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param SystemLock sys_lock: (optional) System lock status.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.type = type
        self.description = description
        self.resource_group = resource_group
        self.service_id = service_id
        self.apikey = apikey
        self.location = location
        self.tags = tags
        self.job_triggers = job_triggers
        self.scheduled_triggers = scheduled_triggers
        self.user_state = user_state
        self.trigger_id = trigger_id
        self.registered_by = registered_by
        self.registered_at = registered_at
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.sys_lock = sys_lock
        self.last_health_checked_at = last_health_checked_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Trigger':
        """Initialize a Trigger object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'service_id' in _dict:
            args['service_id'] = base64.b64decode(_dict.get('service_id'))
        if 'apikey' in _dict:
            args['apikey'] = base64.b64decode(_dict.get('apikey'))
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'job_triggers' in _dict:
            args['job_triggers'] = [TriggerJob.from_dict(x) for x in _dict.get('job_triggers')]
        if 'scheduled_triggers' in _dict:
            args['scheduled_triggers'] = [TriggerScheduled.from_dict(x) for x in _dict.get('scheduled_triggers')]
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'trigger_id' in _dict:
            args['trigger_id'] = _dict.get('trigger_id')
        if 'registered_by' in _dict:
            args['registered_by'] = _dict.get('registered_by')
        if 'registered_at' in _dict:
            args['registered_at'] = string_to_datetime(_dict.get('registered_at'))
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'last_health_checked_at' in _dict:
            args['last_health_checked_at'] = string_to_datetime(_dict.get('last_health_checked_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Trigger object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = str(base64.b64encode(self.service_id), 'utf-8')
        if hasattr(self, 'apikey') and self.apikey is not None:
            _dict['apikey'] = str(base64.b64encode(self.apikey), 'utf-8')
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'job_triggers') and self.job_triggers is not None:
            _dict['job_triggers'] = [x.to_dict() for x in self.job_triggers]
        if hasattr(self, 'scheduled_triggers') and self.scheduled_triggers is not None:
            _dict['scheduled_triggers'] = [x.to_dict() for x in self.scheduled_triggers]
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'trigger_id') and getattr(self, 'trigger_id') is not None:
            _dict['trigger_id'] = getattr(self, 'trigger_id')
        if hasattr(self, 'registered_by') and getattr(self, 'registered_by') is not None:
            _dict['registered_by'] = getattr(self, 'registered_by')
        if hasattr(self, 'registered_at') and getattr(self, 'registered_at') is not None:
            _dict['registered_at'] = datetime_to_string(getattr(self, 'registered_at'))
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'last_health_checked_at') and getattr(self, 'last_health_checked_at') is not None:
            _dict['last_health_checked_at'] = datetime_to_string(getattr(self, 'last_health_checked_at'))
        for _key in [k for k in vars(self).keys() if k not in Trigger._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Trigger object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Trigger') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Trigger') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Type of the trigger.
        """
        ACTION = 'action'
        SCHEDULED = 'scheduled'


    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class TriggerJob():
    """
    Job Trigger.

    :attr str event: (optional) Time in UTC format.
    :attr Job job: (optional) Complete Job with user inputs and system generated
          data.
    """

    # The set of defined properties for the class
    _properties = frozenset(['event', 'job'])

    def __init__(self,
                 *,
                 event: str = None,
                 job: 'Job' = None,
                 **kwargs) -> None:
        """
        Initialize a TriggerJob object.

        :param str event: (optional) Time in UTC format.
        :param Job job: (optional) Complete Job with user inputs and system
               generated data.
        :param **kwargs: (optional) Any additional properties.
        """
        self.event = event
        self.job = job
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TriggerJob':
        """Initialize a TriggerJob object from a json dictionary."""
        args = {}
        if 'event' in _dict:
            args['event'] = _dict.get('event')
        if 'job' in _dict:
            args['job'] = Job.from_dict(_dict.get('job'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TriggerJob object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'event') and self.event is not None:
            _dict['event'] = self.event
        if hasattr(self, 'job') and self.job is not None:
            _dict['job'] = self.job.to_dict()
        for _key in [k for k in vars(self).keys() if k not in TriggerJob._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TriggerJob object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TriggerJob') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TriggerJob') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TriggerList():
    """
    List of trigger definitions response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[Trigger] triggers: (optional) List of triggers.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'triggers'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 triggers: List['Trigger'] = None,
                 **kwargs) -> None:
        """
        Initialize a TriggerList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[Trigger] triggers: (optional) List of triggers.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.triggers = triggers
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TriggerList':
        """Initialize a TriggerList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in TriggerList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in TriggerList JSON')
        if 'triggers' in _dict:
            args['triggers'] = [Trigger.from_dict(x) for x in _dict.get('triggers')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TriggerList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'triggers') and self.triggers is not None:
            _dict['triggers'] = [x.to_dict() for x in self.triggers]
        for _key in [k for k in vars(self).keys() if k not in TriggerList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TriggerList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TriggerList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TriggerList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class TriggerScheduled():
    """
    Scheduled Trigger.

    :attr str frequency: (optional) frequency.
    :attr str time: (optional) Tinme in UTC format.
    :attr str day: (optional) Day.
    """

    # The set of defined properties for the class
    _properties = frozenset(['frequency', 'time', 'day'])

    def __init__(self,
                 *,
                 frequency: str = None,
                 time: str = None,
                 day: str = None,
                 **kwargs) -> None:
        """
        Initialize a TriggerScheduled object.

        :param str frequency: (optional) frequency.
        :param str time: (optional) Tinme in UTC format.
        :param str day: (optional) Day.
        :param **kwargs: (optional) Any additional properties.
        """
        self.frequency = frequency
        self.time = time
        self.day = day
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'TriggerScheduled':
        """Initialize a TriggerScheduled object from a json dictionary."""
        args = {}
        if 'frequency' in _dict:
            args['frequency'] = _dict.get('frequency')
        if 'time' in _dict:
            args['time'] = _dict.get('time')
        if 'day' in _dict:
            args['day'] = _dict.get('day')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a TriggerScheduled object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'frequency') and self.frequency is not None:
            _dict['frequency'] = self.frequency
        if hasattr(self, 'time') and self.time is not None:
            _dict['time'] = self.time
        if hasattr(self, 'day') and self.day is not None:
            _dict['day'] = self.day
        for _key in [k for k in vars(self).keys() if k not in TriggerScheduled._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this TriggerScheduled object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'TriggerScheduled') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'TriggerScheduled') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class UpdateCartOrder():
    """
    Update Cart order details with user inputs data.

    :attr str name: (optional) Cart order name (unique for an account).
    :attr str description: (optional) Cart order description.
    :attr List[str] tags: (optional) Cart order tags.
    :attr List[UpdateOrderItemConfiguration] cart_items: (optional)
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'tags', 'cart_items'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 tags: List[str] = None,
                 cart_items: List['UpdateOrderItemConfiguration'] = None,
                 **kwargs) -> None:
        """
        Initialize a UpdateCartOrder object.

        :param str name: (optional) Cart order name (unique for an account).
        :param str description: (optional) Cart order description.
        :param List[str] tags: (optional) Cart order tags.
        :param List[UpdateOrderItemConfiguration] cart_items: (optional)
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.tags = tags
        self.cart_items = cart_items
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UpdateCartOrder':
        """Initialize a UpdateCartOrder object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'cart_items' in _dict:
            args['cart_items'] = [UpdateOrderItemConfiguration.from_dict(x) for x in _dict.get('cart_items')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UpdateCartOrder object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'cart_items') and self.cart_items is not None:
            _dict['cart_items'] = [x.to_dict() for x in self.cart_items]
        for _key in [k for k in vars(self).keys() if k not in UpdateCartOrder._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UpdateCartOrder object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UpdateCartOrder') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UpdateCartOrder') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class UpdateOrderItemConfiguration():
    """
    Update Catalog item configuration in the Cart order.

    :attr str name: (optional) Catalog item name.
    :attr str description: (optional) Catalog item description.
    :attr List[VariableData] inputs: (optional) Input configuration for the order.
    :attr List[VariableData] settings: (optional) Input environment variables used
          by order.
    :attr List[VariableData] outputs: (optional) Output configuration of the order.
    :attr TargetRequest target: (optional) Target cluster details to perform POC
          operation.
    :attr str operation: (optional) Name of the fulfilment job operations.
    :attr List[ServiceVariableData] service_data: (optional) Additional service
          input data (for extensibility).
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'inputs', 'settings', 'outputs', 'target', 'operation', 'service_data'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 inputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 outputs: List['VariableData'] = None,
                 target: 'TargetRequest' = None,
                 operation: str = None,
                 service_data: List['ServiceVariableData'] = None,
                 **kwargs) -> None:
        """
        Initialize a UpdateOrderItemConfiguration object.

        :param str name: (optional) Catalog item name.
        :param str description: (optional) Catalog item description.
        :param List[VariableData] inputs: (optional) Input configuration for the
               order.
        :param List[VariableData] settings: (optional) Input environment variables
               used by order.
        :param List[VariableData] outputs: (optional) Output configuration of the
               order.
        :param TargetRequest target: (optional) Target cluster details to perform
               POC operation.
        :param str operation: (optional) Name of the fulfilment job operations.
        :param List[ServiceVariableData] service_data: (optional) Additional
               service input data (for extensibility).
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.inputs = inputs
        self.settings = settings
        self.outputs = outputs
        self.target = target
        self.operation = operation
        self.service_data = service_data
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UpdateOrderItemConfiguration':
        """Initialize a UpdateOrderItemConfiguration object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        if 'target' in _dict:
            args['target'] = TargetRequest.from_dict(_dict.get('target'))
        if 'operation' in _dict:
            args['operation'] = _dict.get('operation')
        if 'service_data' in _dict:
            args['service_data'] = [ServiceVariableData.from_dict(x) for x in _dict.get('service_data')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UpdateOrderItemConfiguration object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        if hasattr(self, 'target') and self.target is not None:
            _dict['target'] = self.target.to_dict()
        if hasattr(self, 'operation') and self.operation is not None:
            _dict['operation'] = self.operation
        if hasattr(self, 'service_data') and self.service_data is not None:
            _dict['service_data'] = [x.to_dict() for x in self.service_data]
        for _key in [k for k in vars(self).keys() if k not in UpdateOrderItemConfiguration._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UpdateOrderItemConfiguration object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UpdateOrderItemConfiguration') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UpdateOrderItemConfiguration') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class OperationEnum(str, Enum):
        """
        Name of the fulfilment job operations.
        """
        CONFIGURE = 'configure'
        DESTROY = 'destroy'
        DRYRUN = 'dryrun'
        INSTALL = 'install'
        OPERATE = 'operate'
        PREVIEW = 'preview'
        UNINSTALL = 'uninstall'
        UPDATE = 'update'


class UserState():
    """
    User defined status of the Schematics object.

    :attr str state: (optional) User-defined states
            * `draft` Object can be modified; can be used by Jobs run by the author,
          during execution
            * `live` Object can be modified; can be used by Jobs during execution
            * `locked` Object cannot be modified; can be used by Jobs during execution
            * `disable` Object can be modified. cannot be used by Jobs during execution.
    :attr str set_by: (optional) Name of the User who set the state of the Object.
    :attr datetime set_at: (optional) When the User who set the state of the Object.
    """

    # The set of defined properties for the class
    _properties = frozenset(['state', 'set_by', 'set_at'])

    def __init__(self,
                 *,
                 state: str = None,
                 set_by: str = None,
                 set_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a UserState object.

        :param str state: (optional) User-defined states
                 * `draft` Object can be modified; can be used by Jobs run by the author,
               during execution
                 * `live` Object can be modified; can be used by Jobs during execution
                 * `locked` Object cannot be modified; can be used by Jobs during
               execution
                 * `disable` Object can be modified. cannot be used by Jobs during
               execution.
        :param str set_by: (optional) Name of the User who set the state of the
               Object.
        :param datetime set_at: (optional) When the User who set the state of the
               Object.
        :param **kwargs: (optional) Any additional properties.
        """
        self.state = state
        self.set_by = set_by
        self.set_at = set_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'UserState':
        """Initialize a UserState object from a json dictionary."""
        args = {}
        if 'state' in _dict:
            args['state'] = _dict.get('state')
        if 'set_by' in _dict:
            args['set_by'] = _dict.get('set_by')
        if 'set_at' in _dict:
            args['set_at'] = string_to_datetime(_dict.get('set_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a UserState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state
        if hasattr(self, 'set_by') and self.set_by is not None:
            _dict['set_by'] = self.set_by
        if hasattr(self, 'set_at') and self.set_at is not None:
            _dict['set_at'] = datetime_to_string(self.set_at)
        for _key in [k for k in vars(self).keys() if k not in UserState._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this UserState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'UserState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'UserState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StateEnum(str, Enum):
        """
        User-defined states
          * `draft` Object can be modified; can be used by Jobs run by the author, during
        execution
          * `live` Object can be modified; can be used by Jobs during execution
          * `locked` Object cannot be modified; can be used by Jobs during execution
          * `disable` Object can be modified. cannot be used by Jobs during execution.
        """
        DRAFT = 'draft'
        LIVE = 'live'
        LOCKED = 'locked'
        DISABLE = 'disable'


class ValueListResponse():
    """
    List of string values.

    :attr List[str] values: (optional) list values.
    """

    # The set of defined properties for the class
    _properties = frozenset(['values'])

    def __init__(self,
                 *,
                 values: List[str] = None,
                 **kwargs) -> None:
        """
        Initialize a ValueListResponse object.

        :param List[str] values: (optional) list values.
        :param **kwargs: (optional) Any additional properties.
        """
        self.values = values
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ValueListResponse':
        """Initialize a ValueListResponse object from a json dictionary."""
        args = {}
        if 'values' in _dict:
            args['values'] = _dict.get('values')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ValueListResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'values') and self.values is not None:
            _dict['values'] = self.values
        for _key in [k for k in vars(self).keys() if k not in ValueListResponse._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ValueListResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ValueListResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ValueListResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class ValueResponse():
    """
    String value.

    :attr str value: (optional) value response.
    """

    # The set of defined properties for the class
    _properties = frozenset(['value'])

    def __init__(self,
                 *,
                 value: str = None,
                 **kwargs) -> None:
        """
        Initialize a ValueResponse object.

        :param str value: (optional) value response.
        :param **kwargs: (optional) Any additional properties.
        """
        self.value = value
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'ValueResponse':
        """Initialize a ValueResponse object from a json dictionary."""
        args = {}
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a ValueResponse object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        for _key in [k for k in vars(self).keys() if k not in ValueResponse._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this ValueResponse object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'ValueResponse') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'ValueResponse') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class VariableData():
    """
    User editable variable data and system generated reference to the value.

    :attr str name: (optional) The name of the variable. For example, `name =
          "inventory username"`.
    :attr str value: (optional) The value for the variable or reference to the
          value. For example, `value = "<provide your ssh_key_value with \n>"`. **Note**
          The SSH key should contain `\n` at the end of the key details in case of command
          line or API calls.
    :attr bool use_default: (optional) True, will ignore the data in the value
          attribute, instead the data in metadata.default_value will be used.
    :attr VariableMetadata metadata: (optional) An user editable metadata for the
          variables.
    :attr str link: (optional) The reference link to the variable value By default
          the expression points to `$self.value`.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'value', 'use_default', 'metadata', 'link'])

    def __init__(self,
                 *,
                 name: str = None,
                 value: str = None,
                 use_default: bool = None,
                 metadata: 'VariableMetadata' = None,
                 link: str = None,
                 **kwargs) -> None:
        """
        Initialize a VariableData object.

        :param str name: (optional) The name of the variable. For example, `name =
               "inventory username"`.
        :param str value: (optional) The value for the variable or reference to the
               value. For example, `value = "<provide your ssh_key_value with \n>"`.
               **Note** The SSH key should contain `\n` at the end of the key details in
               case of command line or API calls.
        :param bool use_default: (optional) True, will ignore the data in the value
               attribute, instead the data in metadata.default_value will be used.
        :param VariableMetadata metadata: (optional) An user editable metadata for
               the variables.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.value = value
        self.use_default = use_default
        self.metadata = metadata
        self.link = link
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'VariableData':
        """Initialize a VariableData object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'value' in _dict:
            args['value'] = _dict.get('value')
        if 'use_default' in _dict:
            args['use_default'] = _dict.get('use_default')
        if 'metadata' in _dict:
            args['metadata'] = VariableMetadata.from_dict(_dict.get('metadata'))
        if 'link' in _dict:
            args['link'] = _dict.get('link')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a VariableData object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'value') and self.value is not None:
            _dict['value'] = self.value
        if hasattr(self, 'use_default') and self.use_default is not None:
            _dict['use_default'] = self.use_default
        if hasattr(self, 'metadata') and self.metadata is not None:
            _dict['metadata'] = self.metadata.to_dict()
        if hasattr(self, 'link') and getattr(self, 'link') is not None:
            _dict['link'] = getattr(self, 'link')
        for _key in [k for k in vars(self).keys() if k not in VariableData._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this VariableData object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'VariableData') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'VariableData') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class VariableDataList():
    """
    List of Variable data record response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[VariableData] variables: (optional) List of variables and values.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'variables'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 variables: List['VariableData'] = None,
                 **kwargs) -> None:
        """
        Initialize a VariableDataList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[VariableData] variables: (optional) List of variables and
               values.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.variables = variables
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'VariableDataList':
        """Initialize a VariableDataList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in VariableDataList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in VariableDataList JSON')
        if 'variables' in _dict:
            args['variables'] = [VariableData.from_dict(x) for x in _dict.get('variables')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a VariableDataList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'variables') and self.variables is not None:
            _dict['variables'] = [x.to_dict() for x in self.variables]
        for _key in [k for k in vars(self).keys() if k not in VariableDataList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this VariableDataList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'VariableDataList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'VariableDataList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class VariableMetadata():
    """
    An user editable metadata for the variables.

    :attr str type: (optional) Type of the variable.
    :attr List[str] aliases: (optional) The list of aliases for the variable name.
    :attr str description: (optional) The description of the meta data.
    :attr str cloud_data_type: (optional) Cloud data type of the variable. eg.
          resource_group_id, region, vpc_id.
    :attr str default_value: (optional) Default value for the variable only if the
          override value is not specified.
    :attr str link_status: (optional) The status of the link.
    :attr bool secure: (optional) Is the variable secure or sensitive ?.
    :attr bool immutable: (optional) Is the variable readonly ?.
    :attr bool hidden: (optional) If **true**, the variable is not displayed on UI
          or Command line.
    :attr bool required: (optional) If the variable required?.
    :attr List[str] options: (optional) The list of possible values for this
          variable.  If type is **integer** or **date**, then the array of string is
          converted to array of integers or date during the runtime.
    :attr int min_value: (optional) The minimum value of the variable. Applicable
          for the integer type.
    :attr int max_value: (optional) The maximum value of the variable. Applicable
          for the integer type.
    :attr int min_length: (optional) The minimum length of the variable value.
          Applicable for the string type.
    :attr int max_length: (optional) The maximum length of the variable value.
          Applicable for the string type.
    :attr str matches: (optional) The regex for the variable value.
    :attr int position: (optional) The relative position of this variable in a list.
    :attr str group_by: (optional) The display name of the group this variable
          belongs to.
    :attr str source: (optional) The source of this meta-data.
    """

    # The set of defined properties for the class
    _properties = frozenset(['type', 'aliases', 'description', 'cloud_data_type', 'default_value', 'link_status', 'secure', 'immutable', 'hidden', 'required', 'options', 'min_value', 'max_value', 'min_length', 'max_length', 'matches', 'position', 'group_by', 'source'])

    def __init__(self,
                 *,
                 type: str = None,
                 aliases: List[str] = None,
                 description: str = None,
                 cloud_data_type: str = None,
                 default_value: str = None,
                 link_status: str = None,
                 secure: bool = None,
                 immutable: bool = None,
                 hidden: bool = None,
                 required: bool = None,
                 options: List[str] = None,
                 min_value: int = None,
                 max_value: int = None,
                 min_length: int = None,
                 max_length: int = None,
                 matches: str = None,
                 position: int = None,
                 group_by: str = None,
                 source: str = None,
                 **kwargs) -> None:
        """
        Initialize a VariableMetadata object.

        :param str type: (optional) Type of the variable.
        :param List[str] aliases: (optional) The list of aliases for the variable
               name.
        :param str description: (optional) The description of the meta data.
        :param str cloud_data_type: (optional) Cloud data type of the variable. eg.
               resource_group_id, region, vpc_id.
        :param str default_value: (optional) Default value for the variable only if
               the override value is not specified.
        :param str link_status: (optional) The status of the link.
        :param bool secure: (optional) Is the variable secure or sensitive ?.
        :param bool immutable: (optional) Is the variable readonly ?.
        :param bool hidden: (optional) If **true**, the variable is not displayed
               on UI or Command line.
        :param bool required: (optional) If the variable required?.
        :param List[str] options: (optional) The list of possible values for this
               variable.  If type is **integer** or **date**, then the array of string is
               converted to array of integers or date during the runtime.
        :param int min_value: (optional) The minimum value of the variable.
               Applicable for the integer type.
        :param int max_value: (optional) The maximum value of the variable.
               Applicable for the integer type.
        :param int min_length: (optional) The minimum length of the variable value.
               Applicable for the string type.
        :param int max_length: (optional) The maximum length of the variable value.
               Applicable for the string type.
        :param str matches: (optional) The regex for the variable value.
        :param int position: (optional) The relative position of this variable in a
               list.
        :param str group_by: (optional) The display name of the group this variable
               belongs to.
        :param str source: (optional) The source of this meta-data.
        :param **kwargs: (optional) Any additional properties.
        """
        self.type = type
        self.aliases = aliases
        self.description = description
        self.cloud_data_type = cloud_data_type
        self.default_value = default_value
        self.link_status = link_status
        self.secure = secure
        self.immutable = immutable
        self.hidden = hidden
        self.required = required
        self.options = options
        self.min_value = min_value
        self.max_value = max_value
        self.min_length = min_length
        self.max_length = max_length
        self.matches = matches
        self.position = position
        self.group_by = group_by
        self.source = source
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'VariableMetadata':
        """Initialize a VariableMetadata object from a json dictionary."""
        args = {}
        if 'type' in _dict:
            args['type'] = _dict.get('type')
        if 'aliases' in _dict:
            args['aliases'] = _dict.get('aliases')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'cloud_data_type' in _dict:
            args['cloud_data_type'] = _dict.get('cloud_data_type')
        if 'default_value' in _dict:
            args['default_value'] = _dict.get('default_value')
        if 'link_status' in _dict:
            args['link_status'] = _dict.get('link_status')
        if 'secure' in _dict:
            args['secure'] = _dict.get('secure')
        if 'immutable' in _dict:
            args['immutable'] = _dict.get('immutable')
        if 'hidden' in _dict:
            args['hidden'] = _dict.get('hidden')
        if 'required' in _dict:
            args['required'] = _dict.get('required')
        if 'options' in _dict:
            args['options'] = _dict.get('options')
        if 'min_value' in _dict:
            args['min_value'] = _dict.get('min_value')
        if 'max_value' in _dict:
            args['max_value'] = _dict.get('max_value')
        if 'min_length' in _dict:
            args['min_length'] = _dict.get('min_length')
        if 'max_length' in _dict:
            args['max_length'] = _dict.get('max_length')
        if 'matches' in _dict:
            args['matches'] = _dict.get('matches')
        if 'position' in _dict:
            args['position'] = _dict.get('position')
        if 'group_by' in _dict:
            args['group_by'] = _dict.get('group_by')
        if 'source' in _dict:
            args['source'] = _dict.get('source')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a VariableMetadata object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'type') and self.type is not None:
            _dict['type'] = self.type
        if hasattr(self, 'aliases') and self.aliases is not None:
            _dict['aliases'] = self.aliases
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'cloud_data_type') and self.cloud_data_type is not None:
            _dict['cloud_data_type'] = self.cloud_data_type
        if hasattr(self, 'default_value') and self.default_value is not None:
            _dict['default_value'] = self.default_value
        if hasattr(self, 'link_status') and self.link_status is not None:
            _dict['link_status'] = self.link_status
        if hasattr(self, 'secure') and self.secure is not None:
            _dict['secure'] = self.secure
        if hasattr(self, 'immutable') and self.immutable is not None:
            _dict['immutable'] = self.immutable
        if hasattr(self, 'hidden') and self.hidden is not None:
            _dict['hidden'] = self.hidden
        if hasattr(self, 'required') and self.required is not None:
            _dict['required'] = self.required
        if hasattr(self, 'options') and self.options is not None:
            _dict['options'] = self.options
        if hasattr(self, 'min_value') and self.min_value is not None:
            _dict['min_value'] = self.min_value
        if hasattr(self, 'max_value') and self.max_value is not None:
            _dict['max_value'] = self.max_value
        if hasattr(self, 'min_length') and self.min_length is not None:
            _dict['min_length'] = self.min_length
        if hasattr(self, 'max_length') and self.max_length is not None:
            _dict['max_length'] = self.max_length
        if hasattr(self, 'matches') and self.matches is not None:
            _dict['matches'] = self.matches
        if hasattr(self, 'position') and self.position is not None:
            _dict['position'] = self.position
        if hasattr(self, 'group_by') and self.group_by is not None:
            _dict['group_by'] = self.group_by
        if hasattr(self, 'source') and self.source is not None:
            _dict['source'] = self.source
        for _key in [k for k in vars(self).keys() if k not in VariableMetadata._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this VariableMetadata object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'VariableMetadata') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'VariableMetadata') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class TypeEnum(str, Enum):
        """
        Type of the variable.
        """
        BOOLEAN = 'boolean'
        STRING = 'string'
        INTEGER = 'integer'
        DATE = 'date'
        ARRAY = 'array'
        LIST = 'list'
        MAP = 'map'
        COMPLEX = 'complex'
        LINK = 'link'


    class LinkStatusEnum(str, Enum):
        """
        The status of the link.
        """
        NORMAL = 'normal'
        BROKEN = 'broken'


class WebHook():
    """
    Complete WebHook details provided by user and system generated.

    :attr str command_name: (optional) Schematics job command name.
    :attr str hook_type: (optional) Type of the Schematics web-hook.
    :attr str hook_site: (optional) List of notification points.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str resource_group: (optional) Resource-group id for the Schematics
          web-hook.
    :attr List[str] tags: (optional) Schematics web-hook tags.
    :attr str hook_endpoint_url: (optional) Endpoint URL for the Schematics
          web-hook.
    :attr str service_id: (optional) Service-ID to connect to the Schematics
          web-hook; if this is not provided, Schematics will used the IAM token of the
          user to connect to the Hook.
    :attr str apikey: (optional) API Key for the Service ID.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr bool ignore_inflight_operations: (optional) True - Replace the Hook
          definition, without waiting for completion of all inflight Schematics
          operations;   False - Block new Schematics operations, and wait for  the
          relevant inflight operations to complete - before  changing the Hook definition.
    :attr str hook_id: (optional) Id of the Schematics web-hook.
    :attr str registered_by: (optional) Name of the user who registered the
          Schematics web-hook.
    :attr datetime registered_at: (optional) Timestamp of Schematics web-hook
          registration.
    :attr datetime updated_at: (optional) Schematics web-hook updation time.
    :attr str updated_by: (optional) Name of user who updated the Schematics
          web-hook definition.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr datetime last_health_checked_at: (optional) Timestamp of the last health
          check.
    """

    # The set of defined properties for the class
    _properties = frozenset(['command_name', 'hook_type', 'hook_site', 'location', 'resource_group', 'tags', 'hook_endpoint_url', 'service_id', 'apikey', 'user_state', 'ignore_inflight_operations', 'hook_id', 'registered_by', 'registered_at', 'updated_at', 'updated_by', 'sys_lock', 'last_health_checked_at'])

    def __init__(self,
                 *,
                 command_name: str = None,
                 hook_type: str = None,
                 hook_site: str = None,
                 location: str = None,
                 resource_group: str = None,
                 tags: List[str] = None,
                 hook_endpoint_url: str = None,
                 service_id: str = None,
                 apikey: str = None,
                 user_state: 'UserState' = None,
                 ignore_inflight_operations: bool = None,
                 hook_id: str = None,
                 registered_by: str = None,
                 registered_at: datetime = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 sys_lock: 'SystemLock' = None,
                 last_health_checked_at: datetime = None,
                 **kwargs) -> None:
        """
        Initialize a WebHook object.

        :param str command_name: (optional) Schematics job command name.
        :param str hook_type: (optional) Type of the Schematics web-hook.
        :param str hook_site: (optional) List of notification points.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group id for the Schematics
               web-hook.
        :param List[str] tags: (optional) Schematics web-hook tags.
        :param str hook_endpoint_url: (optional) Endpoint URL for the Schematics
               web-hook.
        :param str service_id: (optional) Service-ID to connect to the Schematics
               web-hook; if this is not provided, Schematics will used the IAM token of
               the user to connect to the Hook.
        :param str apikey: (optional) API Key for the Service ID.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param bool ignore_inflight_operations: (optional) True - Replace the Hook
               definition, without waiting for completion of all inflight Schematics
               operations;   False - Block new Schematics operations, and wait for  the
               relevant inflight operations to complete - before  changing the Hook
               definition.
        :param SystemLock sys_lock: (optional) System lock status.
        :param **kwargs: (optional) Any additional properties.
        """
        self.command_name = command_name
        self.hook_type = hook_type
        self.hook_site = hook_site
        self.location = location
        self.resource_group = resource_group
        self.tags = tags
        self.hook_endpoint_url = hook_endpoint_url
        self.service_id = service_id
        self.apikey = apikey
        self.user_state = user_state
        self.ignore_inflight_operations = ignore_inflight_operations
        self.hook_id = hook_id
        self.registered_by = registered_by
        self.registered_at = registered_at
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.sys_lock = sys_lock
        self.last_health_checked_at = last_health_checked_at
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WebHook':
        """Initialize a WebHook object from a json dictionary."""
        args = {}
        if 'command_name' in _dict:
            args['command_name'] = _dict.get('command_name')
        if 'hook_type' in _dict:
            args['hook_type'] = _dict.get('hook_type')
        if 'hook_site' in _dict:
            args['hook_site'] = _dict.get('hook_site')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'hook_endpoint_url' in _dict:
            args['hook_endpoint_url'] = _dict.get('hook_endpoint_url')
        if 'service_id' in _dict:
            args['service_id'] = _dict.get('service_id')
        if 'apikey' in _dict:
            args['apikey'] = _dict.get('apikey')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'ignore_inflight_operations' in _dict:
            args['ignore_inflight_operations'] = _dict.get('ignore_inflight_operations')
        if 'hook_id' in _dict:
            args['hook_id'] = _dict.get('hook_id')
        if 'registered_by' in _dict:
            args['registered_by'] = _dict.get('registered_by')
        if 'registered_at' in _dict:
            args['registered_at'] = string_to_datetime(_dict.get('registered_at'))
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'last_health_checked_at' in _dict:
            args['last_health_checked_at'] = string_to_datetime(_dict.get('last_health_checked_at'))
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WebHook object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'command_name') and self.command_name is not None:
            _dict['command_name'] = self.command_name
        if hasattr(self, 'hook_type') and self.hook_type is not None:
            _dict['hook_type'] = self.hook_type
        if hasattr(self, 'hook_site') and self.hook_site is not None:
            _dict['hook_site'] = self.hook_site
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'hook_endpoint_url') and self.hook_endpoint_url is not None:
            _dict['hook_endpoint_url'] = self.hook_endpoint_url
        if hasattr(self, 'service_id') and self.service_id is not None:
            _dict['service_id'] = self.service_id
        if hasattr(self, 'apikey') and self.apikey is not None:
            _dict['apikey'] = self.apikey
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'ignore_inflight_operations') and self.ignore_inflight_operations is not None:
            _dict['ignore_inflight_operations'] = self.ignore_inflight_operations
        if hasattr(self, 'hook_id') and getattr(self, 'hook_id') is not None:
            _dict['hook_id'] = getattr(self, 'hook_id')
        if hasattr(self, 'registered_by') and getattr(self, 'registered_by') is not None:
            _dict['registered_by'] = getattr(self, 'registered_by')
        if hasattr(self, 'registered_at') and getattr(self, 'registered_at') is not None:
            _dict['registered_at'] = datetime_to_string(getattr(self, 'registered_at'))
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'last_health_checked_at') and getattr(self, 'last_health_checked_at') is not None:
            _dict['last_health_checked_at'] = datetime_to_string(getattr(self, 'last_health_checked_at'))
        for _key in [k for k in vars(self).keys() if k not in WebHook._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WebHook object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WebHook') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WebHook') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class CommandNameEnum(str, Enum):
        """
        Schematics job command name.
        """
        WORKSPACE_PLAN = 'workspace_plan'
        WORKSPACE_APPLY = 'workspace_apply'
        WORKSPACE_DESTROY = 'workspace_destroy'
        WORKSPACE_REFRESH = 'workspace_refresh'
        ANSIBLE_PLAYBOOK_RUN = 'ansible_playbook_run'
        ANSIBLE_PLAYBOOK_CHECK = 'ansible_playbook_check'
        CREATE_ACTION = 'create_action'
        PUT_ACTION = 'put_action'
        PATCH_ACTION = 'patch_action'
        DELETE_ACTION = 'delete_action'
        SYSTEM_KEY_ENABLE = 'system_key_enable'
        SYSTEM_KEY_DELETE = 'system_key_delete'
        SYSTEM_KEY_DISABLE = 'system_key_disable'
        SYSTEM_KEY_ROTATE = 'system_key_rotate'
        SYSTEM_KEY_RESTORE = 'system_key_restore'
        CREATE_WORKSPACE = 'create_workspace'
        PUT_WORKSPACE = 'put_workspace'
        PATCH_WORKSPACE = 'patch_workspace'
        DELETE_WORKSPACE = 'delete_workspace'
        CREATE_CART = 'create_cart'
        CREATE_ENVIRONMENT = 'create_environment'
        PUT_ENVIRONMENT = 'put_environment'
        DELETE_ENVIRONMENT = 'delete_environment'
        ENVIRONMENT_INIT = 'environment_init'
        ENVIRONMENT_INSTALL = 'environment_install'
        ENVIRONMENT_UNINSTALL = 'environment_uninstall'
        REPOSITORY_PROCESS = 'repository_process'
        TERRAFORM_COMMANDS = 'terraform_commands'


    class HookTypeEnum(str, Enum):
        """
        Type of the Schematics web-hook.
        """
        HOOK = 'hook'
        CALLBACK = 'callback'


    class HookSiteEnum(str, Enum):
        """
        List of notification points.
        """
        BEFORE = 'before'
        ON_ERROR = 'on_error'
        ON_SUCCESS = 'on_success'


    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class WebHookList():
    """
    List of Web-hook details response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[WebHook] hooks: (optional) List of webhooks.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'hooks'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 hooks: List['WebHook'] = None,
                 **kwargs) -> None:
        """
        Initialize a WebHookList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param int total_count: (optional) Total number of records.
        :param List[WebHook] hooks: (optional) List of webhooks.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.hooks = hooks
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WebHookList':
        """Initialize a WebHookList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in WebHookList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in WebHookList JSON')
        if 'hooks' in _dict:
            args['hooks'] = [WebHook.from_dict(x) for x in _dict.get('hooks')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WebHookList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and self.total_count is not None:
            _dict['total_count'] = self.total_count
        if hasattr(self, 'limit') and self.limit is not None:
            _dict['limit'] = self.limit
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'hooks') and self.hooks is not None:
            _dict['hooks'] = [x.to_dict() for x in self.hooks]
        for _key in [k for k in vars(self).keys() if k not in WebHookList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WebHookList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WebHookList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WebHookList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class Workspace():
    """
    Complete Workspace details with user inputs and system generated data.

    :attr str name: Workspace name (unique for an account).
    :attr str description: (optional) Workspace description.
    :attr str resource_group: Resource-group name for the Workspace.  By default,
          workspace will be created in Default Resource Group.
    :attr List[str] tags: (optional) Workspace tags.
    :attr bool destroy_resources_on_delete: (optional) If true, automatically
          destroy all resources, when the workspace is deleted. Default is false.
    :attr str location: List of locations supported by IBM Cloud Schematics service.
           While creating your workspace or action, choose the right region, since it
          cannot be changed.  Note, this does not limit the location of the IBM Cloud
          resources, provisioned using Schematics.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr str command_parameter: (optional) Schematics job command parameter
          (playbook-name, capsule-name or flow-name).
    :attr List[VariableData] inputs: (optional) Input variables for the Workspace.
    :attr List[VariableData] outputs: (optional) Output variables from the
          Workspace.
    :attr List[VariableData] settings: (optional) Environment variables used by all
          the templates in the Workspace.
    :attr str id: (optional) Workspace Id.
    :attr str crn: (optional) Workspace Cloud Resource Name.
    :attr str account: (optional) Workspace account id.
    :attr datetime created_at: (optional) Workspace creation time.
    :attr str created_by: (optional) Email address of user who created the
          workspace.
    :attr datetime updated_at: (optional) Workspace updation time.
    :attr str updated_by: (optional) Email address of user who updated the
          workspace.
    :attr WorkspaceLiteState state: (optional) Computed state of the Workspace.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr List[Template] templates: (optional) Workspace Template records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'resource_group', 'tags', 'destroy_resources_on_delete', 'location', 'user_state', 'command_parameter', 'inputs', 'outputs', 'settings', 'id', 'crn', 'account', 'created_at', 'created_by', 'updated_at', 'updated_by', 'state', 'sys_lock', 'templates'])

    def __init__(self,
                 name: str,
                 resource_group: str,
                 location: str,
                 *,
                 description: str = None,
                 tags: List[str] = None,
                 destroy_resources_on_delete: bool = None,
                 user_state: 'UserState' = None,
                 command_parameter: str = None,
                 inputs: List['VariableData'] = None,
                 outputs: List['VariableData'] = None,
                 settings: List['VariableData'] = None,
                 id: str = None,
                 crn: str = None,
                 account: str = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 state: 'WorkspaceLiteState' = None,
                 sys_lock: 'SystemLock' = None,
                 templates: List['Template'] = None,
                 **kwargs) -> None:
        """
        Initialize a Workspace object.

        :param str name: Workspace name (unique for an account).
        :param str resource_group: Resource-group name for the Workspace.  By
               default, workspace will be created in Default Resource Group.
        :param str location: List of locations supported by IBM Cloud Schematics
               service.  While creating your workspace or action, choose the right region,
               since it cannot be changed.  Note, this does not limit the location of the
               IBM Cloud resources, provisioned using Schematics.
        :param str description: (optional) Workspace description.
        :param List[str] tags: (optional) Workspace tags.
        :param bool destroy_resources_on_delete: (optional) If true, automatically
               destroy all resources, when the workspace is deleted. Default is false.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param str command_parameter: (optional) Schematics job command parameter
               (playbook-name, capsule-name or flow-name).
        :param List[VariableData] inputs: (optional) Input variables for the
               Workspace.
        :param List[VariableData] outputs: (optional) Output variables from the
               Workspace.
        :param List[VariableData] settings: (optional) Environment variables used
               by all the templates in the Workspace.
        :param WorkspaceLiteState state: (optional) Computed state of the
               Workspace.
        :param SystemLock sys_lock: (optional) System lock status.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.resource_group = resource_group
        self.tags = tags
        self.destroy_resources_on_delete = destroy_resources_on_delete
        self.location = location
        self.user_state = user_state
        self.command_parameter = command_parameter
        self.inputs = inputs
        self.outputs = outputs
        self.settings = settings
        self.id = id
        self.crn = crn
        self.account = account
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.state = state
        self.sys_lock = sys_lock
        self.templates = templates
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'Workspace':
        """Initialize a Workspace object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        else:
            raise ValueError('Required property \'name\' not present in Workspace JSON')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        else:
            raise ValueError('Required property \'resource_group\' not present in Workspace JSON')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'destroy_resources_on_delete' in _dict:
            args['destroy_resources_on_delete'] = _dict.get('destroy_resources_on_delete')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        else:
            raise ValueError('Required property \'location\' not present in Workspace JSON')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'command_parameter' in _dict:
            args['command_parameter'] = _dict.get('command_parameter')
        if 'inputs' in _dict:
            args['inputs'] = [VariableData.from_dict(x) for x in _dict.get('inputs')]
        if 'outputs' in _dict:
            args['outputs'] = [VariableData.from_dict(x) for x in _dict.get('outputs')]
        if 'settings' in _dict:
            args['settings'] = [VariableData.from_dict(x) for x in _dict.get('settings')]
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'account' in _dict:
            args['account'] = _dict.get('account')
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        if 'state' in _dict:
            args['state'] = WorkspaceLiteState.from_dict(_dict.get('state'))
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'templates' in _dict:
            args['templates'] = [Template.from_dict(x) for x in _dict.get('templates')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a Workspace object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'destroy_resources_on_delete') and self.destroy_resources_on_delete is not None:
            _dict['destroy_resources_on_delete'] = self.destroy_resources_on_delete
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'command_parameter') and self.command_parameter is not None:
            _dict['command_parameter'] = self.command_parameter
        if hasattr(self, 'inputs') and self.inputs is not None:
            _dict['inputs'] = [x.to_dict() for x in self.inputs]
        if hasattr(self, 'outputs') and self.outputs is not None:
            _dict['outputs'] = [x.to_dict() for x in self.outputs]
        if hasattr(self, 'settings') and self.settings is not None:
            _dict['settings'] = [x.to_dict() for x in self.settings]
        if hasattr(self, 'id') and getattr(self, 'id') is not None:
            _dict['id'] = getattr(self, 'id')
        if hasattr(self, 'crn') and getattr(self, 'crn') is not None:
            _dict['crn'] = getattr(self, 'crn')
        if hasattr(self, 'account') and getattr(self, 'account') is not None:
            _dict['account'] = getattr(self, 'account')
        if hasattr(self, 'created_at') and getattr(self, 'created_at') is not None:
            _dict['created_at'] = datetime_to_string(getattr(self, 'created_at'))
        if hasattr(self, 'created_by') and getattr(self, 'created_by') is not None:
            _dict['created_by'] = getattr(self, 'created_by')
        if hasattr(self, 'updated_at') and getattr(self, 'updated_at') is not None:
            _dict['updated_at'] = datetime_to_string(getattr(self, 'updated_at'))
        if hasattr(self, 'updated_by') and getattr(self, 'updated_by') is not None:
            _dict['updated_by'] = getattr(self, 'updated_by')
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'templates') and getattr(self, 'templates') is not None:
            _dict['templates'] = [x.to_dict() for x in getattr(self, 'templates')]
        for _key in [k for k in vars(self).keys() if k not in Workspace._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this Workspace object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'Workspace') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'Workspace') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class WorkspaceList():
    """
    List of Workspace definition response.

    :attr int total_count: (optional) Total number of records.
    :attr int limit: Number of records returned.
    :attr int offset: Skipped number of records.
    :attr List[WorkspaceLite] workspaces: (optional) List of workspace records.
    """

    # The set of defined properties for the class
    _properties = frozenset(['total_count', 'limit', 'offset', 'workspaces'])

    def __init__(self,
                 limit: int,
                 offset: int,
                 *,
                 total_count: int = None,
                 workspaces: List['WorkspaceLite'] = None,
                 **kwargs) -> None:
        """
        Initialize a WorkspaceList object.

        :param int limit: Number of records returned.
        :param int offset: Skipped number of records.
        :param List[WorkspaceLite] workspaces: (optional) List of workspace
               records.
        :param **kwargs: (optional) Any additional properties.
        """
        self.total_count = total_count
        self.limit = limit
        self.offset = offset
        self.workspaces = workspaces
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceList':
        """Initialize a WorkspaceList object from a json dictionary."""
        args = {}
        if 'total_count' in _dict:
            args['total_count'] = _dict.get('total_count')
        if 'limit' in _dict:
            args['limit'] = _dict.get('limit')
        else:
            raise ValueError('Required property \'limit\' not present in WorkspaceList JSON')
        if 'offset' in _dict:
            args['offset'] = _dict.get('offset')
        else:
            raise ValueError('Required property \'offset\' not present in WorkspaceList JSON')
        if 'workspaces' in _dict:
            args['workspaces'] = [WorkspaceLite.from_dict(x) for x in _dict.get('workspaces')]
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceList object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'total_count') and getattr(self, 'total_count') is not None:
            _dict['total_count'] = getattr(self, 'total_count')
        if hasattr(self, 'limit') and getattr(self, 'limit') is not None:
            _dict['limit'] = getattr(self, 'limit')
        if hasattr(self, 'offset') and self.offset is not None:
            _dict['offset'] = self.offset
        if hasattr(self, 'workspaces') and self.workspaces is not None:
            _dict['workspaces'] = [x.to_dict() for x in self.workspaces]
        for _key in [k for k in vars(self).keys() if k not in WorkspaceList._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceList object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceList') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceList') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

class WorkspaceLite():
    """
    Workspace summary profile with user inputs and system generated data.

    :attr str name: (optional) Workspace name (unique for an account).
    :attr str description: (optional) Workspace description.
    :attr str id: (optional) Workspace Id.
    :attr str crn: (optional) Workspace Cloud Resource Name.
    :attr str location: (optional) List of locations supported by IBM Cloud
          Schematics service.  While creating your workspace or action, choose the right
          region, since it cannot be changed.  Note, this does not limit the location of
          the IBM Cloud resources, provisioned using Schematics.
    :attr str resource_group: (optional) Resource-group name for the Workspace.  By
          default, Workspace will be created in Default Resource Group.
    :attr List[str] tags: (optional) Workspace tags.
    :attr UserState user_state: (optional) User defined status of the Schematics
          object.
    :attr WorkspaceLiteState state: (optional) Computed state of the Workspace.
    :attr SystemLock sys_lock: (optional) System lock status.
    :attr datetime created_at: (optional) Workspace creation time.
    :attr str created_by: (optional) Email address of user who created the
          Workspace.
    :attr datetime updated_at: (optional) Workspace updation time.
    :attr str updated_by: (optional) Email address of user who updated the
          Workspace.
    """

    # The set of defined properties for the class
    _properties = frozenset(['name', 'description', 'id', 'crn', 'location', 'resource_group', 'tags', 'user_state', 'state', 'sys_lock', 'created_at', 'created_by', 'updated_at', 'updated_by'])

    def __init__(self,
                 *,
                 name: str = None,
                 description: str = None,
                 id: str = None,
                 crn: str = None,
                 location: str = None,
                 resource_group: str = None,
                 tags: List[str] = None,
                 user_state: 'UserState' = None,
                 state: 'WorkspaceLiteState' = None,
                 sys_lock: 'SystemLock' = None,
                 created_at: datetime = None,
                 created_by: str = None,
                 updated_at: datetime = None,
                 updated_by: str = None,
                 **kwargs) -> None:
        """
        Initialize a WorkspaceLite object.

        :param str name: (optional) Workspace name (unique for an account).
        :param str description: (optional) Workspace description.
        :param str id: (optional) Workspace Id.
        :param str crn: (optional) Workspace Cloud Resource Name.
        :param str location: (optional) List of locations supported by IBM Cloud
               Schematics service.  While creating your workspace or action, choose the
               right region, since it cannot be changed.  Note, this does not limit the
               location of the IBM Cloud resources, provisioned using Schematics.
        :param str resource_group: (optional) Resource-group name for the
               Workspace.  By default, Workspace will be created in Default Resource
               Group.
        :param List[str] tags: (optional) Workspace tags.
        :param UserState user_state: (optional) User defined status of the
               Schematics object.
        :param WorkspaceLiteState state: (optional) Computed state of the
               Workspace.
        :param SystemLock sys_lock: (optional) System lock status.
        :param datetime created_at: (optional) Workspace creation time.
        :param str created_by: (optional) Email address of user who created the
               Workspace.
        :param datetime updated_at: (optional) Workspace updation time.
        :param str updated_by: (optional) Email address of user who updated the
               Workspace.
        :param **kwargs: (optional) Any additional properties.
        """
        self.name = name
        self.description = description
        self.id = id
        self.crn = crn
        self.location = location
        self.resource_group = resource_group
        self.tags = tags
        self.user_state = user_state
        self.state = state
        self.sys_lock = sys_lock
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceLite':
        """Initialize a WorkspaceLite object from a json dictionary."""
        args = {}
        if 'name' in _dict:
            args['name'] = _dict.get('name')
        if 'description' in _dict:
            args['description'] = _dict.get('description')
        if 'id' in _dict:
            args['id'] = _dict.get('id')
        if 'crn' in _dict:
            args['crn'] = _dict.get('crn')
        if 'location' in _dict:
            args['location'] = _dict.get('location')
        if 'resource_group' in _dict:
            args['resource_group'] = _dict.get('resource_group')
        if 'tags' in _dict:
            args['tags'] = _dict.get('tags')
        if 'user_state' in _dict:
            args['user_state'] = UserState.from_dict(_dict.get('user_state'))
        if 'state' in _dict:
            args['state'] = WorkspaceLiteState.from_dict(_dict.get('state'))
        if 'sys_lock' in _dict:
            args['sys_lock'] = SystemLock.from_dict(_dict.get('sys_lock'))
        if 'created_at' in _dict:
            args['created_at'] = string_to_datetime(_dict.get('created_at'))
        if 'created_by' in _dict:
            args['created_by'] = _dict.get('created_by')
        if 'updated_at' in _dict:
            args['updated_at'] = string_to_datetime(_dict.get('updated_at'))
        if 'updated_by' in _dict:
            args['updated_by'] = _dict.get('updated_by')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceLite object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'name') and self.name is not None:
            _dict['name'] = self.name
        if hasattr(self, 'description') and self.description is not None:
            _dict['description'] = self.description
        if hasattr(self, 'id') and self.id is not None:
            _dict['id'] = self.id
        if hasattr(self, 'crn') and self.crn is not None:
            _dict['crn'] = self.crn
        if hasattr(self, 'location') and self.location is not None:
            _dict['location'] = self.location
        if hasattr(self, 'resource_group') and self.resource_group is not None:
            _dict['resource_group'] = self.resource_group
        if hasattr(self, 'tags') and self.tags is not None:
            _dict['tags'] = self.tags
        if hasattr(self, 'user_state') and self.user_state is not None:
            _dict['user_state'] = self.user_state.to_dict()
        if hasattr(self, 'state') and self.state is not None:
            _dict['state'] = self.state.to_dict()
        if hasattr(self, 'sys_lock') and self.sys_lock is not None:
            _dict['sys_lock'] = self.sys_lock.to_dict()
        if hasattr(self, 'created_at') and self.created_at is not None:
            _dict['created_at'] = datetime_to_string(self.created_at)
        if hasattr(self, 'created_by') and self.created_by is not None:
            _dict['created_by'] = self.created_by
        if hasattr(self, 'updated_at') and self.updated_at is not None:
            _dict['updated_at'] = datetime_to_string(self.updated_at)
        if hasattr(self, 'updated_by') and self.updated_by is not None:
            _dict['updated_by'] = self.updated_by
        for _key in [k for k in vars(self).keys() if k not in WorkspaceLite._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceLite object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceLite') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceLite') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class LocationEnum(str, Enum):
        """
        List of locations supported by IBM Cloud Schematics service.  While creating your
        workspace or action, choose the right region, since it cannot be changed.  Note,
        this does not limit the location of the IBM Cloud resources, provisioned using
        Schematics.
        """
        US_SOUTH = 'us-south'
        US_EAST = 'us-east'
        EU_GB = 'eu-gb'
        EU_DE = 'eu-de'


class WorkspaceLiteState():
    """
    Computed state of the Workspace.

    :attr str status_code: (optional) Status of automation (workspace or action).
    :attr str status_message: (optional) Automation status message - to be displayed
          along with the status_code.
    """

    # The set of defined properties for the class
    _properties = frozenset(['status_code', 'status_message'])

    def __init__(self,
                 *,
                 status_code: str = None,
                 status_message: str = None,
                 **kwargs) -> None:
        """
        Initialize a WorkspaceLiteState object.

        :param str status_code: (optional) Status of automation (workspace or
               action).
        :param str status_message: (optional) Automation status message - to be
               displayed along with the status_code.
        :param **kwargs: (optional) Any additional properties.
        """
        self.status_code = status_code
        self.status_message = status_message
        for _key, _value in kwargs.items():
            setattr(self, _key, _value)

    @classmethod
    def from_dict(cls, _dict: Dict) -> 'WorkspaceLiteState':
        """Initialize a WorkspaceLiteState object from a json dictionary."""
        args = {}
        if 'status_code' in _dict:
            args['status_code'] = _dict.get('status_code')
        if 'status_message' in _dict:
            args['status_message'] = _dict.get('status_message')
        args.update({k:v for (k, v) in _dict.items() if k not in cls._properties})
        return cls(**args)

    @classmethod
    def _from_dict(cls, _dict):
        """Initialize a WorkspaceLiteState object from a json dictionary."""
        return cls.from_dict(_dict)

    def to_dict(self) -> Dict:
        """Return a json dictionary representing this model."""
        _dict = {}
        if hasattr(self, 'status_code') and self.status_code is not None:
            _dict['status_code'] = self.status_code
        if hasattr(self, 'status_message') and self.status_message is not None:
            _dict['status_message'] = self.status_message
        for _key in [k for k in vars(self).keys() if k not in WorkspaceLiteState._properties]:
            if getattr(self, _key, None) is not None:
                _dict[_key] = getattr(self, _key)
        return _dict

    def _to_dict(self):
        """Return a json dictionary representing this model."""
        return self.to_dict()

    def __str__(self) -> str:
        """Return a `str` version of this WorkspaceLiteState object."""
        return json.dumps(self.to_dict(), indent=2)

    def __eq__(self, other: 'WorkspaceLiteState') -> bool:
        """Return `true` when self and other are equal, false otherwise."""
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other: 'WorkspaceLiteState') -> bool:
        """Return `true` when self and other are not equal, false otherwise."""
        return not self == other

    class StatusCodeEnum(str, Enum):
        """
        Status of automation (workspace or action).
        """
        NORMAL = 'normal'
        PENDING = 'pending'
        DISABLED = 'disabled'
        CRITICAL = 'critical'

