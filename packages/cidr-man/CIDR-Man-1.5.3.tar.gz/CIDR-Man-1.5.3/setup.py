# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['cidr_man']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'cidr-man',
    'version': '1.5.3',
    'description': 'CIDR-Man is a high-performance ipaddress subnetting library designed to replace the built-in ipaddress library.',
    'long_description': '# CIDR-Man\n![Release Badge](https://gitlab.com/geoip.network/cidr_man/-/badges/release.svg)\n![Pipeline Badge](https://gitlab.com/geoip.network/cidr_man/badges/main/pipeline.svg)\n\nBuilt due to frustrations with python\'s built-in `ipaddress` library\'s performance, code complexity, and accuracy.\nCIDR-Man is an accurate high-performance IP address subnetting library.\n\n![An attractive screenshot of the example code below](https://gitlab.com/geoip.network/cidr_man/-/raw/main/screenshots/screenshot.png?inline=true)\n\nWhile the interface of this new library is a little different from that of the built-in library, we think you\'ll find it to be more "pythonic", and quite intuitive.\n\n*NOTE: While writing tests for this library we discovered that a number of the `is_<address type>` flags from the python built-in library were returning incorrect results. CIDR-Man is accurate as per the RFCs at the time of writing, thus our responses may differ.*\n\n## Key performance metrics (vs Built-in `ipaddress`)\n* `__init__`:    7.822x\n* `supernet`:    2.186x\n* `subnet_of`:   8.516x\n* `subnets`:     3.966x\n* `compressed`:  1.303x\n\n## CIDRs explained\nCIDR (or Classless Inter-Domain Routing) is a way of representing and handling IP addresses and networks. \nIntroduced in 1993 to replace the previous IP address class architecture, CIDRs offer more flexibility in addressing hierarchy in network designs.\nA block of IP addresses in CIDR notation would be represented as the first IP in the block followed by the number of bits in the bitmask separated by a forward slash. \n\nFor example, the CIDR 192.0.2.0/24 represents an IP address block spanning 192.0.2.0 to 192.0.2.255.\nExpanding this out we get the following:\n\n    Network:                                192.0.2.0\n    Network (as binary):                    11000000000000000000001000000000\n    Netmask:                                255.255.255.0\n    Netmask (as binary):                    11111111111111111111111100000000\n    Broadcast IP:                           192.0.2.255\n    Broadcast IP (as binary):               11000000000000000000001011111111\n    First usable IP (normally the Gateway): 192.0.2.1\n    First usable IP (as binary):            11000000000000000000001000000001\n    Last usable IP:                         192.0.2.255\n    Last usable IP (as binary):             11000000000000000000001011111110\n\nUsing this representation a single IP address is simply one with a full bitmask, thus 192.0.2.1/32 is the same as 192.0.2.1.\n\nThis means that our network subnetting library only needs a single class `CIDR`. \nUtilising a single type `CIDR` to represent both network objects and individual addresses results in considerably more concise code.\n\n## Usage\n### Initialisation\n\nInitialising a new CIDR object is easy and supports all common input types (presentation format, integer format, network/big-endian byte format, and built-in IP & Network types).\n```python\nfrom cidr_man import CIDR, Version\n\n## Create from string (presentation format)\nnetwork = CIDR("192.0.2.0/24")\nip = CIDR("192.0.2.1")\n\nnetwork_v6 = CIDR("2001:db8::/56")\nmachine_alloc_v6 = CIDR("2001:db8::/64")\nip_v6 = CIDR("2001:db8::1")\n\n## Create from built-in\nnetwork = CIDR(IPv4Network("192.0.2.0/24"))\nip = CIDR(IPv4Address("192.0.2.1"))\n\nnetwork_v6 = CIDR(IPv6Network("2001:db8::/56"))\nmachine_alloc_v6 = CIDR(IPv6Network("2001:db8::/64"))\nip_v6 = CIDR(IPv6Address("2001:db8::1"))\n\n\n## Create from integer\nnetwork = CIDR(3221225984, version=Version.v4, prefix_len=24)\nip = CIDR(3221225985, version=Version.v4)\n\nnetwork_v6 = CIDR(42540766411282592856903984951653826560, version=Version.v6, prefix_len=56)\nip_v6 = CIDR(42540766411282592856903984951653826561, version=Version.v6)\n\n\n## Create from byte\nnetwork = CIDR(b\'\\xc0\\x00\\x02\\x01\', prefix_len=24)\nip = CIDR(b\'\\xc0\\x00\\x02\\x01\')\n\nnetwork_v6 = CIDR(b\' \\x01\\r\\xb8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\', prefix_len=56)\nip_v6 = CIDR(b\' \\x01\\r\\xb8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\')\n```\n\n## Get subnets\nRetrieving the direct subnets of a network is easy.\n\nTo get the pair\n```python\nnetwork = CIDR("192.0.2.0/24")\nsubnets = network.subnets  # (CIDR("192.0.2.0/25"), CIDR("192.0.2.128/25"))\n```\nTo get only the "left" (low-bit subnet)\n```python\nleft = network.left  # CIDR("192.0.2.0/25")\n```\nTo get only the "right" (high-bit subnet)\n```python\nright = network.right  # CIDR("192.0.2.128/25")\n```\nThese can be chained for quick traversal\n```python\nleft_of_left = network.left.left  # CIDR("192.0.2.0/26")\nright_of_left = network.left.right  # CIDR(192.0.2.64/26")\n```\n\n## Get supernets\nRetrieving the direct supernet of a network is easy.\n\n```python\nnetwork = CIDR("192.0.2.0/25")\nsupernet = network.supernet()  # CIDR("192.0.2.0/24")\n```\n\n\n## Contains\nChecking if an address or network is the subnet of another is made simpler, with `subnet in supernet` syntax fully supported.\n```python\nnetwork_1 = CIDR("192.0.2.0/24")\nnetwork_2 = CIDR("192.0.2.0/26")\n\nresult = network_2 in network_1\n# or \nresult = network_1.contains(network_2)\n```\n\nAlternatively if you prefer the built-in library\'s style we\'ve included `subnet_of` for compatibility.\n```python\nnetwork_2.subnet_of(network_1)\n```\n\nAs well as additional support for `subnet < supernet`,`subnet <= supernet`,`subnet > supernet`, `subnet >= supernet`, and `subnet == supernet`\n*NOTE: These are perhaps counter-intuitive as this in the inverse of the size of the address space, but as this is how python\'s library defines the operations we\'re maintaining compatibility\n```python\nsubnet < supernet   # Returns True if subnet has less specific prefix than supernet \nsubnet <= supernet  # Returns True if subnet has a less than or equal prefix than supernet\nsubnet > supernet   # Returns True if subnet has a less specific prefix than supernet\nsubnet >= supernet  # Returns True if subnet has a greater than or equal prefix supernet\nsubnet == supernet  # Returns True if subnet is exactly equal to supernet\n```\n\n\n## Packed (Byte format)\n```python\nip_b = ip.packed  # b\'\\xc0\\x00\\x02\\x01\'\n\nipv6_b = ip.packed  # b\' \\x01\\r\\xb8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\'\n```\n\n## Compressed (String / Presentation format)\nCIDRs that have a `prefix_len` equal to the maximum for their IP version (that is 32 for IPv4, and 128 for IPv6) will be presented in IP presentation format.\nTherefore, both `CIDR("192.0.2.1")` and `CIDR("192.0.2.1/32")` produce the presentation format `"192.0.2.1"`.\n```python\n# IPv4\n\nip_s = ip.compressed                # "192.0.2.1"\n### or\nip_s = str(ip)                      # "192.0.2.1"\n\n\n## CIDRs who\'s prefix is not the max_prefix are presented in CIDR presentation format\nnetwork_s = network.compressed      # "192.0.2.0/24"\n### or\nnetwork_s = str(ip)                 # "192.0.2.0/24"\n\n\n# IPv6\nipv6_s = ip.compressed              # "2001:db8::1"\n### or\nipv6_s = str(ip)                    # "2001:db8::1"\n\n\nnetwork_v6_s = network.compressed   # "2001:db8::/56"\n## or\nnetwork_v6_s = str(ip)              # "2001:db8::/56"\n```\n\n## Important addresses\n`network_address`, `broadcast_address`, `netmask`, `inverse_netmask`, `first_address`, and `last_address` each provide the relevant addresses as new CIDR objects.\n```python\n# IPv4\nnet_address         = network.network_address   # 192.0.2.0\nfirst_address       = network.first_address     # 192.0.2.1\nlast_address        = network.last_address      # 192.0.2.254\nbroadcast_address   = network.network_address   # 192.0.2.255\nnetmask             = network.netmask           # 255.255.255.0\ninverse_netmask     = network.inverse_netmask   # 0.0.0.255\n\n# IPv6\nnet_address_v6         = network_v6.network_address  # 2001:db8::\nfirst_address_v6       = network_v6.first_address    # 2001:db8::1\nlast_address_v6        = network_v6.last_address     # 2001:db8:0:ff:ffff:ffff:ffff:fffe\nbroadcast_address_v6   = network_v6.network_address  # 2001:db8:0:ff:ffff:ffff:ffff:ffff\nnetmask_v6             = network_v6.netmask          # ffff:ffff:ffff:ff00::\ninverse_netmask_v6     = network_v6.inverse_netmask  # ::ff:ffff:ffff:ffff:ffff\n```\n\n## is_ flags\n\n*NOTE: While writing tests for this library we discovered that a number of the `is_<address type>` flags from the python built-in library were returning incorrect results. CIDR-Man is accurate as per the RFCs at the time of writing, thus our responses may differ.*\n```python\nis_multicast    = network.is_multicast  # True if the address is reserved for multicast use by RFCs.\nis_global       = network.is_global     # True if the address is allocated for public networks.\nis_private      = network.is_private    # True if the address is allocated for private networks.\nis_reserved     = network.is_reserved   # True if the address is otherwise IETF reserved.\nis_loopback     = network.is_loopback   # True if this is a loopback address.\nis_link_local   = network.is_link_local # True if the address is reserved for link-local usage.\n```\n\n\n## Installation (from pip):\n```shell\npip install cidr_man\n```\n\n## Installation (from source):\n```shell\ngit clone https://gitlab.com/geoip.network/cidr_man\npoetry install\n```\n\n## Theme song\nCIDR-Man, CIDR-Man, Does what ever a CIDR can... \n\n*Thwip! Thwip! """""""""""""""""""""""""""""""""""""""""""""""""*',
    'author': 'Tim Armstrong',
    'author_email': 'tim@plaintextnerds.com',
    'maintainer': 'Tim Armstrong',
    'maintainer_email': 'tim@plaintextnerds.com',
    'url': 'https://geoip.network/',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.7,<3.11',
}


setup(**setup_kwargs)
