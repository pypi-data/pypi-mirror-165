{"version":3,"sources":["index.tsx"],"names":["document","getElementById","body","appendChild","createElement","setAttribute","innerHTML","margin","width","height","Streamlit","events","addEventListener","RENDER_EVENT","event","d3","remove","svg","append","attr","style","data","detail","dic","args","key","size","words","length","allNodes","map","d","id","x","range","domain","nodes","selectAll","enter","ans","undefined","text","tag","arcs","start","toString","end","join","dir","label","on","a","zoom","scaleExtent","e","transform","call","setFrameHeight","setComponentReady"],"mappings":"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","file":"static/js/main.ce3bc050.chunk.js","sourcesContent":["import { Streamlit, RenderData } from \"streamlit-component-lib\"\nimport * as d3 from \"d3\"\n\n// Add text and a button to the DOM. (You could also add these directly\n// to index.html.)\n\ninterface word { text: string, tag: string, id: number }\ninterface arc { start: number, end: number, label: string, dir: string }\n\n//create a base div\nif (document.getElementById('diag')==null){\n  const div = document.body.appendChild(document.createElement(\"div\"))\n  div.setAttribute('id', 'diag')\n}else{\n  const ele = document.getElementById('diag')\n  ele!.innerHTML=''\n}\n\n//var allNodes = data.words.map(function (d:word) { return d.text })\n// Add a click handler to our button. It will send data back to Streamlit.\n\nvar margin = { top: 20, right: 30, bottom: 20, left: 30 },\n  width = 1200 - margin.left - margin.right,\n  height = 400 - margin.top - margin.bottom\n /* \nd3.select(\"svg\").remove();\nvar svg = d3.select('#diag')\n  .append(\"svg\")\n  .attr(\"width\", width + margin.left + margin.right)\n  .attr(\"height\", height + margin.top + margin.bottom)\n  .style(\"background-color\", \"white\")\n  .append(\"g\")\n  .attr(\"transform\",\n    \"translate(\" + margin.left + \",\" + margin.top + \")\")\n*/\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  //on render,remove the svg and reappend the svg\n  d3.select(\"svg\").remove()\n  var svg = d3.select('#diag')\n  .append(\"svg\")\n  .attr(\"width\", width + margin.left + margin.right)\n  .attr(\"height\", height + margin.top + margin.bottom)\n  .style(\"background-color\", \"white\")\n  .append(\"g\")\n  .attr(\"transform\",\n    \"translate(\" + margin.left + \",\" + margin.top + \")\")\n  const data = (event as CustomEvent<RenderData>).detail\n  const dic = data.args['data']\n  const key = data.args['key']\n  let size = dic.words.length * 75\n  const div = document.body.appendChild(document.createElement(\"div\"))\n  div.setAttribute('id', 'diag')\n  const allNodes = dic.words.map(function (d: word) { return d.id })\n  document.getElementById('diag')?.setAttribute('id',`${key}`)\n  const x = d3.scalePoint()\n    .range([0, size])\n    .domain(allNodes)\n  // creating node\n  const nodes = svg\n    .selectAll(\"mynodes\")\n    .data(dic.words)\n    .enter()\n    .append(\"circle\")\n    .attr(\"cx\", function (d: any) {\n      let ans = x(d.id)\n      if (ans === undefined) {\n        return null\n      }\n      else {\n        return ans\n      }\n    })\n    .attr(\"cy\", height - 30)\n    .attr(\"r\", 10)\n    .style(\"fill\", \"#69b3a2\")\n\n  //create the words' text\n  const labels = svg\n    .selectAll(\"mylabels\")\n    .data(dic.words)\n    .enter()\n    .append(\"text\")\n    .attr(\"x\", function (d: any) {\n      let ans = x(d.id)\n      if (ans === undefined) {\n        return null\n      }\n      else {\n        return ans\n      }\n    })\n    .attr(\"y\", height - 5)\n    .text(function (d: any) { return (d.text) })\n    .style(\"text-anchor\", \"middle\")\n  //create the words' tag\n  const tags = svg\n    .selectAll(\"mylabels\")\n    .data(dic.words)\n    .enter()\n    .append(\"text\")\n    .attr(\"x\", function (d: any) {\n      let ans = x(d.id)\n      if (ans === undefined) {\n        return null\n      }\n      else {\n        return ans\n      }\n    })\n    .attr(\"y\", height + 15)\n    .text(function (d: any) { return (d.tag) })\n    .style(\"text-anchor\", \"middle\")\n\n  const markers = svg.append(\"svg:defs\").selectAll(\"marker\")\n    .data(dic.arcs)      // Different link/path types can be defined here\n    .enter().append(\"svg:marker\")\n    .attr(\"id\", function (d: any) {\n      return d.start.toString() + d.end.toString()\n    })    // This section adds in the arrows\n    .attr(\"viewBox\", \"0 -5 10 10\")\n    .attr(\"refX\", 8)\n    .attr(\"refY\", 0)\n    .attr(\"markerWidth\", 10)\n    .attr(\"markerHeight\", 10)\n    .attr(\"orient\", 'auto-start-reverse')\n    .append(\"svg:path\")\n    .attr(\"d\", \"M0,-5L10,0L0,5\")\n    .attr('class','color_change_marker')\n    //.style('fill','black')\n\n  //create the path from one word to another\n  const links = svg\n    .selectAll('mylinks')\n    .data(dic.arcs)\n    .join('path')\n    .attr('id', function (d: any) {\n      if (d === undefined) { return '' }\n      else {\n        return d.start.toString() +'_'+ d.end.toString()\n      }\n    })\n    .attr('d', function (d: any) {\n      let start = x(dic.words[d.start].id)    // X position of start node on the X axis\n      let end = x(dic.words[d.end].id)      // X position of end node\n      if (start === undefined) {\n        start = 0\n      }\n      if (end === undefined) {\n        end = 0\n      }\n      //M x y (M = move to)\n      // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n      // rx - x radius\n      // ry - y radius\n\n      //to prevent the arcs from overcrowding at a point, count the total points to ending spot\n      //space them out\n\n      return ['M', start < end ? start : end, height - 30,    // the arc starts at the coordinate x=start, y=height-30 (where the starting node is)\n        'A',                            // This means we're gonna build an elliptical arc\n        start < end ? (start - end) / 2 : (end - start) / 2,    // Next 2 lines are the coordinates of the inflexion point. Height of this point is proportional with start - end distance\n        start < end ? (start - end) / 2 : (end - start) / 2, 0, 0,\n        1, start < end ? end : start, ',', height - 30] // We always want the arc on top. So if end is before start, putting 0 here turn the arc upside down.\n        .join(' ');\n    })\n    .style(\"fill\", \"none\")\n    .attr(\"stroke\", \"black\")\n    .attr('stroke-width', 1)\n    .attr('class', 'color_change_path')\n    .attr(\"marker-end\", function (d: any) {\n      if (d.dir === 'right') {\n        return \"url(#\" + d.start.toString() + d.end.toString() + \")\"\n      }\n      else return 'none'\n    })\n    .attr(\"marker-start\", function (d: any) {\n      if (d.dir === 'left') {\n        return \"url(#\" + d.start.toString() + d.end.toString() + \")\"\n      }\n      else return 'none'\n    })\n\n\n\n  //create the dep tag on the path\n  var text_labels = svg.selectAll(\"myText_labels\")\n    .data(dic.arcs)\n    .enter()\n    .append(\"text\")\n    .attr('dy', -5)\n\n  text_labels.append(\"textPath\")\n    .attr(\"xlink:href\", function (d: any) {\n      if (d === undefined) return ''\n      else {\n        return '#' + d.start.toString() +'_'+ d.end.toString()\n      }\n    })\n    .attr('text-anchor', \"middle\")\n    .attr('startOffset', '50%')\n    .attr('class', 'dep')\n    .text(function (d: any) { return d.label })\n\n  // Add the highlighting functionality\n  nodes\n    .on('mouseout', function (event, d) {\n      nodes.style('fill', \"#69b3a2\")\n      d3.selectAll('.color_change_path')\n        .style('stroke', 'black')\n        .style('stroke-width', 1)\n      d3.selectAll('.color_change_marker').style('fill', 'black')\n    })\n    .on('mouseover', function (event, d) {\n      nodes.style('fill', \"#b8b8b8\")\n      // Highlight the paths\n      d3.selectAll('.color_change_path')\n      .style('stroke', function (a: any) {\n        return dic.words[a.start] === d || dic.words[a.end] === d ? '#69b3b2' : '#b8b8b8'\n      })\n      .style('stroke-width', function (a: any) {\n        return (dic.words[a.start] === d || dic.words[a.end] === d ? 2 : 1)\n      })\n      // Highlight marker\n      d3.selectAll('.color_change_marker')        \n      .style('fill', function (a: any) {\n        return dic.words[a.start] === d || dic.words[a.end] === d ? '#69b3b2' : '#b8b8b8'\n      })\n\n      /*\n      links\n        .style('stroke', function (a: any) {\n          return dic.words[a.start] === d || dic.words[a.end] === d ? '#69b3b2' : '#b8b8b8'\n        })\n        .style('stroke-width', function (a: any) {\n          return (dic.words[a.start] === d || dic.words[a.end] === d ? 2 : 1)\n        })\n      markers\n        .style('fill', function (a: any) {\n          return dic.words[a.start] === d || dic.words[a.end] === d ? '#69b3b2' : '#b8b8b8'\n        })*/\n    })\n\n  //zooming and panning functionality\n  function handleZoom(e: any) {\n    d3.select('svg g')\n      .attr('transform', e.transform)\n  }\n  const zoom = d3.zoom()\n    .scaleExtent([0.2, 100])\n    //.translateExtent([[-size, -height], [size*2, height*3]])\n    .on('zoom', handleZoom) as any\n  d3.select('svg').call(zoom)\n\n  // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n  Streamlit.setFrameHeight()\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"],"sourceRoot":""}