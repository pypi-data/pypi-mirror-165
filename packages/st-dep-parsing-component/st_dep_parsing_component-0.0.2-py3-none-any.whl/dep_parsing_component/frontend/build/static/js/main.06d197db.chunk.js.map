{"version":3,"sources":["index.tsx"],"names":["document","getElementById","body","appendChild","createElement","setAttribute","innerHTML","margin","width","height","svg","d3","append","attr","style","Streamlit","events","addEventListener","RENDER_EVENT","event","dic","detail","args","size","words","length","allNodes","map","d","id","x","range","domain","nodes","selectAll","data","enter","ans","undefined","text","tag","arcs","start","toString","end","join","dir","label","on","a","zoom","scaleExtent","e","transform","call","setFrameHeight","setComponentReady"],"mappings":"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","file":"static/js/main.06d197db.chunk.js","sourcesContent":["import { Streamlit, RenderData } from \"streamlit-component-lib\"\nimport * as d3 from \"d3\"\n\n// Add text and a button to the DOM. (You could also add these directly\n// to index.html.)\n\ninterface word { text: string, tag: string, id: number }\ninterface arc { start: number, end: number, label: string, dir: string }\n\nif (document.getElementById('diag')==null){\n  const div = document.body.appendChild(document.createElement(\"div\"))\n  div.setAttribute('id', 'diag')\n}else{\n  const ele = document.getElementById('diag')\n  ele!.innerHTML=''\n}\n\n//var allNodes = data.words.map(function (d:word) { return d.text })\n// Add a click handler to our button. It will send data back to Streamlit.\n\nvar margin = { top: 20, right: 30, bottom: 20, left: 30 },\n  width = 1200 - margin.left - margin.right,\n  height = 400 - margin.top - margin.bottom\n\nvar svg = d3.select('#diag')\n  .append(\"svg\")\n  .attr(\"width\", width + margin.left + margin.right)\n  .attr(\"height\", height + margin.top + margin.bottom)\n  .style(\"background-color\", \"white\")\n  .append(\"g\")\n  .attr(\"transform\",\n    \"translate(\" + margin.left + \",\" + margin.top + \")\")\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n  const dic = data.args['data']\n\n  let size = dic.words.length * 75\n\n  const allNodes = dic.words.map(function (d: word) { return d.id })\n\n  const x = d3.scalePoint()\n    .range([0, size])\n    .domain(allNodes)\n  // creating node\n  const nodes = svg\n    .selectAll(\"mynodes\")\n    .data(dic.words)\n    .enter()\n    .append(\"circle\")\n    .attr(\"cx\", function (d: any) {\n      let ans = x(d.id)\n      if (ans === undefined) {\n        return null\n      }\n      else {\n        return ans\n      }\n    })\n    .attr(\"cy\", height - 30)\n    .attr(\"r\", 10)\n    .style(\"fill\", \"#69b3a2\")\n\n  //create the words' text\n  const labels = svg\n    .selectAll(\"mylabels\")\n    .data(dic.words)\n    .enter()\n    .append(\"text\")\n    .attr(\"x\", function (d: any) {\n      let ans = x(d.id)\n      if (ans === undefined) {\n        return null\n      }\n      else {\n        return ans\n      }\n    })\n    .attr(\"y\", height - 5)\n    .text(function (d: any) { return (d.text) })\n    .style(\"text-anchor\", \"middle\")\n  //create the words' tag\n  const tags = svg\n    .selectAll(\"mylabels\")\n    .data(dic.words)\n    .enter()\n    .append(\"text\")\n    .attr(\"x\", function (d: any) {\n      let ans = x(d.id)\n      if (ans === undefined) {\n        return null\n      }\n      else {\n        return ans\n      }\n    })\n    .attr(\"y\", height + 15)\n    .text(function (d: any) { return (d.tag) })\n    .style(\"text-anchor\", \"middle\")\n\n  const markers = svg.append(\"svg:defs\").selectAll(\"marker\")\n    .data(dic.arcs)      // Different link/path types can be defined here\n    .enter().append(\"svg:marker\")\n    .attr(\"id\", function (d: any) {\n      return d.start.toString() + d.end.toString()\n    })    // This section adds in the arrows\n    .attr(\"viewBox\", \"0 -5 10 10\")\n    .attr(\"refX\", 8)\n    .attr(\"refY\", 0)\n    .attr(\"markerWidth\", 10)\n    .attr(\"markerHeight\", 10)\n    .attr(\"orient\", 'auto-start-reverse')\n    .append(\"svg:path\")\n    .attr(\"d\", \"M0,-5L10,0L0,5\")\n    .attr('class','color_change_marker')\n    //.style('fill','black')\n\n  //create the path from one word to another\n  const links = svg\n    .selectAll('mylinks')\n    .data(dic.arcs)\n    .join('path')\n    .attr('id', function (d: any) {\n      if (d === undefined) { return '' }\n      else {\n        return d.start.toString() +'_'+ d.end.toString()\n      }\n    })\n    .attr('d', function (d: any) {\n      let start = x(dic.words[d.start].id)    // X position of start node on the X axis\n      let end = x(dic.words[d.end].id)      // X position of end node\n      if (start === undefined) {\n        start = 0\n      }\n      if (end === undefined) {\n        end = 0\n      }\n      //M x y (M = move to)\n      // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n      // rx - x radius\n      // ry - y radius\n\n      //to prevent the arcs from overcrowding at a point, count the total points to ending spot\n      //space them out\n\n      return ['M', start < end ? start : end, height - 30,    // the arc starts at the coordinate x=start, y=height-30 (where the starting node is)\n        'A',                            // This means we're gonna build an elliptical arc\n        start < end ? (start - end) / 2 : (end - start) / 2,    // Next 2 lines are the coordinates of the inflexion point. Height of this point is proportional with start - end distance\n        start < end ? (start - end) / 2 : (end - start) / 2, 0, 0,\n        1, start < end ? end : start, ',', height - 30] // We always want the arc on top. So if end is before start, putting 0 here turn the arc upside down.\n        .join(' ');\n    })\n    .style(\"fill\", \"none\")\n    .attr(\"stroke\", \"black\")\n    .attr('stroke-width', 1)\n    .attr('class', 'color_change_path')\n    .attr(\"marker-end\", function (d: any) {\n      if (d.dir === 'right') {\n        return \"url(#\" + d.start.toString() + d.end.toString() + \")\"\n      }\n      else return 'none'\n    })\n    .attr(\"marker-start\", function (d: any) {\n      if (d.dir === 'left') {\n        return \"url(#\" + d.start.toString() + d.end.toString() + \")\"\n      }\n      else return 'none'\n    })\n\n\n\n  //create the dep tag on the path\n  var text_labels = svg.selectAll(\"myText_labels\")\n    .data(dic.arcs)\n    .enter()\n    .append(\"text\")\n    .attr('dy', -5)\n\n  text_labels.append(\"textPath\")\n    .attr(\"xlink:href\", function (d: any) {\n      if (d === undefined) return ''\n      else {\n        return '#' + d.start.toString() +'_'+ d.end.toString()\n      }\n    })\n    .attr('text-anchor', \"middle\")\n    .attr('startOffset', '50%')\n    .attr('class', 'dep')\n    .text(function (d: any) { return d.label })\n\n  // Add the highlighting functionality\n  nodes\n    .on('mouseout', function (event, d) {\n      nodes.style('fill', \"#69b3a2\")\n      d3.selectAll('.color_change_path')\n        .style('stroke', 'black')\n        .style('stroke-width', 1)\n      d3.selectAll('.color_change_marker').style('fill', 'black')\n    })\n    .on('mouseover', function (event, d) {\n      nodes.style('fill', \"#b8b8b8\")\n      // Highlight the paths\n      d3.selectAll('.color_change_path')\n      .style('stroke', function (a: any) {\n        return dic.words[a.start] === d || dic.words[a.end] === d ? '#69b3b2' : '#b8b8b8'\n      })\n      .style('stroke-width', function (a: any) {\n        return (dic.words[a.start] === d || dic.words[a.end] === d ? 2 : 1)\n      })\n      // Highlight marker\n      d3.selectAll('.color_change_marker')        \n      .style('fill', function (a: any) {\n        return dic.words[a.start] === d || dic.words[a.end] === d ? '#69b3b2' : '#b8b8b8'\n      })\n\n      /*\n      links\n        .style('stroke', function (a: any) {\n          return dic.words[a.start] === d || dic.words[a.end] === d ? '#69b3b2' : '#b8b8b8'\n        })\n        .style('stroke-width', function (a: any) {\n          return (dic.words[a.start] === d || dic.words[a.end] === d ? 2 : 1)\n        })\n      markers\n        .style('fill', function (a: any) {\n          return dic.words[a.start] === d || dic.words[a.end] === d ? '#69b3b2' : '#b8b8b8'\n        })*/\n    })\n\n  //zooming and panning functionality\n  function handleZoom(e: any) {\n    d3.select('svg g')\n      .attr('transform', e.transform)\n  }\n  const zoom = d3.zoom()\n    .scaleExtent([0.2, 100])\n    //.translateExtent([[-size, -height], [size*2, height*3]])\n    .on('zoom', handleZoom) as any\n  d3.select('svg').call(zoom)\n\n  // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n  Streamlit.setFrameHeight()\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"],"sourceRoot":""}