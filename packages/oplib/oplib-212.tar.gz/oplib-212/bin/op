#!/usr/bin/env python3
# This file is placed in the Public Domain.
# pylint: disable=E1101,E0611,C0115,C0116,C0413,C0411,W0406


"client"


import os
import readline
import sys
import termios
import threading
import time


sys.path.insert(0, os.getcwd())


from op.bus import Bus
from op.clt import Client
from op.evt import Event
from op.obj import Object, get, update
from op.prs import parse
from op.run import docmd, starttime
from op.scn import scan
from op.tbl import Commands
from op.utl import elapsed, getname
from op.wdr import Wd


Wd.workdir = os.path.expanduser("~/.op")


class CLI(Client):

    @staticmethod
    def raw(txt):
        print(txt)


class Console(CLI):

    @staticmethod
    def handle(event):
        Client.handle(event)
        event.wait()

    def poll(self):
        event = Event()
        event.txt = input("> ")
        event.orig = repr(self)
        return event


def wrap(func):
    fds = sys.stdin.fileno()
    gotterm = True
    try:
        old = termios.tcgetattr(fds)
    except termios.error:
        gotterm = False
    readline.redisplay()
    try:
        func()
    except (EOFError, KeyboardInterrupt):
        print("")
    finally:
        if gotterm:
            termios.tcsetattr(fds, termios.TCSADRAIN, old)


def cmd(event):
    event.reply(",".join(sorted(Commands.cmds)))


def flt(event):
    try:
        index = int(event.args[0])
        event.reply(Bus.objs[index])
        return
    except (KeyError, TypeError, IndexError, ValueError):
        pass
    event.reply(" | ".join([getname(o) for o in Bus.objs]))


def thr(event):
    result = []
    for thread in sorted(threading.enumerate(), key=lambda x: x.getName()):
        if str(thread).startswith("<_"):
            continue
        obj = Object()
        update(obj, vars(thread))
        if get(obj, "sleep", None):
            uptime = obj.sleep - int(time.time() - obj.state.latest)
        else:
            uptime = int(time.time() - starttime)
        result.append((uptime, thread.getName()))
    res = []
    for uptime, txt in sorted(result, key=lambda x: x[0]):
        res.append("%s/%s" % (txt, elapsed(uptime)))
    if res:
        event.reply(" ".join(res))
    else:
        event.reply("no threads running")


def upt(event):
    event.reply(elapsed(time.time()-starttime))


mod = __import__("__main__")


scan(mod)


def main():
    txt = ' '.join(sys.argv[1:])
    cfg = parse(txt)
    if cfg.txt:
        cli = CLI()
        docmd(cli, cfg.otxt)
    elif "c" in cfg.opts:
        csl = Console()
        csl.start()
        csl.forever()


wrap(main)
